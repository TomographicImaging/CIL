

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Optimisation framework &#8212; CIL 23.1.0 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="icon" sizes="32x32" type="image/png" href="https://ccpi.ac.uk/wp-content/uploads/2022/11/cropped-CCPi_Logo_Icon_Only-32x32.png" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'optimisation';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = '/CIL/versions.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = '23.1.0';
        </script>
    <link rel="index" title="Index" href="../genindex/" />
    <link rel="search" title="Search" href="../search/" />
    <link rel="next" title="Processors" href="../processors/" />
    <link rel="prev" title="Read/ write AcquisitionData and ImageData" href="../io/" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search/"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
<div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
    <span class="fa-solid fa-bars"></span>
  </label>
  
  <div class="navbar-header-items__start">
    
      <div class="navbar-item">
  

<a class="navbar-brand logo" href="../">
  
  
  
  
    
    
      
    
    
    <img src="https://ccpi.ac.uk/wp-content/uploads/2022/11/CIL-logo-RGB.svg" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="https://ccpi.ac.uk/wp-content/uploads/2022/11/CIL-logo-RGB-reversed.svg" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
    
  </div>
  
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../introduction/">
                        Introduction
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../framework/">
                        Framework
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../io/">
                        Read/ write AcquisitionData and ImageData
                      </a>
                    </li>
                

                    <li class="nav-item current active">
                      <a class="nav-link nav-internal" href="#">
                        Optimisation framework
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../processors/">
                        Processors
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../recon/">
                        Recon
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../utilities/">
                        Utilities
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../plugins/">
                        CIL Plugins
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../developer_guide/">
                        Developers’ Guide
                      </a>
                    </li>
                
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
      
        <div class="navbar-item">
<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script></div>
      
    </div>
    
  </div>
  
  

  
</div>

    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../introduction/">
                        Introduction
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../framework/">
                        Framework
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../io/">
                        Read/ write AcquisitionData and ImageData
                      </a>
                    </li>
                

                    <li class="nav-item current active">
                      <a class="nav-link nav-internal" href="#">
                        Optimisation framework
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../processors/">
                        Processors
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../recon/">
                        Recon
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../utilities/">
                        Utilities
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../plugins/">
                        CIL Plugins
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../developer_guide/">
                        Developers’ Guide
                      </a>
                    </li>
                
  </ul>
</nav></div>
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">
<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<form class="bd-search d-flex align-items-center"
      action="../search/"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
        <div class="sidebar-primary-item">
<script>
document.write(`
  <div class="version-switcher__container dropdown">
    <button type="button" class="version-switcher__button btn btn-sm navbar-btn dropdown-toggle" data-bs-toggle="dropdown">
      23.1.0  <!-- this text may get changed later by javascript -->
      <span class="caret"></span>
    </button>
    <div class="version-switcher__menu dropdown-menu list-group-flush py-0">
    <!-- dropdown will be populated by javascript on page load -->
    </div>
  </div>
`);
</script></div>
        <div class="sidebar-primary-item">
<h3><a href="../">Table of Contents</a></h3>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../framework/">Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../io/">Read/ write AcquisitionData and ImageData</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Optimisation framework</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#algorithms">Algorithms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#base-class">Base class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#gd">GD</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cgls">CGLS</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sirt">SIRT</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ista">ISTA</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fista">FISTA</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pdhg">PDHG</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ladmm">LADMM</a></li>
<li class="toctree-l3"><a class="reference internal" href="#spdhg">SPDHG</a></li>
<li class="toctree-l3"><a class="reference internal" href="#callbacks">Callbacks</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#operators">Operators</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#operator-base-classes">Operator base classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#trivial-operators">Trivial operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#gradientoperator">GradientOperator</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#functions">Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#base-classes">Base classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simple-functions">Simple functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#composition-of-operator-and-a-function">Composition of operator and a function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#indicator-box">Indicator box</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kullbackleibler">KullbackLeibler</a></li>
<li class="toctree-l3"><a class="reference internal" href="#l1-norm">L1 Norm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#l2-norm-squared">L2 Norm Squared</a></li>
<li class="toctree-l3"><a class="reference internal" href="#least-squares">Least Squares</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mixed-l21-norm">Mixed L21 norm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#smooth-mixed-l21-norm">Smooth Mixed L21 norm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mixed-l11-norm">Mixed L11 norm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#total-variation">Total variation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#utilities">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#samplers">Samplers</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#block-framework">Block Framework</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#blockdatacontainer">BlockDataContainer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#block-function">Block Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="#block-operator">Block Operator</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../processors/">Processors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../recon/">Recon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utilities/">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plugins/">CIL Plugins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer_guide/">Developers’ Guide</a></li>
</ul>
</div>
        <div class="sidebar-primary-item">
  
  <div class="tocsection editthispage">
    <a href="https://github.com/TomographicImaging/CIL/edit/master/docs/source/optimisation.rst">
      <i class="fa-solid fa-pencil"></i>
      
      
        
          Edit on GitHub
        
      
    </a>
  </div>
</div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumbs">
  <ul class="bd-breadcrumbs" role="navigation" aria-label="Breadcrumb">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    <li class="breadcrumb-item active" aria-current="page">Optimisation framework</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section id="optimisation-framework">
<h1>Optimisation framework<a class="headerlink" href="#optimisation-framework" title="Permalink to this headline">#</a></h1>
<p>This package allows rapid prototyping of optimisation-based reconstruction problems, i.e. defining and solving different optimization problems to enforce different properties on the reconstructed image.</p>
<p>Firstly, it provides an object-oriented framework for defining mathematical operators and functions as well a collection of useful example operators and functions. Both smooth and non-smooth functions can be used.</p>
<p>Further, it provides a number of high-level generic implementations of optimisation algorithms to solve generically formulated optimisation problems constructed from operator and function objects.</p>
<p>The fundamental components are:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">Operator</span></code>: A class specifying a (currently linear) operator.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">Function</span></code>: A class specifying mathematical functions such as a least squares data fidelity.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">Algorithm</span></code>: Implementation of an iterative optimisation algorithm to solve a particular generic optimisation problem. Algorithms are iterable Python object which can be run in a for loop. Can be stopped and warm restarted.</p></li>
</ul>
<section id="algorithms">
<h2>Algorithms<a class="headerlink" href="#algorithms" title="Permalink to this headline">#</a></h2>
<p>A number of generic algorithm implementations are provided including
Gradient Descent (GD), Conjugate Gradient Least Squares (CGLS),
Simultaneous Iterative Reconstruction Technique (SIRT), Primal Dual Hybrid
Gradient (PDHG), Iterative Shrinkage Thresholding Algorithm (ISTA),
and Fast Iterative Shrinkage Thresholding Algorithm (FISTA).</p>
<p>An algorithm is designed for a particular generic optimisation problem accepts and number of
instances of <code class="code docutils literal notranslate"><span class="pre">Function</span></code> derived classes and/or <code class="code docutils literal notranslate"><span class="pre">Operator</span></code> derived classes as input to
define a specific instance of the generic optimisation problem to be solved.
They are iterable objects which can be run in a for loop.
The user can provide a stopping criterion different than the default max_iteration.</p>
<p>New algorithms can be easily created by extending the <code class="code docutils literal notranslate"><span class="pre">Algorithm</span></code> class.
The user is required to implement only 4 methods: set_up, __init__, update and update_objective.</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">set_up</span></code> and <code class="code docutils literal notranslate"><span class="pre">__init__</span></code> are used to configure the algorithm</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">update</span></code> is the actual iteration updating the solution</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">update_objective</span></code> defines how the objective is calculated.</p></li>
</ul>
<p>For example, the implementation of the update of the Gradient Descent
algorithm to minimise a Function will only be:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective_function</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">update_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objective_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>The <code class="code docutils literal notranslate"><span class="pre">Algorithm</span></code> provides the infrastructure to continue iteration, to access the values of the
objective function in subsequent iterations, the time for each iteration, and to provide a nice
print to screen of the status of the optimisation.</p>
<section id="base-class">
<h3>Base class<a class="headerlink" href="#base-class" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></span><span class="sig-name descname"><span class="pre">Algorithm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">update_objective_interval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iteration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/Algorithm/#Algorithm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm" title="Permalink to this definition">#</a></dt>
<dd><p>Base class for iterative algorithms</p>
<p>provides the minimal infrastructure.</p>
<p>Algorithms are iterables so can be easily run in a for loop. They will
stop as soon as the stop criterion is met.
The user is required to implement the <code class="code docutils literal notranslate"><span class="pre">set_up</span></code>, <code class="code docutils literal notranslate"><span class="pre">__init__</span></code>, <code class="code docutils literal notranslate"><span class="pre">update</span></code> and
and <code class="code docutils literal notranslate"><span class="pre">update_objective</span></code> methods</p>
<p>A courtesy method <code class="code docutils literal notranslate"><span class="pre">run</span></code> is available to run <code class="code docutils literal notranslate"><span class="pre">n</span></code> iterations. The method accepts
a <code class="code docutils literal notranslate"><span class="pre">callbacks</span></code> list of callables, each of which receive the current Algorithm object
(which in turn contains the iteration number and the actual objective value)
and can be used to trigger print to screens and other user interactions. The <code class="code docutils literal notranslate"><span class="pre">run</span></code>
method will stop when the stopping criterion is met or <cite>StopIteration</cite> is raised.</p>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.set_up">
<span class="sig-name descname"><span class="pre">set_up</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/Algorithm/#Algorithm.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.set_up" title="Permalink to this definition">#</a></dt>
<dd><p>Set up the algorithm</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/Algorithm/#Algorithm.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.update" title="Permalink to this definition">#</a></dt>
<dd><p>A single iteration of the algorithm</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.should_stop">
<span class="sig-name descname"><span class="pre">should_stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/Algorithm/#Algorithm.should_stop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.should_stop" title="Permalink to this definition">#</a></dt>
<dd><p>default stopping criterion: number of iterations</p>
<p>The user can change this in concrete implementation of iterative algorithms.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.get_output">
<span class="sig-name descname"><span class="pre">get_output</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/Algorithm/#Algorithm.get_output"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.get_output" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.is_provably_convergent">
<span class="sig-name descname"><span class="pre">is_provably_convergent</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/Algorithm/#Algorithm.is_provably_convergent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.is_provably_convergent" title="Permalink to this definition">#</a></dt>
<dd><p>Check if the algorithm is convergent based on the provable convergence criterion.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.get_last_loss">
<span class="sig-name descname"><span class="pre">get_last_loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/Algorithm/#Algorithm.get_last_loss"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.get_last_loss" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.get_last_objective">
<span class="sig-name descname"><span class="pre">get_last_objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.get_last_objective" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.update_objective">
<span class="sig-name descname"><span class="pre">update_objective</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/Algorithm/#Algorithm.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.update_objective" title="Permalink to this definition">#</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.iterations">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">iterations</span></span><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.iterations" title="Permalink to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.loss">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">loss</span></span><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.loss" title="Permalink to this definition">#</a></dt>
<dd><p>returns the list of the values of the objective during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when
the update_objective_interval &gt; 1</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.objective">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">objective</span></span><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.objective" title="Permalink to this definition">#</a></dt>
<dd><p>returns the list of the values of the objective during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when
the update_objective_interval &gt; 1</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.max_iteration">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_iteration</span></span><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.max_iteration" title="Permalink to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callbacks</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">cil.optimisation.utilities.callbacks.Callback</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/Algorithm/#Algorithm.run"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.run" title="Permalink to this definition">#</a></dt>
<dd><p>run upto <code class="code docutils literal notranslate"><span class="pre">iterations</span></code> with callbacks/logging.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> – number of iterations to run. If not set the algorithm will
run until <code class="code docutils literal notranslate"><span class="pre">should_stop()</span></code> is reached</p></li>
<li><p><strong>verbose</strong> – 0=quiet, 1=info, 2=debug</p></li>
<li><p><strong>callbacks</strong> – list of callables which are passed the current Algorithm
object each iteration. Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="gd">
<h3>GD<a class="headerlink" href="#gd" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></span><span class="sig-name descname"><span class="pre">GD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">objective_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/GD/#GD"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD" title="Permalink to this definition">#</a></dt>
<dd><p>Gradient Descent algorithm</p>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.set_up">
<span class="sig-name descname"><span class="pre">set_up</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">objective_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/GD/#GD.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD.set_up" title="Permalink to this definition">#</a></dt>
<dd><p>initialisation of the algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial</strong> – initial guess</p></li>
<li><p><strong>objective_function</strong> – objective function to be minimised</p></li>
<li><p><strong>step_size</strong> – step size</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/GD/#GD.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD.update" title="Permalink to this definition">#</a></dt>
<dd><p>Single iteration</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.update_objective">
<span class="sig-name descname"><span class="pre">update_objective</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/GD/#GD.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD.update_objective" title="Permalink to this definition">#</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.armijo_rule">
<span class="sig-name descname"><span class="pre">armijo_rule</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/GD/#GD.armijo_rule"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD.armijo_rule" title="Permalink to this definition">#</a></dt>
<dd><p>Applies the Armijo rule to calculate the step size (step_size)</p>
<p><a class="reference external" href="https://projecteuclid.org/download/pdf_1/euclid.pjm/1102995080">https://projecteuclid.org/download/pdf_1/euclid.pjm/1102995080</a></p>
<p>The Armijo rule runs a while loop to find the appropriate step_size by starting
from a very large number (alpha). The step_size is found by dividing alpha by 2
in an iterative way until a certain criterion is met. To avoid infinite loops, we
add a maximum number of times the while loop is run.</p>
<p>This rule would allow to reach a minimum step_size of 10^-alpha.</p>
<p>if
alpha = numpy.power(10,gamma)
delta = 3
step_size = numpy.power(10, -delta)
with armijo rule we can get to step_size from initial alpha by repeating the while loop k times
where
alpha / 2^k = step_size
10^gamma / 2^k = 10^-delta
2^k = 10^(gamma+delta)
k = gamma+delta / log10(2) approx 3.3 * (gamma+delta)</p>
<p>if we would take by default delta = gamma
kmax = numpy.ceil ( 2 * gamma / numpy.log10(2) )
kmax = numpy.ceil (2 * numpy.log10(alpha) / numpy.log10(2))</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.get_last_loss">
<span class="sig-name descname"><span class="pre">get_last_loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.GD.get_last_loss" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.get_last_objective">
<span class="sig-name descname"><span class="pre">get_last_objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.GD.get_last_objective" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.get_output">
<span class="sig-name descname"><span class="pre">get_output</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.GD.get_output" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.is_provably_convergent">
<span class="sig-name descname"><span class="pre">is_provably_convergent</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.GD.is_provably_convergent" title="Permalink to this definition">#</a></dt>
<dd><p>Check if the algorithm is convergent based on the provable convergence criterion.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.iterations">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">iterations</span></span><a class="headerlink" href="#cil.optimisation.algorithms.GD.iterations" title="Permalink to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.loss">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">loss</span></span><a class="headerlink" href="#cil.optimisation.algorithms.GD.loss" title="Permalink to this definition">#</a></dt>
<dd><p>returns the list of the values of the objective during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when
the update_objective_interval &gt; 1</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.max_iteration">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_iteration</span></span><a class="headerlink" href="#cil.optimisation.algorithms.GD.max_iteration" title="Permalink to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.objective">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">objective</span></span><a class="headerlink" href="#cil.optimisation.algorithms.GD.objective" title="Permalink to this definition">#</a></dt>
<dd><p>returns the list of the values of the objective during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when
the update_objective_interval &gt; 1</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callbacks</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">cil.optimisation.utilities.callbacks.Callback</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.GD.run" title="Permalink to this definition">#</a></dt>
<dd><p>run upto <code class="code docutils literal notranslate"><span class="pre">iterations</span></code> with callbacks/logging.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> – number of iterations to run. If not set the algorithm will
run until <code class="code docutils literal notranslate"><span class="pre">should_stop()</span></code> is reached</p></li>
<li><p><strong>verbose</strong> – 0=quiet, 1=info, 2=debug</p></li>
<li><p><strong>callbacks</strong> – list of callables which are passed the current Algorithm
object each iteration. Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.should_stop">
<span class="sig-name descname"><span class="pre">should_stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/GD/#GD.should_stop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD.should_stop" title="Permalink to this definition">#</a></dt>
<dd><p>default stopping criterion: number of iterations</p>
<p>The user can change this in concrete implementation of iterative algorithms.</p>
</dd></dl>

</dd></dl>

</section>
<section id="cgls">
<h3>CGLS<a class="headerlink" href="#cgls" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></span><span class="sig-name descname"><span class="pre">CGLS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/CGLS/#CGLS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS" title="Permalink to this definition">#</a></dt>
<dd><p>Conjugate Gradient Least Squares algorithm</p>
<p>Problem:</p>
<div class="math notranslate nohighlight">
\[\min || A x - b ||^2_2\]</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Parameters :</p>
<blockquote>
<div><p>:parameter operator : Linear operator for the inverse problem
:parameter initial : Initial guess ( Default initial = 0)
:parameter data : Acquired data to reconstruct
:parameter tolerance: Tolerance/ Stopping Criterion to end CGLS algorithm</p>
</div></blockquote>
<dl class="simple">
<dt>Reference:</dt><dd><p><a class="reference external" href="https://web.stanford.edu/group/SOL/software/cgls/">https://web.stanford.edu/group/SOL/software/cgls/</a></p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.set_up">
<span class="sig-name descname"><span class="pre">set_up</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/CGLS/#CGLS.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.set_up" title="Permalink to this definition">#</a></dt>
<dd><p>initialisation of the algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> – Linear operator for the inverse problem</p></li>
<li><p><strong>initial</strong> – Initial guess ( Default initial = 0)</p></li>
<li><p><strong>data</strong> – Acquired data to reconstruct</p></li>
<li><p><strong>tolerance</strong> – Tolerance/ Stopping Criterion to end CGLS algorithm</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/CGLS/#CGLS.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.update" title="Permalink to this definition">#</a></dt>
<dd><p>single iteration</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.update_objective">
<span class="sig-name descname"><span class="pre">update_objective</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/CGLS/#CGLS.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.update_objective" title="Permalink to this definition">#</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.should_stop">
<span class="sig-name descname"><span class="pre">should_stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/CGLS/#CGLS.should_stop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.should_stop" title="Permalink to this definition">#</a></dt>
<dd><p>default stopping criterion: number of iterations</p>
<p>The user can change this in concrete implementation of iterative algorithms.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.flag">
<span class="sig-name descname"><span class="pre">flag</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/CGLS/#CGLS.flag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.flag" title="Permalink to this definition">#</a></dt>
<dd><p>returns whether the tolerance has been reached</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.get_last_loss">
<span class="sig-name descname"><span class="pre">get_last_loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.get_last_loss" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.get_last_objective">
<span class="sig-name descname"><span class="pre">get_last_objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.get_last_objective" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.get_output">
<span class="sig-name descname"><span class="pre">get_output</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.get_output" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.is_provably_convergent">
<span class="sig-name descname"><span class="pre">is_provably_convergent</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.is_provably_convergent" title="Permalink to this definition">#</a></dt>
<dd><p>Check if the algorithm is convergent based on the provable convergence criterion.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.iterations">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">iterations</span></span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.iterations" title="Permalink to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.loss">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">loss</span></span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.loss" title="Permalink to this definition">#</a></dt>
<dd><p>returns the list of the values of the objective during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when
the update_objective_interval &gt; 1</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.max_iteration">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_iteration</span></span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.max_iteration" title="Permalink to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.objective">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">objective</span></span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.objective" title="Permalink to this definition">#</a></dt>
<dd><p>returns the list of the values of the objective during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when
the update_objective_interval &gt; 1</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callbacks</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">cil.optimisation.utilities.callbacks.Callback</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.run" title="Permalink to this definition">#</a></dt>
<dd><p>run upto <code class="code docutils literal notranslate"><span class="pre">iterations</span></code> with callbacks/logging.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> – number of iterations to run. If not set the algorithm will
run until <code class="code docutils literal notranslate"><span class="pre">should_stop()</span></code> is reached</p></li>
<li><p><strong>verbose</strong> – 0=quiet, 1=info, 2=debug</p></li>
<li><p><strong>callbacks</strong> – list of callables which are passed the current Algorithm
object each iteration. Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="sirt">
<h3>SIRT<a class="headerlink" href="#sirt" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></span><span class="sig-name descname"><span class="pre">SIRT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/SIRT/#SIRT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SIRT" title="Permalink to this definition">#</a></dt>
<dd><p>Simultaneous Iterative Reconstruction Technique, see <span id="id1">[<a class="reference internal" href="#id45" title="Avinash C. Kak and Malcolm Slaney. Principles of Computerized Tomographic Imaging. Society for Industrial and Applied Mathematics, January 2001. URL: https://doi.org/10.1137/1.9780898719277, doi:10.1137/1.9780898719277.">7</a>]</span>.</p>
<p>Simultaneous Iterative Reconstruction Technique (SIRT) solves
the following problem</p>
<div class="math notranslate nohighlight">
\[A x = b\]</div>
<p>The SIRT algorithm is</p>
<div class="math notranslate nohighlight">
\[x^{k+1} =  \mathrm{proj}_{C}( x^{k} + \omega * D ( A^{T} ( M * (b - Ax^{k}) ) ) ),\]</div>
<p>where,
<span class="math notranslate nohighlight">\(M = \frac{1}{A*\mathbb{1}}\)</span>,
<span class="math notranslate nohighlight">\(D = \frac{1}{A^{T}\mathbb{1}}\)</span>,
<span class="math notranslate nohighlight">\(\mathbb{1}\)</span> is a <code class="code docutils literal notranslate"><span class="pre">DataContainer</span></code> of ones,
<span class="math notranslate nohighlight">\(\mathrm{prox}_{C}\)</span> is the projection over a set <span class="math notranslate nohighlight">\(C\)</span>,
and <span class="math notranslate nohighlight">\(\omega\)</span> is the relaxation parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>default = None</em>) – Starting point of the algorithm, default value = Zero DataContainer</p></li>
<li><p><strong>operator</strong> (<a class="reference internal" href="#cil.optimisation.operators.LinearOperator" title="cil.optimisation.operators.LinearOperator"><em>LinearOperator</em></a>) – The operator A.</p></li>
<li><p><strong>data</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The data b.</p></li>
<li><p><strong>lower</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, default = None) – Lower bound constraint</p></li>
<li><p><strong>upper</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, default = None) – Upper bound constraint</p></li>
<li><p><strong>constraint</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a><em>, </em><em>default = None</em>) – A function with <code class="code docutils literal notranslate"><span class="pre">proximal</span></code> method, e.g., <a class="reference internal" href="#cil.optimisation.functions.IndicatorBox" title="cil.optimisation.functions.IndicatorBox"><code class="xref py py-class docutils literal notranslate"><span class="pre">IndicatorBox</span></code></a> function and <a class="reference internal" href="#cil.optimisation.functions.IndicatorBox.proximal" title="cil.optimisation.functions.IndicatorBox.proximal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">IndicatorBox.proximal()</span></code></a>,
or <a class="reference internal" href="#cil.optimisation.functions.TotalVariation" title="cil.optimisation.functions.TotalVariation"><code class="xref py py-class docutils literal notranslate"><span class="pre">TotalVariation</span></code></a> function and <a class="reference internal" href="#cil.optimisation.functions.TotalVariation.proximal" title="cil.optimisation.functions.TotalVariation.proximal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TotalVariation.proximal()</span></code></a>.</p></li>
<li><p><strong>kwargs</strong> – Keyword arguments used from the base class <a class="reference internal" href="#cil.optimisation.algorithms.Algorithm" title="cil.optimisation.algorithms.Algorithm"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algorithm</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="code docutils literal notranslate"><span class="pre">constraint</span></code> is not passed, <code class="code docutils literal notranslate"><span class="pre">lower</span></code> and <code class="code docutils literal notranslate"><span class="pre">upper</span></code> are used to create an <a class="reference internal" href="#cil.optimisation.functions.IndicatorBox" title="cil.optimisation.functions.IndicatorBox"><code class="xref py py-class docutils literal notranslate"><span class="pre">IndicatorBox</span></code></a> and apply its <code class="code docutils literal notranslate"><span class="pre">proximal</span></code>.</p>
<p>If <code class="code docutils literal notranslate"><span class="pre">constraint</span></code> is passed, <code class="code docutils literal notranslate"><span class="pre">proximal</span></code> method is required to be implemented.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The preconditioning arrays (weights) <code class="code docutils literal notranslate"><span class="pre">M</span></code> and <code class="code docutils literal notranslate"><span class="pre">D</span></code> used in SIRT are defined as</p>
<div class="math notranslate nohighlight">
\[M = \frac{1}{A*\mathbb{1}} = \frac{1}{\sum_{j}a_{i,j}}\]</div>
<div class="math notranslate nohighlight">
\[D = \frac{1}{A*\mathbb{1}} = \frac{1}{\sum_{i}a_{i,j}}\]</div>
</div>
<p class="rubric">Examples</p>
<div class="math notranslate nohighlight">
\[\underset{x}{\mathrm{argmin}} \frac{1}{2}\| x - d\|^{2}\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sirt</span> <span class="o">=</span> <span class="n">SIRT</span><span class="p">(</span><span class="n">initial</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">operator</span> <span class="o">=</span> <span class="n">A</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="p">,</span> <span class="n">max_iteration</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.set_up">
<span class="sig-name descname"><span class="pre">set_up</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/SIRT/#SIRT.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.set_up" title="Permalink to this definition">#</a></dt>
<dd><p>Initialisation of the algorithm</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.set_relaxation_parameter">
<span class="sig-name descname"><span class="pre">set_relaxation_parameter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/SIRT/#SIRT.set_relaxation_parameter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.set_relaxation_parameter" title="Permalink to this definition">#</a></dt>
<dd><p>Set the relaxation parameter <span class="math notranslate nohighlight">\(\omega\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>value</strong> (<em>float</em>) – The relaxation parameter to be applied to the update. Must be between 0 and 2 to guarantee asymptotic convergence.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/SIRT/#SIRT.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.update" title="Permalink to this definition">#</a></dt>
<dd><p>Performs a single iteration of the SIRT algorithm</p>
<div class="math notranslate nohighlight">
\[x^{k+1} =  \mathrm{proj}_{C}( x^{k} + \omega * D ( A^{T} ( M * (b - Ax) ) ) )\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.update_objective">
<span class="sig-name descname"><span class="pre">update_objective</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/SIRT/#SIRT.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.update_objective" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the objective</p>
<div class="math notranslate nohighlight">
\[\frac{1}{2}\|A x - b\|^{2}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.get_last_loss">
<span class="sig-name descname"><span class="pre">get_last_loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.get_last_loss" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.get_last_objective">
<span class="sig-name descname"><span class="pre">get_last_objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.get_last_objective" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.get_output">
<span class="sig-name descname"><span class="pre">get_output</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.get_output" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.is_provably_convergent">
<span class="sig-name descname"><span class="pre">is_provably_convergent</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.is_provably_convergent" title="Permalink to this definition">#</a></dt>
<dd><p>Check if the algorithm is convergent based on the provable convergence criterion.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.iterations">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">iterations</span></span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.iterations" title="Permalink to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.loss">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">loss</span></span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.loss" title="Permalink to this definition">#</a></dt>
<dd><p>returns the list of the values of the objective during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when
the update_objective_interval &gt; 1</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.max_iteration">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_iteration</span></span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.max_iteration" title="Permalink to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.objective">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">objective</span></span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.objective" title="Permalink to this definition">#</a></dt>
<dd><p>returns the list of the values of the objective during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when
the update_objective_interval &gt; 1</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callbacks</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">cil.optimisation.utilities.callbacks.Callback</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.run" title="Permalink to this definition">#</a></dt>
<dd><p>run upto <code class="code docutils literal notranslate"><span class="pre">iterations</span></code> with callbacks/logging.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> – number of iterations to run. If not set the algorithm will
run until <code class="code docutils literal notranslate"><span class="pre">should_stop()</span></code> is reached</p></li>
<li><p><strong>verbose</strong> – 0=quiet, 1=info, 2=debug</p></li>
<li><p><strong>callbacks</strong> – list of callables which are passed the current Algorithm
object each iteration. Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.should_stop">
<span class="sig-name descname"><span class="pre">should_stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.should_stop" title="Permalink to this definition">#</a></dt>
<dd><p>default stopping criterion: number of iterations</p>
<p>The user can change this in concrete implementation of iterative algorithms.</p>
</dd></dl>

</dd></dl>

</section>
<section id="ista">
<h3>ISTA<a class="headerlink" href="#ista" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></span><span class="sig-name descname"><span class="pre">ISTA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/FISTA/#ISTA"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.ISTA" title="Permalink to this definition">#</a></dt>
<dd><p>Iterative Shrinkage-Thresholding Algorithm, see <span id="id2">[<a class="reference internal" href="#id43" title="Amir Beck and Marc Teboulle. A fast iterative shrinkage-thresholding algorithm for linear inverse problems. SIAM Journal on Imaging Sciences, 2(1):183-202, 2009. URL: https://doi.org/10.1137/080716542, arXiv:https://doi.org/10.1137/080716542, doi:10.1137/080716542.">1</a>]</span>, <span id="id3">[<a class="reference internal" href="#id42" title="Amir Beck and Marc Teboulle. Fast gradient-based algorithms for constrained total variation image denoising and deblurring problems. IEEE Transactions on Image Processing, 18(11):2419-2434, 2009. doi:10.1109/TIP.2009.2028250.">2</a>]</span>.</p>
<p>Iterative Shrinkage-Thresholding Algorithm (ISTA)</p>
<div class="math notranslate nohighlight">
\[x^{k+1} = \mathrm{prox}_{\alpha^{k} g}(x^{k} - \alpha^{k}\nabla f(x^{k}))\]</div>
<p>is used to solve</p>
<div class="math notranslate nohighlight">
\[\min_{x} f(x) + g(x)\]</div>
<p>where <span class="math notranslate nohighlight">\(f\)</span> is differentiable, <span class="math notranslate nohighlight">\(g\)</span> has a <em>simple</em> proximal operator and <span class="math notranslate nohighlight">\(\alpha^{k}\)</span>
is the <code class="code docutils literal notranslate"><span class="pre">step_size</span></code> per iteration.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For a constant step size, i.e., <span class="math notranslate nohighlight">\(a^{k}=a\)</span> for <span class="math notranslate nohighlight">\(k\geq1\)</span>, convergence of ISTA
is guaranteed if</p>
<div class="math notranslate nohighlight">
\[\alpha\in(0, \frac{2}{L}),\]</div>
<p>where <span class="math notranslate nohighlight">\(L\)</span> is the Lipschitz constant of <span class="math notranslate nohighlight">\(f\)</span>, see <span id="id4">[]</span>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – Initial guess of ISTA.</p></li>
<li><p><strong>f</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – Differentiable function. If <cite>None</cite> is passed, the algorithm will use the ZeroFunction.</p></li>
<li><p><strong>g</strong> (Function or <cite>None</cite>) – Convex function with <em>simple</em> proximal operator. If <cite>None</cite> is passed, the algorithm will use the ZeroFunction.</p></li>
<li><p><strong>step_size</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, default = None) – Step size for the gradient step of ISTA.
The default <code class="code docutils literal notranslate"><span class="pre">step_size</span></code> is <span class="math notranslate nohighlight">\(\frac{1}{L}\)</span> or 1 if <cite>f=None</cite>.</p></li>
<li><p><strong>kwargs</strong> (<em>Keyword arguments</em>) – Arguments from the base class <a class="reference internal" href="#cil.optimisation.algorithms.Algorithm" title="cil.optimisation.algorithms.Algorithm"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algorithm</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the function <cite>g</cite> is set to <cite>None</cite> or to the <cite>ZeroFunction</cite> then the ISTA algorithm is equivalent to Gradient Descent.</p>
<p>If the function <cite>f</cite> is set to <cite>None</cite> or to the <cite>ZeroFunction</cite> then the ISTA algorithm is equivalent to a Proximal Point Algorithm.</p>
</div>
<p class="rubric">Examples</p>
<div class="math notranslate nohighlight">
\[\underset{x}{\mathrm{argmin}}\|A x - b\|^{2}_{2}\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">LeastSquares</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">ZeroFunction</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ig</span> <span class="o">=</span> <span class="n">Aop</span><span class="o">.</span><span class="n">domain</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ista</span> <span class="o">=</span> <span class="n">ISTA</span><span class="p">(</span><span class="n">initial</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">allocate</span><span class="p">(),</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="p">,</span> <span class="n">max_iteration</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ista</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#cil.optimisation.algorithms.FISTA" title="cil.optimisation.algorithms.FISTA"><code class="xref py py-class docutils literal notranslate"><span class="pre">FISTA</span></code></a>, <a class="reference internal" href="#cil.optimisation.algorithms.GD" title="cil.optimisation.algorithms.GD"><code class="xref py py-class docutils literal notranslate"><span class="pre">GD</span></code></a></p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.set_step_size">
<span class="sig-name descname"><span class="pre">set_step_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">step_size</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/FISTA/#ISTA.set_step_size"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.set_step_size" title="Permalink to this definition">#</a></dt>
<dd><p>Set default step size.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/FISTA/#ISTA.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Set the minimal number of parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>update_objective_interval</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default 1</em>) – the interval every which we would save the current                                       objective. 1 means every iteration, 2 every 2 iteration                                       and so forth. This is by default 1 and should be increased                                       when evaluating the objective is computationally expensive.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.set_up">
<span class="sig-name descname"><span class="pre">set_up</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/FISTA/#ISTA.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.set_up" title="Permalink to this definition">#</a></dt>
<dd><p>Set up of the algorithm</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/FISTA/#ISTA.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.update" title="Permalink to this definition">#</a></dt>
<dd><p>Performs a single iteration of ISTA</p>
<div class="math notranslate nohighlight">
\[x_{k+1} = \mathrm{prox}_{\alpha g}(x_{k} - \alpha\nabla f(x_{k}))\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.get_output">
<span class="sig-name descname"><span class="pre">get_output</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/FISTA/#ISTA.get_output"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.get_output" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.update_objective">
<span class="sig-name descname"><span class="pre">update_objective</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/FISTA/#ISTA.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.update_objective" title="Permalink to this definition">#</a></dt>
<dd><p>Updates the objective</p>
<div class="math notranslate nohighlight">
\[f(x) + g(x)\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.__delattr__">
<span class="sig-name descname"><span class="pre">__delattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__delattr__" title="Permalink to this definition">#</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.__dir__">
<span class="sig-name descname"><span class="pre">__dir__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__dir__" title="Permalink to this definition">#</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__eq__" title="Permalink to this definition">#</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.__format__">
<span class="sig-name descname"><span class="pre">__format__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">format_spec</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__format__" title="Permalink to this definition">#</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.__ge__">
<span class="sig-name descname"><span class="pre">__ge__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__ge__" title="Permalink to this definition">#</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.__getattribute__">
<span class="sig-name descname"><span class="pre">__getattribute__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__getattribute__" title="Permalink to this definition">#</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.__gt__">
<span class="sig-name descname"><span class="pre">__gt__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__gt__" title="Permalink to this definition">#</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__hash__" title="Permalink to this definition">#</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.__init_subclass__">
<span class="sig-name descname"><span class="pre">__init_subclass__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__init_subclass__" title="Permalink to this definition">#</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.__iter__">
<span class="sig-name descname"><span class="pre">__iter__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__iter__" title="Permalink to this definition">#</a></dt>
<dd><p>Algorithm is an iterable</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.__le__">
<span class="sig-name descname"><span class="pre">__le__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__le__" title="Permalink to this definition">#</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.__lt__">
<span class="sig-name descname"><span class="pre">__lt__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__lt__" title="Permalink to this definition">#</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.__ne__">
<span class="sig-name descname"><span class="pre">__ne__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__ne__" title="Permalink to this definition">#</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.__new__">
<span class="sig-name descname"><span class="pre">__new__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__new__" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.__next__">
<span class="sig-name descname"><span class="pre">__next__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__next__" title="Permalink to this definition">#</a></dt>
<dd><p>Algorithm is an iterable</p>
<p>This method triggers <code class="code docutils literal notranslate"><span class="pre">update()</span></code> and <code class="code docutils literal notranslate"><span class="pre">update_objective()</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.__reduce__">
<span class="sig-name descname"><span class="pre">__reduce__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__reduce__" title="Permalink to this definition">#</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.__reduce_ex__">
<span class="sig-name descname"><span class="pre">__reduce_ex__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__reduce_ex__" title="Permalink to this definition">#</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__repr__" title="Permalink to this definition">#</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.__setattr__">
<span class="sig-name descname"><span class="pre">__setattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__setattr__" title="Permalink to this definition">#</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.__sizeof__">
<span class="sig-name descname"><span class="pre">__sizeof__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__sizeof__" title="Permalink to this definition">#</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.__str__">
<span class="sig-name descname"><span class="pre">__str__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__str__" title="Permalink to this definition">#</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.__subclasshook__">
<span class="sig-name descname"><span class="pre">__subclasshook__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__subclasshook__" title="Permalink to this definition">#</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.__weakref__">
<span class="sig-name descname"><span class="pre">__weakref__</span></span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__weakref__" title="Permalink to this definition">#</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.get_last_loss">
<span class="sig-name descname"><span class="pre">get_last_loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.get_last_loss" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.get_last_objective">
<span class="sig-name descname"><span class="pre">get_last_objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.get_last_objective" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.is_provably_convergent">
<span class="sig-name descname"><span class="pre">is_provably_convergent</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.is_provably_convergent" title="Permalink to this definition">#</a></dt>
<dd><p>Check if the algorithm is convergent based on the provable convergence criterion.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.iterations">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">iterations</span></span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.iterations" title="Permalink to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.loss">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">loss</span></span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.loss" title="Permalink to this definition">#</a></dt>
<dd><p>returns the list of the values of the objective during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when
the update_objective_interval &gt; 1</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.max_iteration">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_iteration</span></span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.max_iteration" title="Permalink to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.objective">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">objective</span></span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.objective" title="Permalink to this definition">#</a></dt>
<dd><p>returns the list of the values of the objective during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when
the update_objective_interval &gt; 1</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callbacks</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">cil.optimisation.utilities.callbacks.Callback</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.run" title="Permalink to this definition">#</a></dt>
<dd><p>run upto <code class="code docutils literal notranslate"><span class="pre">iterations</span></code> with callbacks/logging.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> – number of iterations to run. If not set the algorithm will
run until <code class="code docutils literal notranslate"><span class="pre">should_stop()</span></code> is reached</p></li>
<li><p><strong>verbose</strong> – 0=quiet, 1=info, 2=debug</p></li>
<li><p><strong>callbacks</strong> – list of callables which are passed the current Algorithm
object each iteration. Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.should_stop">
<span class="sig-name descname"><span class="pre">should_stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.should_stop" title="Permalink to this definition">#</a></dt>
<dd><p>default stopping criterion: number of iterations</p>
<p>The user can change this in concrete implementation of iterative algorithms.</p>
</dd></dl>

</dd></dl>

</section>
<section id="fista">
<h3>FISTA<a class="headerlink" href="#fista" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></span><span class="sig-name descname"><span class="pre">FISTA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/FISTA/#FISTA"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.FISTA" title="Permalink to this definition">#</a></dt>
<dd><p>Fast Iterative Shrinkage-Thresholding Algorithm, see <span id="id5">[<a class="reference internal" href="#id43" title="Amir Beck and Marc Teboulle. A fast iterative shrinkage-thresholding algorithm for linear inverse problems. SIAM Journal on Imaging Sciences, 2(1):183-202, 2009. URL: https://doi.org/10.1137/080716542, arXiv:https://doi.org/10.1137/080716542, doi:10.1137/080716542.">1</a>]</span>, <span id="id6">[<a class="reference internal" href="#id42" title="Amir Beck and Marc Teboulle. Fast gradient-based algorithms for constrained total variation image denoising and deblurring problems. IEEE Transactions on Image Processing, 18(11):2419-2434, 2009. doi:10.1109/TIP.2009.2028250.">2</a>]</span>.</p>
<p>Fast Iterative Shrinkage-Thresholding Algorithm (FISTA)</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
    y_{k} = x_{k} - \alpha\nabla f(x_{k})  \\
    x_{k+1} = \mathrm{prox}_{\alpha g}(y_{k})\\
    t_{k+1} = \frac{1+\sqrt{1+ 4t_{k}^{2}}}{2}\\
    y_{k+1} = x_{k} + \frac{t_{k}-1}{t_{k-1}}(x_{k} - x_{k-1})
\end{cases}\end{split}\]</div>
<p>is used to solve</p>
<div class="math notranslate nohighlight">
\[\min_{x} f(x) + g(x)\]</div>
<p>where <span class="math notranslate nohighlight">\(f\)</span> is differentiable, <span class="math notranslate nohighlight">\(g\)</span> has a <em>simple</em> proximal operator and <span class="math notranslate nohighlight">\(\alpha^{k}\)</span>
is the <code class="code docutils literal notranslate"><span class="pre">step_size</span></code> per iteration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – Starting point of the algorithm</p></li>
<li><p><strong>f</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – Differentiable function.  If <cite>None</cite> is passed, the algorithm will use the ZeroFunction.</p></li>
<li><p><strong>g</strong> (Function or <cite>None</cite>) – Convex function with <em>simple</em> proximal operator. If <cite>None</cite> is passed, the algorithm will use the ZeroFunction.</p></li>
<li><p><strong>step_size</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, default = None) – Step size for the gradient step of FISTA.
The default <code class="code docutils literal notranslate"><span class="pre">step_size</span></code> is <span class="math notranslate nohighlight">\(\frac{1}{L}\)</span> or 1 if <cite>f=None</cite>.</p></li>
<li><p><strong>kwargs</strong> (<em>Keyword arguments</em>) – Arguments from the base class <a class="reference internal" href="#cil.optimisation.algorithms.Algorithm" title="cil.optimisation.algorithms.Algorithm"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algorithm</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the function <cite>g</cite> is set to <cite>None</cite> or to the <cite>ZeroFunction</cite> then the FISTA algorithm is equivalent to Accelerated Gradient Descent by Nesterov (<span id="id7">[<a class="reference internal" href="#id37" title="Yurii Nesterov. Introductory lectures on convex optimization: A basic course. Volume 87. Springer Science &amp; Business Media, 2003.">8</a>]</span> algorithm 2.2.9).</p>
<p>If the function <cite>f</cite> is set to <cite>None</cite> or to the <cite>ZeroFunction</cite> then the FISTA algorithm is equivalent to Guler’s First Accelerated Proximal Point Method  (<span id="id8">[<a class="reference internal" href="#id36" title="Osman Güler. New proximal point algorithms for convex minimization. SIAM Journal on Optimization, 2(4):649–664, 1992.">5</a>]</span> sec 2).</p>
</div>
<p class="rubric">Examples</p>
<div class="math notranslate nohighlight">
\[\underset{x}{\mathrm{argmin}}\|A x - b\|^{2}_{2}\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">LeastSquares</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">ZeroFunction</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ig</span> <span class="o">=</span> <span class="n">Aop</span><span class="o">.</span><span class="n">domain</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fista</span> <span class="o">=</span> <span class="n">FISTA</span><span class="p">(</span><span class="n">initial</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">allocate</span><span class="p">(),</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="p">,</span> <span class="n">max_iteration</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fista</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#cil.optimisation.algorithms.FISTA" title="cil.optimisation.algorithms.FISTA.FISTA"><code class="xref py py-class docutils literal notranslate"><span class="pre">FISTA</span></code></a>, <a class="reference internal" href="#cil.optimisation.algorithms.GD" title="cil.optimisation.algorithms.GD"><code class="xref py py-class docutils literal notranslate"><span class="pre">GD</span></code></a></p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.set_step_size">
<span class="sig-name descname"><span class="pre">set_step_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">step_size</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/FISTA/#FISTA.set_step_size"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.set_step_size" title="Permalink to this definition">#</a></dt>
<dd><p>Set the default step size</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/FISTA/#FISTA.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Set the minimal number of parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>update_objective_interval</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default 1</em>) – the interval every which we would save the current                                       objective. 1 means every iteration, 2 every 2 iteration                                       and so forth. This is by default 1 and should be increased                                       when evaluating the objective is computationally expensive.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/FISTA/#FISTA.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.update" title="Permalink to this definition">#</a></dt>
<dd><p>Performs a single iteration of FISTA</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
    x_{k+1} = \mathrm{prox}_{\alpha g}(y_{k} - \alpha\nabla f(y_{k}))\\
    t_{k+1} = \frac{1+\sqrt{1+ 4t_{k}^{2}}}{2}\\
    y_{k+1} = x_{k} + \frac{t_{k}-1}{t_{k-1}}(x_{k} - x_{k-1})
\end{cases}\end{split}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.__delattr__">
<span class="sig-name descname"><span class="pre">__delattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__delattr__" title="Permalink to this definition">#</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.__dir__">
<span class="sig-name descname"><span class="pre">__dir__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__dir__" title="Permalink to this definition">#</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__eq__" title="Permalink to this definition">#</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.__format__">
<span class="sig-name descname"><span class="pre">__format__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">format_spec</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__format__" title="Permalink to this definition">#</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.__ge__">
<span class="sig-name descname"><span class="pre">__ge__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__ge__" title="Permalink to this definition">#</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.__getattribute__">
<span class="sig-name descname"><span class="pre">__getattribute__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__getattribute__" title="Permalink to this definition">#</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.__gt__">
<span class="sig-name descname"><span class="pre">__gt__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__gt__" title="Permalink to this definition">#</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__hash__" title="Permalink to this definition">#</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.__init_subclass__">
<span class="sig-name descname"><span class="pre">__init_subclass__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__init_subclass__" title="Permalink to this definition">#</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.__iter__">
<span class="sig-name descname"><span class="pre">__iter__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__iter__" title="Permalink to this definition">#</a></dt>
<dd><p>Algorithm is an iterable</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.__le__">
<span class="sig-name descname"><span class="pre">__le__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__le__" title="Permalink to this definition">#</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.__lt__">
<span class="sig-name descname"><span class="pre">__lt__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__lt__" title="Permalink to this definition">#</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.__ne__">
<span class="sig-name descname"><span class="pre">__ne__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__ne__" title="Permalink to this definition">#</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.__new__">
<span class="sig-name descname"><span class="pre">__new__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__new__" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.__next__">
<span class="sig-name descname"><span class="pre">__next__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__next__" title="Permalink to this definition">#</a></dt>
<dd><p>Algorithm is an iterable</p>
<p>This method triggers <code class="code docutils literal notranslate"><span class="pre">update()</span></code> and <code class="code docutils literal notranslate"><span class="pre">update_objective()</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.__reduce__">
<span class="sig-name descname"><span class="pre">__reduce__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__reduce__" title="Permalink to this definition">#</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.__reduce_ex__">
<span class="sig-name descname"><span class="pre">__reduce_ex__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__reduce_ex__" title="Permalink to this definition">#</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.__repr__">
<span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__repr__" title="Permalink to this definition">#</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.__setattr__">
<span class="sig-name descname"><span class="pre">__setattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__setattr__" title="Permalink to this definition">#</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.__sizeof__">
<span class="sig-name descname"><span class="pre">__sizeof__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__sizeof__" title="Permalink to this definition">#</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.__str__">
<span class="sig-name descname"><span class="pre">__str__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__str__" title="Permalink to this definition">#</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.__subclasshook__">
<span class="sig-name descname"><span class="pre">__subclasshook__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__subclasshook__" title="Permalink to this definition">#</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.__weakref__">
<span class="sig-name descname"><span class="pre">__weakref__</span></span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__weakref__" title="Permalink to this definition">#</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.get_last_loss">
<span class="sig-name descname"><span class="pre">get_last_loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.get_last_loss" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.get_last_objective">
<span class="sig-name descname"><span class="pre">get_last_objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.get_last_objective" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.get_output">
<span class="sig-name descname"><span class="pre">get_output</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.get_output" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.is_provably_convergent">
<span class="sig-name descname"><span class="pre">is_provably_convergent</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.is_provably_convergent" title="Permalink to this definition">#</a></dt>
<dd><p>Check if the algorithm is convergent based on the provable convergence criterion.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.iterations">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">iterations</span></span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.iterations" title="Permalink to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.loss">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">loss</span></span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.loss" title="Permalink to this definition">#</a></dt>
<dd><p>returns the list of the values of the objective during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when
the update_objective_interval &gt; 1</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.max_iteration">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_iteration</span></span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.max_iteration" title="Permalink to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.objective">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">objective</span></span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.objective" title="Permalink to this definition">#</a></dt>
<dd><p>returns the list of the values of the objective during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when
the update_objective_interval &gt; 1</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callbacks</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">cil.optimisation.utilities.callbacks.Callback</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.run" title="Permalink to this definition">#</a></dt>
<dd><p>run upto <code class="code docutils literal notranslate"><span class="pre">iterations</span></code> with callbacks/logging.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> – number of iterations to run. If not set the algorithm will
run until <code class="code docutils literal notranslate"><span class="pre">should_stop()</span></code> is reached</p></li>
<li><p><strong>verbose</strong> – 0=quiet, 1=info, 2=debug</p></li>
<li><p><strong>callbacks</strong> – list of callables which are passed the current Algorithm
object each iteration. Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.set_up">
<span class="sig-name descname"><span class="pre">set_up</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.set_up" title="Permalink to this definition">#</a></dt>
<dd><p>Set up of the algorithm</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.should_stop">
<span class="sig-name descname"><span class="pre">should_stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.should_stop" title="Permalink to this definition">#</a></dt>
<dd><p>default stopping criterion: number of iterations</p>
<p>The user can change this in concrete implementation of iterative algorithms.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.update_objective">
<span class="sig-name descname"><span class="pre">update_objective</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.update_objective" title="Permalink to this definition">#</a></dt>
<dd><p>Updates the objective</p>
<div class="math notranslate nohighlight">
\[f(x) + g(x)\]</div>
</dd></dl>

</dd></dl>

</section>
<section id="pdhg">
<h3>PDHG<a class="headerlink" href="#pdhg" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></span><span class="sig-name descname"><span class="pre">PDHG</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma_g</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma_fconj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/PDHG/#PDHG"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG" title="Permalink to this definition">#</a></dt>
<dd><p>Primal Dual Hybrid Gradient (PDHG) algorithm, see <span id="id9">[<a class="reference internal" href="#id38" title="Antonin Chambolle and Thomas Pock. A first-order primal-dual algorithm for convex problems with applications to imaging. Journal of Mathematical Imaging and Vision, 40(1):120-145, May 2011. URL: https://doi.org/10.1007/s10851-010-0251-1, doi:10.1007/s10851-010-0251-1.">3</a>]</span>, <span id="id10">[<a class="reference internal" href="#id39" title="Ernie Esser, Xiaoqun Zhang, and Tony F. Chan. A general framework for a class of first order primal-dual algorithms for convex optimization in imaging science. SIAM Journal on Imaging Sciences, 3(4):1015-1046, 2010. URL: https://doi.org/10.1137/09076934X, arXiv:https://doi.org/10.1137/09076934X, doi:10.1137/09076934X.">4</a>]</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – A convex function with a “simple” proximal method of its conjugate.</p></li>
<li><p><strong>g</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – A convex function with a “simple” proximal.</p></li>
<li><p><strong>operator</strong> (<a class="reference internal" href="#cil.optimisation.operators.LinearOperator" title="cil.optimisation.operators.LinearOperator"><em>LinearOperator</em></a>) – A Linear Operator.</p></li>
<li><p><strong>sigma</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, or <cite>np.ndarray</cite>, <cite>DataContainer</cite>, <cite>BlockDataContainer</cite>, optional, default=None) – Step size for the dual problem.</p></li>
<li><p><strong>tau</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, or <cite>np.ndarray</cite>, <cite>DataContainer</cite>, <cite>BlockDataContainer</cite>, optional, default=None) – Step size for the primal problem.</p></li>
<li><p><strong>initial</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Initial point for the PDHG algorithm.</p></li>
<li><p><strong>gamma_g</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, optional, default=None) – Strongly convex constant if the function g is strongly convex. Allows primal acceleration of the PDHG algorithm.</p></li>
<li><p><strong>gamma_fconj</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, optional, default=None) – Strongly convex constant if the convex conjugate of f is strongly convex. Allows dual acceleration of the PDHG algorithm.</p></li>
<li><p><strong>**kwargs</strong> – <p>Keyward arguments used from the base class <a class="reference internal" href="#cil.optimisation.algorithms.Algorithm" title="cil.optimisation.algorithms.Algorithm"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algorithm</span></code></a>.</p>
<dl>
<dt>max_iteration<span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional, default=0</span></dt><dd><p>Maximum number of iterations of the PDHG.</p>
</dd>
<dt>update_objective_interval<span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional, default=1</span></dt><dd><p>Evaluates objectives, e.g., primal/dual/primal-dual gap every <code class="docutils literal notranslate"><span class="pre">update_objective_interval</span></code>.</p>
</dd>
<dt>check_convergence<span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">boolean</span></code>, default=True</span></dt><dd><p>Checks scalar sigma and tau values satisfy convergence criterion</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<p>In our <a class="reference external" href="https://github.com/TomographicImaging/CIL-Demos/blob/main/binder/TomographyReconstruction.ipynb">CIL-Demos</a> repositoryyou can find examples using the PDHG algorithm for different imaging problems, such as Total Variation denoising, Total Generalised Variation inpaintingand Total Variation Tomography reconstruction. More examples can also be found in <span id="id11">[<a class="reference internal" href="#id41" title="J. S. Jörgensen, E. Ametova, G. Burca, G. Fardell, E. Papoutsellis, E. Pasca, K. Thielemans, M. Turner, R. Warr, W. R. B. Lionheart, and P. J. Withers. Core imaging library - part i: a versatile python framework for tomographic imaging. Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences, 379(2204):20200192, 2021. URL: https://royalsocietypublishing.org/doi/abs/10.1098/rsta.2020.0192, arXiv:https://royalsocietypublishing.org/doi/pdf/10.1098/rsta.2020.0192, doi:10.1098/rsta.2020.0192.">6</a>]</span>, <span id="id12">[<a class="reference internal" href="#id40" title="Evangelos Papoutsellis, Evelina Ametova, Claire Delplancke, Gemma Fardell, Jakob S. Jörgensen, Edoardo Pasca, Martin Turner, Ryan Warr, William R. B. Lionheart, and Philip J. Withers. Core imaging library - part ii: multichannel reconstruction for dynamic and spectral tomography. Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences, 379(2204):20200193, 2021. URL: https://royalsocietypublishing.org/doi/abs/10.1098/rsta.2020.0193, arXiv:https://royalsocietypublishing.org/doi/pdf/10.1098/rsta.2020.0193, doi:10.1098/rsta.2020.0193.">9</a>]</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, the strongly convex constants are passed as parameters of PDHG.
In the future, these parameters will be properties of the corresponding functions.</p>
</div>
<p class="rubric">Notes</p>
<p>A first-order primal-dual algorithm for convex optimization problems with known saddle-point structure with applications in imaging.</p>
<p>The general problem considered in the PDHG algorithm is the generic saddle-point problem</p>
<div class="math notranslate nohighlight">
\[\min_{x\in X}\max_{y\in Y} \langle Kx, y \rangle + g(x) - f^{*}(x)\]</div>
<p>where <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> are convex functions with “simple” proximal operators.</p>
<p><span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> are two two finite-dimensional vector spaces with an inner product and representing the domain of <span class="math notranslate nohighlight">\(g\)</span> and <span class="math notranslate nohighlight">\(f^{*}\)</span>, the convex conjugate of <span class="math notranslate nohighlight">\(f\)</span>, respectively.</p>
<p>The operator <span class="math notranslate nohighlight">\(K\)</span> is a continuous linear operator with operator norm defined as</p>
<div class="math notranslate nohighlight">
\[\|K\| = \max\{ \|Kx\| : x\in X, \|x\|\leq1\}\]</div>
<p>The saddle point problem is decomposed into the primal problem:</p>
<div class="math notranslate nohighlight">
\[\min_{x\in X} f(Kx) + g(x),\]</div>
<p>and its corresponding dual problem</p>
<div class="math notranslate nohighlight">
\[\max_{y\in Y} - g^{*}(-K^{*}y) - f^{*}(y).\]</div>
<p>The PDHG algorithm consists of three steps:</p>
<ul class="simple">
<li><p>gradient ascent step for the dual problem,</p></li>
<li><p>gradient descent step for the primal problem and</p></li>
<li><p>an over-relaxation of the primal variable.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[y^{n+1} = \mathrm{prox}_{\sigma f^{*}}(y^{n} + \sigma K \bar{x}^{n})\]</div>
<div class="math notranslate nohighlight">
\[x^{n+1} = \mathrm{prox}_{\tau g}(x^{n} - \tau K^{*}y^{n+1})\]</div>
<div class="math notranslate nohighlight">
\[\bar{x}^{n+1} = x^{n+1} + \theta (x^{n+1} - x^{n})\]</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Convergence is guaranteed if <span class="math notranslate nohighlight">\(\theta\)</span> = 1.0,  the operator norm <span class="math notranslate nohighlight">\(\|K\|\)</span>, the dual step size <span class="math notranslate nohighlight">\(\sigma\)</span> and the primal step size <span class="math notranslate nohighlight">\(\tau\)</span>, satisfy the following inequality:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\tau \sigma \|K\|^2 &lt; 1\]</div>
<ul>
<li><p>By default, the step sizes <span class="math notranslate nohighlight">\(\sigma\)</span> and <span class="math notranslate nohighlight">\(\tau\)</span> are positive scalars and defined as below:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">sigma</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code> and <code class="docutils literal notranslate"><span class="pre">tau</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\sigma = \frac{1}{\|K\|},  \tau = \frac{1}{\|K\|}\]</div>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">tau</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\tau = \frac{1}{\sigma\|K\|^{2}}\]</div>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">sigma</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\sigma = \frac{1}{\tau\|K\|^{2}}\]</div>
</li>
<li><p>To monitor the convergence of the algorithm, we compute the primal/dual objectives and the primal-dual gap in <a class="reference internal" href="#cil.optimisation.algorithms.PDHG.update_objective" title="cil.optimisation.algorithms.PDHG.update_objective"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update_objective()</span></code></a>.</p>
<p>The primal objective is</p>
<div class="math notranslate nohighlight">
\[f(Kx) + g(x)\]</div>
<p>and the dual objective is</p>
<div class="math notranslate nohighlight">
\[- g^{*}(-K^{*}y) - f^{*}(y)\]</div>
<p>The primal-dual gap (or duality gap) is</p>
<div class="math notranslate nohighlight">
\[f(Kx) + g(x) + g^{*}(-K^{*}y) + f^{*}(y)\]</div>
<p>and measures how close is the primal-dual pair (x,y) to the primal-dual solution. It is always non-negative and is used to monitor convergence of the PDHG algorithm. For more information, see <a class="reference external" href="https://en.wikipedia.org/wiki/Duality_gap">Duality Gap</a>.</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>The primal objective is printed if <cite>verbose=1</cite>, <code class="docutils literal notranslate"><span class="pre">pdhg.run(verbose=1)</span></code>.</p></li>
<li><p>All the objectives are printed if <cite>verbose=2</cite>, <code class="docutils literal notranslate"><span class="pre">pdhg.run(verbose=2)</span></code>.</p></li>
</ul>
<p>Computing these objectives can be costly, so it is better to compute every some iterations. To do this, use <code class="docutils literal notranslate"><span class="pre">update_objective_interval</span> <span class="pre">=</span> <span class="pre">#number</span></code>.</p>
</div>
<ul>
<li><p>PDHG algorithm can be accelerated if the functions <span class="math notranslate nohighlight">\(f^{*}\)</span> and/or <span class="math notranslate nohighlight">\(g\)</span> are strongly convex. In these cases, the step-sizes <span class="math notranslate nohighlight">\(\sigma\)</span> and <span class="math notranslate nohighlight">\(\tau\)</span> are updated using the <a class="reference internal" href="#cil.optimisation.algorithms.PDHG.update_step_sizes" title="cil.optimisation.algorithms.PDHG.update_step_sizes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update_step_sizes()</span></code></a> method. A function <span class="math notranslate nohighlight">\(f\)</span> is strongly convex with constant <span class="math notranslate nohighlight">\(\gamma&gt;0\)</span> if</p>
<div class="math notranslate nohighlight">
\[f(x) - \frac{\gamma}{2}\|x\|^{2} \quad\mbox{ is convex. }\]</div>
<ul class="simple">
<li><p>For instance the function <span class="math notranslate nohighlight">\(\frac{1}{2}\|x\|^{2}_{2}\)</span> is <span class="math notranslate nohighlight">\(\gamma\)</span> strongly convex for <span class="math notranslate nohighlight">\(\gamma\in(-\infty,1]\)</span>. We say it is 1-strongly convex because it is the largest constant for which <span class="math notranslate nohighlight">\(f - \frac{1}{2}\|\cdot\|^{2}\)</span> is convex.</p></li>
<li><p>The <span class="math notranslate nohighlight">\(\|\cdot\|_{1}\)</span> norm is not strongly convex. For more information, see <a class="reference external" href="https://en.wikipedia.org/wiki/Convex_function#Strongly_convex_functions">Strongly Convex</a>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(g\)</span> is strongly convex with constant <span class="math notranslate nohighlight">\(\gamma\)</span> then the step-sizes <span class="math notranslate nohighlight">\(\sigma\)</span>, <span class="math notranslate nohighlight">\(\tau\)</span> and <span class="math notranslate nohighlight">\(\theta\)</span> are updated as:</p></li>
</ul>
<div class="math notranslate nohighlight">
   \begin{aligned}

       \theta_{n} &amp; = \frac{1}{\sqrt{1 + 2\gamma\tau_{n}}}\\
       \tau_{n+1} &amp; = \theta_{n}\tau_{n}\\
       \sigma_{n+1} &amp; = \frac{\sigma_{n}}{\theta_{n}}

   \end{aligned}</div><ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(f^{*}\)</span> is strongly convex, we swap <span class="math notranslate nohighlight">\(\sigma\)</span> with <span class="math notranslate nohighlight">\(\tau\)</span>.</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The case where both functions are strongly convex is not available at the moment.</p>
</div>
<div class="admonition-todo admonition" id="id13">
<p class="admonition-title">Todo</p>
<p>Implement acceleration of PDHG when both functions are strongly convex.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.set_gamma_g">
<span class="sig-name descname"><span class="pre">set_gamma_g</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/PDHG/#PDHG.set_gamma_g"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.set_gamma_g" title="Permalink to this definition">#</a></dt>
<dd><p>Set the value of the strongly convex constant for function <cite>g</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>value</strong> (<em>a positive number</em><em> or </em><em>None</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.set_gamma_fconj">
<span class="sig-name descname"><span class="pre">set_gamma_fconj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/PDHG/#PDHG.set_gamma_fconj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.set_gamma_fconj" title="Permalink to this definition">#</a></dt>
<dd><p>Set the value of the strongly convex constant for the convex conjugate of function <cite>f</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>value</strong> (<em>a positive number</em><em> or </em><em>None</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.set_up">
<span class="sig-name descname"><span class="pre">set_up</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/PDHG/#PDHG.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.set_up" title="Permalink to this definition">#</a></dt>
<dd><p>Initialisation of the algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – A convex function with a “simple” proximal method of its conjugate.</p></li>
<li><p><strong>g</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – A convex function with a “simple” proximal.</p></li>
<li><p><strong>operator</strong> (<a class="reference internal" href="#cil.optimisation.operators.LinearOperator" title="cil.optimisation.operators.LinearOperator"><em>LinearOperator</em></a>) – A Linear Operator.</p></li>
<li><p><strong>sigma</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, or <cite>np.ndarray</cite>, <cite>DataContainer</cite>, <cite>BlockDataContainer</cite>, optional, default=None) – Step size for the dual problem.</p></li>
<li><p><strong>tau</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, or <cite>np.ndarray</cite>, <cite>DataContainer</cite>, <cite>BlockDataContainer</cite>, optional, default=None) – Step size for the primal problem.</p></li>
<li><p><strong>initial</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Initial point for the PDHG algorithm.</p></li>
<li><p><strong>theta</strong> (<em>Relaxation parameter</em><em>, </em><em>Number</em><em>, </em><em>default 1.0</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.get_output">
<span class="sig-name descname"><span class="pre">get_output</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/PDHG/#PDHG.get_output"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.get_output" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/PDHG/#PDHG.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.update" title="Permalink to this definition">#</a></dt>
<dd><p>Performs a single iteration of the PDHG algorithm</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.check_convergence">
<span class="sig-name descname"><span class="pre">check_convergence</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/PDHG/#PDHG.check_convergence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.check_convergence" title="Permalink to this definition">#</a></dt>
<dd><p>Check whether convergence criterion for PDHG is satisfied with scalar values of tau and sigma</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>True if convergence criterion is satisfied. False if not satisfied or convergence is unknown.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.set_step_sizes">
<span class="sig-name descname"><span class="pre">set_step_sizes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/PDHG/#PDHG.set_step_sizes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.set_step_sizes" title="Permalink to this definition">#</a></dt>
<dd><p>Sets sigma and tau step-sizes for the PDHG algorithm. The step sizes can be either scalar or array-objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sigma</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, or <cite>np.ndarray</cite>, <cite>DataContainer</cite>, <cite>BlockDataContainer</cite>, optional, default=None) – Step size for the dual problem.</p></li>
<li><p><strong>tau</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, or <cite>np.ndarray</cite>, <cite>DataContainer</cite>, <cite>BlockDataContainer</cite>, optional, default=None) – Step size for the primal problem.</p></li>
</ul>
</dd>
</dl>
<p>The user can set either, both or none. Values passed by the user will be accepted as long as they are positive numbers,
or correct shape array like objects.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.update_step_sizes">
<span class="sig-name descname"><span class="pre">update_step_sizes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/PDHG/#PDHG.update_step_sizes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.update_step_sizes" title="Permalink to this definition">#</a></dt>
<dd><p>Updates step sizes in the cases of primal or dual acceleration using the strongly convexity property.
The case where both functions are strongly convex is not available at the moment.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.update_objective">
<span class="sig-name descname"><span class="pre">update_objective</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/PDHG/#PDHG.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.update_objective" title="Permalink to this definition">#</a></dt>
<dd><p>Evaluates the primal objective, the dual objective and the primal-dual gap.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.objective">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">objective</span></span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.objective" title="Permalink to this definition">#</a></dt>
<dd><p>returns the list of the values of the objective during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when
the update_objective_interval &gt; 1</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.get_last_loss">
<span class="sig-name descname"><span class="pre">get_last_loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.get_last_loss" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.get_last_objective">
<span class="sig-name descname"><span class="pre">get_last_objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.get_last_objective" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.is_provably_convergent">
<span class="sig-name descname"><span class="pre">is_provably_convergent</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.is_provably_convergent" title="Permalink to this definition">#</a></dt>
<dd><p>Check if the algorithm is convergent based on the provable convergence criterion.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.iterations">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">iterations</span></span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.iterations" title="Permalink to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.loss">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">loss</span></span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.loss" title="Permalink to this definition">#</a></dt>
<dd><p>returns the list of the values of the objective during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when
the update_objective_interval &gt; 1</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.max_iteration">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_iteration</span></span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.max_iteration" title="Permalink to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callbacks</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">cil.optimisation.utilities.callbacks.Callback</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.run" title="Permalink to this definition">#</a></dt>
<dd><p>run upto <code class="code docutils literal notranslate"><span class="pre">iterations</span></code> with callbacks/logging.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> – number of iterations to run. If not set the algorithm will
run until <code class="code docutils literal notranslate"><span class="pre">should_stop()</span></code> is reached</p></li>
<li><p><strong>verbose</strong> – 0=quiet, 1=info, 2=debug</p></li>
<li><p><strong>callbacks</strong> – list of callables which are passed the current Algorithm
object each iteration. Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.should_stop">
<span class="sig-name descname"><span class="pre">should_stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.should_stop" title="Permalink to this definition">#</a></dt>
<dd><p>default stopping criterion: number of iterations</p>
<p>The user can change this in concrete implementation of iterative algorithms.</p>
</dd></dl>

</dd></dl>

</section>
<section id="ladmm">
<h3>LADMM<a class="headerlink" href="#ladmm" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></span><span class="sig-name descname"><span class="pre">LADMM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/ADMM/#LADMM"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.LADMM" title="Permalink to this definition">#</a></dt>
<dd><p>LADMM is the Linearized Alternating Direction Method of Multipliers (LADMM)</p>
<p>General form of ADMM : min_{x} f(x) + g(y), subject to Ax + By = b</p>
<p>Case: A = Id, B = -K, b = 0   ==&gt; min_x f(Kx) + g(x)</p>
<p>The quadratic term in the augmented Lagrangian is linearized for the x-update.</p>
<p>Main algorithmic difference is that in ADMM we compute two proximal subproblems,
where in the PDHG a proximal and proximal conjugate.</p>
<p>Reference (Section 8) : <a class="reference external" href="https://link.springer.com/content/pdf/10.1007/s10107-018-1321-1.pdf">https://link.springer.com/content/pdf/10.1007/s10107-018-1321-1.pdf</a></p>
<blockquote>
<div><p>x^{k} = prox_{      au f } (x^{k-1} - tau/sigma A^{T}(Ax^{k-1} - z^{k-1} + u^{k-1} )</p>
<p>z^{k} = prox_{sigma g} (Ax^{k} + u^{k-1})</p>
<p>u^{k} = u^{k-1} + Ax^{k} - z^{k}</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.set_up">
<span class="sig-name descname"><span class="pre">set_up</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/ADMM/#LADMM.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.set_up" title="Permalink to this definition">#</a></dt>
<dd><p>Set up the algorithm</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/ADMM/#LADMM.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.update" title="Permalink to this definition">#</a></dt>
<dd><p>A single iteration of the algorithm</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.update_objective">
<span class="sig-name descname"><span class="pre">update_objective</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/ADMM/#LADMM.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.update_objective" title="Permalink to this definition">#</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.get_last_loss">
<span class="sig-name descname"><span class="pre">get_last_loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.get_last_loss" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.get_last_objective">
<span class="sig-name descname"><span class="pre">get_last_objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.get_last_objective" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.get_output">
<span class="sig-name descname"><span class="pre">get_output</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.get_output" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.is_provably_convergent">
<span class="sig-name descname"><span class="pre">is_provably_convergent</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.is_provably_convergent" title="Permalink to this definition">#</a></dt>
<dd><p>Check if the algorithm is convergent based on the provable convergence criterion.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.iterations">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">iterations</span></span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.iterations" title="Permalink to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.loss">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">loss</span></span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.loss" title="Permalink to this definition">#</a></dt>
<dd><p>returns the list of the values of the objective during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when
the update_objective_interval &gt; 1</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.max_iteration">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_iteration</span></span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.max_iteration" title="Permalink to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.objective">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">objective</span></span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.objective" title="Permalink to this definition">#</a></dt>
<dd><p>returns the list of the values of the objective during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when
the update_objective_interval &gt; 1</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callbacks</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">cil.optimisation.utilities.callbacks.Callback</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.run" title="Permalink to this definition">#</a></dt>
<dd><p>run upto <code class="code docutils literal notranslate"><span class="pre">iterations</span></code> with callbacks/logging.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> – number of iterations to run. If not set the algorithm will
run until <code class="code docutils literal notranslate"><span class="pre">should_stop()</span></code> is reached</p></li>
<li><p><strong>verbose</strong> – 0=quiet, 1=info, 2=debug</p></li>
<li><p><strong>callbacks</strong> – list of callables which are passed the current Algorithm
object each iteration. Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.should_stop">
<span class="sig-name descname"><span class="pre">should_stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.should_stop" title="Permalink to this definition">#</a></dt>
<dd><p>default stopping criterion: number of iterations</p>
<p>The user can change this in concrete implementation of iterative algorithms.</p>
</dd></dl>

</dd></dl>

</section>
<section id="spdhg">
<h3>SPDHG<a class="headerlink" href="#spdhg" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></span><span class="sig-name descname"><span class="pre">SPDHG</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/SPDHG/#SPDHG"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG" title="Permalink to this definition">#</a></dt>
<dd><p>Stochastic Primal Dual Hybrid Gradient</p>
<p>Problem:</p>
<div class="math notranslate nohighlight">
\[\min_{x} f(Kx) + g(x) = \min_{x} \sum f_i(K_i x) + g(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<a class="reference internal" href="#cil.optimisation.functions.BlockFunction" title="cil.optimisation.functions.BlockFunction"><em>BlockFunction</em></a>) – Each must be a convex function with a “simple” proximal method of its conjugate</p></li>
<li><p><strong>g</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – A convex function with a “simple” proximal</p></li>
<li><p><strong>operator</strong> (<a class="reference internal" href="#cil.optimisation.operators.BlockOperator" title="cil.optimisation.operators.BlockOperator"><em>BlockOperator</em></a>) – BlockOperator must contain Linear Operators</p></li>
<li><p><strong>tau</strong> (<em>positive float</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Step size parameter for Primal problem</p></li>
<li><p><strong>sigma</strong> (<em>list of positive float</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – List of Step size parameters for Dual problem</p></li>
<li><p><strong>initial</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Initial point for the SPDHG algorithm</p></li>
<li><p><strong>prob</strong> (<em>list of floats</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – List of probabilities. If None each subset will have probability = 1/number of subsets</p></li>
<li><p><strong>gamma</strong> (<em>float</em>) – parameter controlling the trade-off between the primal and dual step sizes</p></li>
<li><p><strong>**kwargs</strong> – </p></li>
<li><p><strong>norms</strong> (<em>list of floats</em>) – precalculated list of norms of the operators</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<p>Example of usage: See <a class="github reference external" href="https://github.com/vais-ral/CIL-Demos/blob/master/Tomography/Simulated/Single%20Channel/PDHG_vs_SPDHG.py">vais-ral/CIL-Demos</a></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Convergence is guaranteed provided that [2, eq. (12)]:</p>
<div class="math notranslate nohighlight">
\[\]</div>
<p>|sigma[i]^{1/2} * K[i] * tau^{1/2} |^2  &lt; p_i for all i</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<dl class="simple">
<dt>Notation for primal and dual step-sizes are reversed with comparison</dt><dd><p>to PDHG.py</p>
</dd>
</dl>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<dl class="simple">
<dt>this code implements serial sampling only, as presented in [2]</dt><dd><p>(to be extended to more general case of [1] as future work)</p>
</dd>
</dl>
</div>
<p class="rubric">References</p>
<p>[1]”Stochastic primal-dual hybrid gradient algorithm with arbitrary
sampling and imaging applications”,
Chambolle, Antonin, Matthias J. Ehrhardt, Peter Richtárik, and Carola-Bibiane Schonlieb,
SIAM Journal on Optimization 28, no. 4 (2018): 2783-2808.</p>
<p>[2]”Faster PET reconstruction with non-smooth priors by randomization and preconditioning”,
Matthias J Ehrhardt, Pawel Markiewicz and Carola-Bibiane Schönlieb,
Physics in Medicine &amp; Biology, Volume 64, Number 22, 2019.</p>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.set_up">
<span class="sig-name descname"><span class="pre">set_up</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/SPDHG/#SPDHG.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.set_up" title="Permalink to this definition">#</a></dt>
<dd><p>set-up of the algorithm
:param f: Each must be a convex function with a “simple” proximal method of its conjugate
:type f: BlockFunction
:param g: A convex function with a “simple” proximal
:type g: Function
:param operator: BlockOperator must contain Linear Operators
:type operator: BlockOperator
:param tau: Step size parameter for Primal problem
:type tau: positive float, optional, default=None
:param sigma: List of Step size parameters for Dual problem
:type sigma: list of positive float, optional, default=None
:param initial: Initial point for the SPDHG algorithm
:type initial: DataContainer, optional, default=None
:param prob: List of probabilities. If None each subset will have probability = 1/number of subsets
:type prob: list of floats, optional, default=None
:param gamma: parameter controlling the trade-off between the primal and dual step sizes
:type gamma: float
:param **kwargs:
:param norms: precalculated list of norms of the operators
:type norms: list of floats</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/SPDHG/#SPDHG.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.update" title="Permalink to this definition">#</a></dt>
<dd><p>A single iteration of the algorithm</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.update_objective">
<span class="sig-name descname"><span class="pre">update_objective</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/SPDHG/#SPDHG.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.update_objective" title="Permalink to this definition">#</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.objective">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">objective</span></span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.objective" title="Permalink to this definition">#</a></dt>
<dd><p>alias of loss</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.get_last_loss">
<span class="sig-name descname"><span class="pre">get_last_loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.get_last_loss" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.get_last_objective">
<span class="sig-name descname"><span class="pre">get_last_objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.get_last_objective" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.get_output">
<span class="sig-name descname"><span class="pre">get_output</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.get_output" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.is_provably_convergent">
<span class="sig-name descname"><span class="pre">is_provably_convergent</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.is_provably_convergent" title="Permalink to this definition">#</a></dt>
<dd><p>Check if the algorithm is convergent based on the provable convergence criterion.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.iterations">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">iterations</span></span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.iterations" title="Permalink to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.loss">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">loss</span></span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.loss" title="Permalink to this definition">#</a></dt>
<dd><p>returns the list of the values of the objective during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when
the update_objective_interval &gt; 1</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.max_iteration">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_iteration</span></span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.max_iteration" title="Permalink to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callbacks</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">cil.optimisation.utilities.callbacks.Callback</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.run" title="Permalink to this definition">#</a></dt>
<dd><p>run upto <code class="code docutils literal notranslate"><span class="pre">iterations</span></code> with callbacks/logging.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> – number of iterations to run. If not set the algorithm will
run until <code class="code docutils literal notranslate"><span class="pre">should_stop()</span></code> is reached</p></li>
<li><p><strong>verbose</strong> – 0=quiet, 1=info, 2=debug</p></li>
<li><p><strong>callbacks</strong> – list of callables which are passed the current Algorithm
object each iteration. Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.should_stop">
<span class="sig-name descname"><span class="pre">should_stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.should_stop" title="Permalink to this definition">#</a></dt>
<dd><p>default stopping criterion: number of iterations</p>
<p>The user can change this in concrete implementation of iterative algorithms.</p>
</dd></dl>

</dd></dl>

</section>
<section id="callbacks">
<h3>Callbacks<a class="headerlink" href="#callbacks" title="Permalink to this headline">#</a></h3>
<p>A list of <code class="code docutils literal notranslate"><span class="pre">Callback`s</span> <span class="pre">to</span> <span class="pre">be</span> <span class="pre">executed</span> <span class="pre">each</span> <span class="pre">iteration</span> <span class="pre">can</span> <span class="pre">be</span> <span class="pre">passed</span> <span class="pre">to</span> <span class="pre">:code:`Algorithm</span></code>’s <code class="code docutils literal notranslate"><span class="pre">run</span></code> method.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cil.utilities.callbacks</span> <span class="kn">import</span> <span class="n">LogfileCallback</span>
<span class="o">...</span>
<span class="n">algorithm</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">callbacks</span><span class="o">=</span><span class="p">[</span><span class="n">LogfileCallback</span><span class="p">(</span><span class="s2">&quot;log.txt&quot;</span><span class="p">)])</span>
</pre></div>
</div>
</section>
</section>
<section id="operators">
<h2>Operators<a class="headerlink" href="#operators" title="Permalink to this headline">#</a></h2>
<p>The two most important methods are <code class="code docutils literal notranslate"><span class="pre">direct</span></code> and <code class="code docutils literal notranslate"><span class="pre">adjoint</span></code>
methods that describe the result of applying the operator, and its
adjoint respectively, onto a compatible <code class="code docutils literal notranslate"><span class="pre">DataContainer</span></code> input.
The output is another <code class="code docutils literal notranslate"><span class="pre">DataContainer</span></code> object or subclass
hereof. An important special case is to represent the tomographic
forward and backprojection operations.</p>
<section id="operator-base-classes">
<h3>Operator base classes<a class="headerlink" href="#operator-base-classes" title="Permalink to this headline">#</a></h3>
<p>All operators extend the <code class="code docutils literal notranslate"><span class="pre">Operator</span></code> class. A special class is the <code class="code docutils literal notranslate"><span class="pre">LinearOperator</span></code>
which represents an operator for which the <code class="code docutils literal notranslate"><span class="pre">adjoint</span></code> operation is defined.
A <code class="code docutils literal notranslate"><span class="pre">ScaledOperator</span></code> represents the multiplication of any operator with a scalar.</p>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.Operator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">Operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#Operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator" title="Permalink to this definition">#</a></dt>
<dd><p>Operator that maps from a space X -&gt; Y</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> (<a class="reference internal" href="../framework/#cil.framework.ImageGeometry" title="cil.framework.ImageGeometry"><em>ImageGeometry</em></a><em> or </em><a class="reference internal" href="../framework/#cil.framework.AcquisitionGeometry" title="cil.framework.AcquisitionGeometry"><em>AcquisitionGeometry</em></a>) – domain of the operator</p></li>
<li><p><strong>range_geometry</strong> (<a class="reference internal" href="../framework/#cil.framework.ImageGeometry" title="cil.framework.ImageGeometry"><em>ImageGeometry</em></a><em> or </em><a class="reference internal" href="../framework/#cil.framework.AcquisitionGeometry" title="cil.framework.AcquisitionGeometry"><em>AcquisitionGeometry</em></a><em>, </em><em>optional</em><em>, </em><em>default None</em>) – range of the operator</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.Operator.is_linear">
<span class="sig-name descname"><span class="pre">is_linear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#Operator.is_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.is_linear" title="Permalink to this definition">#</a></dt>
<dd><p>Returns if the operator is linear</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.Operator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#Operator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the application of the Operator on x</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.Operator.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#Operator.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.norm" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the norm of the Operator. On first call the norm will be calculated using the operator’s calculate_norm
method. Subsequent calls will return the cached norm.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>norm</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>positive:<cite>float</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.Operator.set_norm">
<span class="sig-name descname"><span class="pre">set_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#Operator.set_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.set_norm" title="Permalink to this definition">#</a></dt>
<dd><p>Sets the norm of the operator to a custom value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>norm</strong> (<em>float</em><em>, </em><em>optional</em>) – Positive real valued number or <cite>None</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The passed values are cached so that when self.norm() is called, the saved value will be returned and not calculated via the power method.
If <cite>None</cite> is passed, the cache is cleared prompting the function to call the power method to calculate the norm the next time self.norm() is called.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.Operator.calculate_norm">
<span class="sig-name descname"><span class="pre">calculate_norm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#Operator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.calculate_norm" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the norm of the SumOperator. Note that this gives a NotImplementedError if the SumOperator is not linear.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.Operator.range_geometry">
<span class="sig-name descname"><span class="pre">range_geometry</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#Operator.range_geometry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.range_geometry" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the range of the Operator: Y space</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.Operator.domain_geometry">
<span class="sig-name descname"><span class="pre">domain_geometry</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#Operator.domain_geometry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.domain_geometry" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the domain of the Operator: X space</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.LinearOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">LinearOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#LinearOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator" title="Permalink to this definition">#</a></dt>
<dd><p>Linear operator that maps from a space X &lt;-&gt; Y</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> (<a class="reference internal" href="../framework/#cil.framework.ImageGeometry" title="cil.framework.ImageGeometry"><em>ImageGeometry</em></a><em> or </em><a class="reference internal" href="../framework/#cil.framework.AcquisitionGeometry" title="cil.framework.AcquisitionGeometry"><em>AcquisitionGeometry</em></a>) – domain of the operator</p></li>
<li><p><strong>range_geometry</strong> (<a class="reference internal" href="../framework/#cil.framework.ImageGeometry" title="cil.framework.ImageGeometry"><em>ImageGeometry</em></a><em> or </em><a class="reference internal" href="../framework/#cil.framework.AcquisitionGeometry" title="cil.framework.AcquisitionGeometry"><em>AcquisitionGeometry</em></a><em>, </em><em>optional</em><em>, </em><em>default None</em>) – range of the operator</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.LinearOperator.is_linear">
<span class="sig-name descname"><span class="pre">is_linear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#LinearOperator.is_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator.is_linear" title="Permalink to this definition">#</a></dt>
<dd><p>Returns if the operator is linear</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.LinearOperator.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#LinearOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>returns the adjoint/inverse operation</p>
<p>only available to linear operators</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.LinearOperator.PowerMethod">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">PowerMethod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iteration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#LinearOperator.PowerMethod"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator.PowerMethod" title="Permalink to this definition">#</a></dt>
<dd><p>Power method or Power iteration algorithm</p>
<p>The Power method computes the largest (dominant) eigenvalue of a matrix in magnitude, e.g.,
absolute value in the real case and modulus in the complex case.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> (<a class="reference internal" href="#cil.optimisation.operators.LinearOperator" title="cil.optimisation.operators.LinearOperator"><em>LinearOperator</em></a>) – </p></li>
<li><p><strong>max_iteration</strong> (positive:<cite>int</cite>, default=10) – Number of iterations for the Power method algorithm.</p></li>
<li><p><strong>initial</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>default = None</em>) – Starting point for the Power method.</p></li>
<li><p><strong>tolerance</strong> (positive:<cite>float</cite>, default = 1e-5) – Stopping criterion for the Power method. Check if two consecutive eigenvalue evaluations are below the tolerance.</p></li>
<li><p><strong>return_all</strong> (<cite>boolean</cite>, default = False) – Toggles the verbosity of the return</p></li>
<li><p><strong>method</strong> (<cite>string</cite> one of <cite>“auto”</cite>, <cite>“composed_with_adjoint”</cite> and <cite>“direct_only”</cite>, default = <cite>“auto”</cite>) – The default <cite>auto</cite> lets the code choose the method, this can be specified with <cite>“direct_only”</cite> or <cite>“composed_with_adjoint”</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>dominant eigenvalue</strong> (positive:<cite>float</cite>)</p></li>
<li><p><strong>number of iterations</strong> (positive:<cite>int</cite>) – Number of iterations run. Only returned if return_all is True.</p></li>
<li><p><strong>eigenvector</strong> (<em>DataContainer</em>) – Corresponding eigenvector of the dominant eigenvalue. Only returned if return_all is True.</p></li>
<li><p><strong>list of eigenvalues</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code>) – List of eigenvalues. Only returned if return_all is True.</p></li>
<li><p><strong>convergence</strong> (<cite>boolean</cite>) – Check on wether the difference between the last two iterations is less than tolerance. Only returned if return_all is True.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The power method contains two different algorithms chosen by the <cite>method</cite> flag.</p>
<p>In the case <cite>method=”direct_only”</cite>, for operator, <span class="math notranslate nohighlight">\(A\)</span>, the power method computes the iterations
<span class="math notranslate nohighlight">\(x_{k+1} = A (x_k/\|x_{k}\|)\)</span> initialised with a random vector <span class="math notranslate nohighlight">\(x_0\)</span> and returning the largest (dominant) eigenvalue in magnitude given by <span class="math notranslate nohighlight">\(\|x_k\|\)</span>.</p>
<p>In the case <cite>method=”composed_with_adjoint”</cite>, the algorithm computes the largest (dominant) eigenvalue of <span class="math notranslate nohighlight">\(A^{T}A\)</span>
returning the square root of this value, i.e. the iterations:
<span class="math notranslate nohighlight">\(x_{k+1} = A^TA (x_k/\|x_{k}\|)\)</span> and returning  <span class="math notranslate nohighlight">\(\sqrt{\|x_k\|}\)</span>.</p>
<p>The default flag is <cite>method=”auto”</cite>, the algorithm checks to see if the <cite>operator.domain_geometry() == operator.range_geometry()</cite> and if so
uses the method “direct_only” and if not the method “composed_with_adjoint”.</p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Mop</span> <span class="o">=</span> <span class="n">MatrixOperator</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Mop_norm</span> <span class="o">=</span> <span class="n">Mop</span><span class="o">.</span><span class="n">PowerMethod</span><span class="p">(</span><span class="n">Mop</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Mop_norm</span>
<span class="go">2.0000654846240296</span>
</pre></div>
</div>
<p><cite>PowerMethod</cite> is called when we compute the norm of a matrix or a <cite>LinearOperator</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Mop_norm</span> <span class="o">=</span> <span class="n">Mop</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
<span class="go">2.0005647295658866</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.LinearOperator.calculate_norm">
<span class="sig-name descname"><span class="pre">calculate_norm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#LinearOperator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator.calculate_norm" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the norm of the LinearOperator calculated by the PowerMethod with default values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.LinearOperator.dot_test">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dot_test</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#LinearOperator.dot_test"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator.dot_test" title="Permalink to this definition">#</a></dt>
<dd><p>Does a dot linearity test on the operator
Evaluates if the following equivalence holds
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ax</span>\<span class="n">times</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> \<span class="n">times</span> <span class="n">A</span><span class="o">^</span><span class="n">Tx</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> – operator to test the dot_test</p></li>
<li><p><strong>range_init</strong> – optional initialisation container in the operator range</p></li>
<li><p><strong>domain_init</strong> – optional initialisation container in the operator domain</p></li>
<li><p><strong>seed</strong> (<em>int</em><em>, </em><em>default = 1</em>) – Seed random generator</p></li>
<li><p><strong>tolerance</strong> (<em>float</em><em>, </em><em>default 1e-6</em>) – Check if the following expression is below the tolerance</p></li>
<li><p><strong>math::</strong> (<em>..</em>) – <a href="#id47"><span class="problematic" id="id48">|Ax\times y - y \times A^Tx|</span></a>/(|A||x||y| + 1e-12) &lt; tolerance</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>boolean, True if the test is passed.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.ScaledOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">ScaledOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalar</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#ScaledOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ScaledOperator" title="Permalink to this definition">#</a></dt>
<dd><p>A class to represent the scalar multiplication of an Operator with a scalar.
It holds an operator and a scalar. Basically it returns the multiplication
of the result of direct and adjoint of the operator with the scalar.
For the rest it behaves like the operator it holds.</p>
<p>Parameters</p>
<p>operator: a <cite>Operator</cite> or <cite>LinearOperator</cite>
scalar:  Number</p>
<blockquote>
<div><p>a scalar multiplier</p>
</div></blockquote>
<p class="rubric">Example</p>
<p>The scaled operator behaves like the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sop</span> <span class="o">=</span> <span class="n">ScaledOperator</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">scalar</span><span class="p">)</span>
<span class="n">sop</span><span class="o">.</span><span class="n">direct</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">scalar</span> <span class="o">*</span> <span class="n">operator</span><span class="o">.</span><span class="n">direct</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">sop</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">scalar</span> <span class="o">*</span> <span class="n">operator</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">sop</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
<span class="n">sop</span><span class="o">.</span><span class="n">range_geometry</span><span class="p">()</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">range_geometry</span><span class="p">()</span>
<span class="n">sop</span><span class="o">.</span><span class="n">domain_geometry</span><span class="p">()</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">domain_geometry</span><span class="p">()</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.ScaledOperator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#ScaledOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ScaledOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>direct method</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.ScaledOperator.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#ScaledOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ScaledOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>adjoint method</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.ScaledOperator.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#ScaledOperator.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ScaledOperator.norm" title="Permalink to this definition">#</a></dt>
<dd><p>norm of the operator</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.ScaledOperator.is_linear">
<span class="sig-name descname"><span class="pre">is_linear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#ScaledOperator.is_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ScaledOperator.is_linear" title="Permalink to this definition">#</a></dt>
<dd><p>returns a <cite>boolean</cite> indicating whether the operator is linear</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.CompositionOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">CompositionOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">operators</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#CompositionOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.CompositionOperator" title="Permalink to this definition">#</a></dt>
<dd><p>Composes one or more operators.
For example, <cite>CompositionOperator(left, right).direct(x)</cite> is equivalent to <cite>left.direct(right.direct(x))</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>args</strong> (<a href="#id14"><span class="problematic" id="id15">`</span></a>Operator`s) – Operators to be composed. As in mathematical notation, the operators will be applied right to left</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.CompositionOperator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#CompositionOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.CompositionOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Calls the composition operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>) – Element in the domain of the CompositionOperator</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>default None</em>) – If out is not None the output of the CompositionOperator will be filled in out, otherwise a new object is instantiated and returned.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.CompositionOperator.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#CompositionOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.CompositionOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>Calls the adjoint of the composition operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>) – Element in the range of the CompositionOperator</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>default None</em>) – If out is not None the output of the adjoint of the CompositionOperator will be filled in out, otherwise a new object is instantiated and returned.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.CompositionOperator.is_linear">
<span class="sig-name descname"><span class="pre">is_linear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#CompositionOperator.is_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.CompositionOperator.is_linear" title="Permalink to this definition">#</a></dt>
<dd><p>Returns if the operator is linear</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.DiagonalOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">DiagonalOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diagonal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/DiagonalOperator/#DiagonalOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.DiagonalOperator" title="Permalink to this definition">#</a></dt>
<dd><p>Performs an element-wise multiplication, i.e., <a class="reference external" href="https://en.wikipedia.org/wiki/Hadamard_product_(matrices)#:~:text=In%20mathematics%2C%20the%20Hadamard%20product,elements%20i%2C%20j%20of%20the">Hadamard Product</a>
of a <code class="xref py py-class docutils literal notranslate"><span class="pre">DataContainer</span></code> <cite>x</cite> and <code class="xref py py-class docutils literal notranslate"><span class="pre">DataContainer</span></code> <cite>diagonal</cite>, <cite>d</cite> .</p>
<div class="math notranslate nohighlight">
\[(D\circ x) = \sum_{i,j}^{M,N} D_{i,j} x_{i, j}\]</div>
<p>In matrix-vector interpretation, if <cite>D</cite> is a <span class="math notranslate nohighlight">\(M\times N\)</span> dense matrix and is flattened, we have a <span class="math notranslate nohighlight">\(M*N \times M*N\)</span> vector.
A sparse diagonal matrix, i.e., <code class="xref py py-class docutils literal notranslate"><span class="pre">DigaonalOperator</span></code> can be created if we add the vector above to the main diagonal.
If the <code class="xref py py-class docutils literal notranslate"><span class="pre">DataContainer</span></code> <cite>x</cite> is also flattened, we have a <span class="math notranslate nohighlight">\(M*N\)</span> vector.
Now, matrix-vector multiplcation is allowed and results to a <span class="math notranslate nohighlight">\((M*N,1)\)</span> vector. After reshaping we recover a <span class="math notranslate nohighlight">\(M\times N\)</span> <code class="xref py py-class docutils literal notranslate"><span class="pre">DataContainer</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>diagonal</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – DataContainer with the same dimensions as the data to be operated on.</p></li>
<li><p><strong>domain_geometry</strong> (<a class="reference internal" href="../framework/#cil.framework.ImageGeometry" title="cil.framework.ImageGeometry"><em>ImageGeometry</em></a>) – Specifies the geometry of the operator domain. If ‘None’ will use the diagonal geometry directly. default=None .</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.DiagonalOperator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/DiagonalOperator/#DiagonalOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.DiagonalOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(D\circ x\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.DiagonalOperator.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/DiagonalOperator/#DiagonalOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.DiagonalOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(D^*\circ x\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.DiagonalOperator.calculate_norm">
<span class="sig-name descname"><span class="pre">calculate_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/DiagonalOperator/#DiagonalOperator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.DiagonalOperator.calculate_norm" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the operator norm of DiagonalOperator which is the <span class="math notranslate nohighlight">\(\infty\)</span> norm of <cite>diagonal</cite></p>
<div class="math notranslate nohighlight">
\[\|D\|_{\infty} = \max_{i}\{|D_{i}|\}\]</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.ChannelwiseOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">ChannelwiseOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'prepend'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/ChannelwiseOperator/#ChannelwiseOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ChannelwiseOperator" title="Permalink to this definition">#</a></dt>
<dd><p>ChannelwiseOperator:  takes in a single-channel operator op and the
number of channels to be used, and creates a new multi-channel
ChannelwiseOperator, which will apply the operator op independently on
each channel for the number of channels specified.</p>
<p>ChannelwiseOperator supports simple operators as input but not
BlockOperators. Typically if such behaviour is desired, it can be achieved
by creating instead a BlockOperator of ChannelwiseOperators.</p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">param op</dt>
<dd class="field-odd"><p>Single-channel operator</p>
</dd>
<dt class="field-even">param channels</dt>
<dd class="field-even"><p>Number of channels</p>
</dd>
<dt class="field-odd">param dimension</dt>
<dd class="field-odd"><p>‘prepend’ (default) or ‘append’ channel dimension onto existing dimensions</p>
</dd>
</dl>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.ChannelwiseOperator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/ChannelwiseOperator/#ChannelwiseOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ChannelwiseOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns D(x)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.ChannelwiseOperator.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/ChannelwiseOperator/#ChannelwiseOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ChannelwiseOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>Returns D^{*}(y)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.ChannelwiseOperator.calculate_norm">
<span class="sig-name descname"><span class="pre">calculate_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/ChannelwiseOperator/#ChannelwiseOperator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ChannelwiseOperator.calculate_norm" title="Permalink to this definition">#</a></dt>
<dd><p>Evaluates operator norm of DiagonalOperator</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.SumOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">SumOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#SumOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SumOperator" title="Permalink to this definition">#</a></dt>
<dd><p>Sums two operators.
For example, <cite>SumOperator(left, right).direct(x)</cite> is equivalent to  <cite>left.direct(x)+right.direct(x)</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator1</strong> (<cite>Operator</cite>) – The first <cite>Operator</cite> in the sum</p></li>
<li><p><strong>operator2</strong> (<cite>Operator</cite>) – The second <cite>Operator</cite> in the sum</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Both operators must have the same domain and range.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.SumOperator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#SumOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SumOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Calls the sum operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>) – Element in the domain of the SumOperator</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>default None</em>) – If out is not None the output of the SumOperator will be filled in out, otherwise a new object is instantiated and returned.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.SumOperator.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#SumOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SumOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>Calls the adjoint of the sum operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>) – Element in the range of the SumOperator</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>default None</em>) – If out is not None the output of the adjoint of the SumOperator will be filled in out, otherwise a new object is instantiated and returned.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.SumOperator.is_linear">
<span class="sig-name descname"><span class="pre">is_linear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#SumOperator.is_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SumOperator.is_linear" title="Permalink to this definition">#</a></dt>
<dd><p>Returns if the operator is linear</p>
</dd></dl>

</dd></dl>

</section>
<section id="trivial-operators">
<h3>Trivial operators<a class="headerlink" href="#trivial-operators" title="Permalink to this headline">#</a></h3>
<p>Trivial operators are the following.</p>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.IdentityOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">IdentityOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/IdentityOperator/#IdentityOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.IdentityOperator" title="Permalink to this definition">#</a></dt>
<dd><p>IdentityOperator:  Id: X -&gt; Y,  Id(x) = xin Y</p>
<p>X : gm_domain
Y : gm_range ( Default: Y = X )</p>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.IdentityOperator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/IdentityOperator/#IdentityOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.IdentityOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns Id(x)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.IdentityOperator.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/IdentityOperator/#IdentityOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.IdentityOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>Returns Id(x)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.IdentityOperator.calculate_norm">
<span class="sig-name descname"><span class="pre">calculate_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/IdentityOperator/#IdentityOperator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.IdentityOperator.calculate_norm" title="Permalink to this definition">#</a></dt>
<dd><p>Evaluates operator norm of IdentityOperator</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.ZeroOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">ZeroOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/ZeroOperator/#ZeroOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ZeroOperator" title="Permalink to this definition">#</a></dt>
<dd><p>ZeroOperator:  O: X -&gt; Y,  maps any element of <span class="math notranslate nohighlight">\(x\in X\)</span> into the zero element <span class="math notranslate nohighlight">\(\in Y,  O(x) = O_{Y}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gm_domain</strong> – domain of the operator</p></li>
<li><p><strong>gm_range</strong> – range of the operator, default: same as domain</p></li>
</ul>
</dd>
</dl>
<p>Note:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}O^{*}: Y^{*} -&gt; X^{*} \text{(Adjoint)}\\&lt; O(x), y &gt; = &lt; x, O^{*}(y) &gt;\end{aligned}\end{align} \]</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.ZeroOperator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/ZeroOperator/#ZeroOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ZeroOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns O(x)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.ZeroOperator.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/ZeroOperator/#ZeroOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ZeroOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>Returns O^{*}(y)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.ZeroOperator.calculate_norm">
<span class="sig-name descname"><span class="pre">calculate_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/ZeroOperator/#ZeroOperator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ZeroOperator.calculate_norm" title="Permalink to this definition">#</a></dt>
<dd><p>Evaluates operator norm of ZeroOperator</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.MatrixOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">MatrixOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/MatrixOperator/#MatrixOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.MatrixOperator" title="Permalink to this definition">#</a></dt>
<dd><p>Matrix wrapped into a LinearOperator</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>a numpy matrix</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.MatrixOperator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/MatrixOperator/#MatrixOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.MatrixOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the application of the Operator on x</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.MatrixOperator.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/MatrixOperator/#MatrixOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.MatrixOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>returns the adjoint/inverse operation</p>
<p>only available to linear operators</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.MaskOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">MaskOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/MaskOperator/#MaskOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.MaskOperator" title="Permalink to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mask</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – Boolean array with the same dimensions as the data to be operated on.</p></li>
<li><p><strong>domain_geometry</strong> (<a class="reference internal" href="../framework/#cil.framework.ImageGeometry" title="cil.framework.ImageGeometry"><em>ImageGeometry</em></a>) – Specifies the geometry of the operator domain. If ‘None’ will use the mask geometry size and spacing as float32. default = None .</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="gradientoperator">
<h3>GradientOperator<a class="headerlink" href="#gradientoperator" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.GradientOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">GradientOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'forward'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bnd_cond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Neumann'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/GradientOperator/#GradientOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.GradientOperator" title="Permalink to this definition">#</a></dt>
<dd><p>Gradient Operator: Computes first-order forward/backward differences on
2D, 3D, 4D ImageData under Neumann/Periodic boundary conditions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> (<a class="reference internal" href="../framework/#cil.framework.ImageGeometry" title="cil.framework.ImageGeometry"><em>ImageGeometry</em></a>) – Set up the domain of the function</p></li>
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>default 'forward'</em>) – Accepts: ‘forward’, ‘backward’, ‘centered’, note C++ optimised routine only works with ‘forward’</p></li>
<li><p><strong>bnd_cond</strong> (<em>str</em><em>, </em><em>default</em><em>,  </em><em>'Neumann'</em>) – Set the boundary conditions to use ‘Neumann’ or ‘Periodic’</p></li>
<li><p><strong>**kwargs</strong> – <dl class="simple">
<dt>correlation: str, default ‘Space’</dt><dd><p>’Space’ will compute the gradient on only the spatial dimensions, ‘SpaceChannels’ will include the channel dimension direction</p>
</dd>
<dt>backend: str, default ‘c’</dt><dd><p>’c’ or ‘numpy’, defaults to ‘c’ if correlation is ‘SpaceChannels’ or channels = 1</p>
</dd>
<dt>num_threads: int</dt><dd><p>If backend is ‘c’ specify the number of threads to use. Default is number of cpus/2</p>
</dd>
<dt>split: boolean</dt><dd><p>If ‘True’, and backend ‘c’ will return a BlockDataContainer with grouped spatial domains. i.e. [Channel, [Z, Y, X]], otherwise [Channel, Z, Y, X]</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a BlockDataContainer containing images of the derivatives order given by <cite>dimension_labels</cite>
i.e. [‘horizontal_y’,’horizontal_x’] will return [d(‘horizontal_y’), d(‘horizontal_x’)]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer">BlockDataContainer</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>2D example</p>
<div class="math notranslate nohighlight">
 \begin{eqnarray}
 \nabla : X \rightarrow Y\\
 u \in X, \nabla(u) &amp;=&amp; [\partial_{y} u, \partial_{x} u]\\
 u^{*} \in Y, \nabla^{*}(u^{*}) &amp;=&amp; \partial_{y} v1 + \partial_{x} v2
 \end{eqnarray}</div><dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.GradientOperator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/GradientOperator/#GradientOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.GradientOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the first-order forward differences</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.ImageData" title="cil.framework.ImageData"><em>ImageData</em></a>) – </p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>optional</em>) – pre-allocated output memory to store result</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>result data if <cite>out</cite> not specified</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer">BlockDataContainer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.GradientOperator.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/GradientOperator/#GradientOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.GradientOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the first-order backward differences</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>) – Gradient images for each dimension in ImageGeometry domain</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.ImageData" title="cil.framework.ImageData"><em>ImageData</em></a><em>, </em><em>optional</em>) – pre-allocated output memory to store result</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>result data if <cite>out</cite> not specified</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="../framework/#cil.framework.ImageData" title="cil.framework.ImageData">ImageData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.GradientOperator.calculate_norm">
<span class="sig-name descname"><span class="pre">calculate_norm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/GradientOperator/#GradientOperator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.GradientOperator.calculate_norm" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the analytical norm of the GradientOperator.</p>
<div class="math notranslate nohighlight">
\[\begin{split}(\partial_{z}, \partial_{y}, \partial_{x}) &amp;= \sqrt{\|\partial_{z}\|^{2} + \|\partial_{y}\|^{2} + \|\partial_{x}\|^{2} } \\
&amp;=  \sqrt{ \frac{4}{h_{z}^{2}} + \frac{4}{h_{y}^{2}} + \frac{4}{h_{x}^{2}}}\end{split}\]</div>
<p>Where the voxel sizes in each dimension are equal to 1 this simplifies to:</p>
<blockquote>
<div><ul class="simple">
<li><p>2D geometries <span class="math notranslate nohighlight">\(norm = \sqrt{8}\)</span></p></li>
<li><p>3D geometries <span class="math notranslate nohighlight">\(norm = \sqrt{12}\)</span></p></li>
</ul>
</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.FiniteDifferenceOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">FiniteDifferenceOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'forward'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bnd_cond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Neumann'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/FiniteDifferenceOperator/#FiniteDifferenceOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.FiniteDifferenceOperator" title="Permalink to this definition">#</a></dt>
<dd><p>Computes forward/backward/centered finite differences of a DataContainer
under Neumann/Periodic boundary conditions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> – Domain geometry for the FiniteDifferenceOperator</p></li>
<li><p><strong>direction</strong> (<em>string label from domain geometry</em><em> or </em><em>integer number</em>) – Direction to evaluate finite differences</p></li>
<li><p><strong>method</strong> (<em>'forward'</em><em>, </em><em>'backward'</em><em>, </em><em>'centered'</em>) – Method for finite differences</p></li>
<li><p><strong>bnd_cond</strong> – ‘Neumann’, ‘Periodic’</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.FiniteDifferenceOperator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/FiniteDifferenceOperator/#FiniteDifferenceOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.FiniteDifferenceOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the application of the Operator on x</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.FiniteDifferenceOperator.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/FiniteDifferenceOperator/#FiniteDifferenceOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.FiniteDifferenceOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>returns the adjoint/inverse operation</p>
<p>only available to linear operators</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.SparseFiniteDifferenceOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">SparseFiniteDifferenceOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bnd_cond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Neumann'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/SparseFiniteDifferenceOperator/#SparseFiniteDifferenceOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SparseFiniteDifferenceOperator" title="Permalink to this definition">#</a></dt>
<dd><p>Create Sparse Matrices for the Finite Difference Operator</p>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.SparseFiniteDifferenceOperator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/SparseFiniteDifferenceOperator/#SparseFiniteDifferenceOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SparseFiniteDifferenceOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the application of the Operator on x</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.SymmetrisedGradientOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">SymmetrisedGradientOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bnd_cond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Neumann'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/SymmetrisedGradientOperator/#SymmetrisedGradientOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SymmetrisedGradientOperator" title="Permalink to this definition">#</a></dt>
<dd><p>The symmetrised gradient is the operator, <span class="math notranslate nohighlight">\(E\)</span>, defined by <span class="math notranslate nohighlight">\(E: V \rightarrow W\)</span> where <cite>V</cite> is <cite>BlockGeometry</cite> and  <cite>W</cite> is the range of the Symmetrised Gradient and</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}E(v) = 0.5  ( \nabla v + (\nabla v)^{T} ) \\\end{split}\]</div>
</div></blockquote>
<p>In 2 dimensions, let <span class="math notranslate nohighlight">\(v(x,y)=(v_1(x,y),v_2(x,y))\)</span> which gives</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}\nabla v =\left( \begin{matrix}
    \partial_{x} v_1 &amp; \partial_x v_2\\
    \partial_{y}v_1 &amp; \partial_y v_2
\end{matrix}\right)\end{split}\]</div>
</div></blockquote>
<p>and thus</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}E(v) = 0.5  ( \nabla v + (\nabla v)^{T} )
=\left( \begin{matrix}
    \partial_{x} v_1 &amp; 0.5  (\partial_{y} v_1 + \partial_{x} v_2) \\
    0.5  (\partial_{x} v_1 + \partial_{y} v_2) &amp; \partial_{y} v_2
\end{matrix}\right)\end{split}\]</div>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> (<cite>BlockGeometry</cite> with shape (2,1) or (3,1)) – Set up the domain of the function.</p></li>
<li><p><strong>bnd_cond</strong> (str, optional, default <code class="code docutils literal notranslate"><span class="pre">Neumann</span></code>) – Boundary condition either <code class="code docutils literal notranslate"><span class="pre">Neumann</span></code> or <code class="code docutils literal notranslate"><span class="pre">Periodic</span></code></p></li>
<li><p><strong>correlation</strong> (str, optional, default <code class="code docutils literal notranslate"><span class="pre">Channel</span></code>) – Correlation either <code class="code docutils literal notranslate"><span class="pre">SpaceChannel</span></code> or <code class="code docutils literal notranslate"><span class="pre">Channel</span></code></p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.SymmetrisedGradientOperator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/SymmetrisedGradientOperator/#SymmetrisedGradientOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SymmetrisedGradientOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(E(v) = 0.5 * ( \nabla v + (\nabla v)^{T} )\)</span></p>
<p>x: BlockDataContainer
out: BlockDataContainer, default None</p>
<blockquote>
<div><p>If out is not None the output of direct will be filled in out, otherwise a new object is instantiated and returned.</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.SymmetrisedGradientOperator.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/SymmetrisedGradientOperator/#SymmetrisedGradientOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SymmetrisedGradientOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the adjoint of the symmetrised gradient operator</p>
<p>x: BlockDataContainer
out: BlockDataContainer, default None</p>
<blockquote>
<div><p>If out is not None the output of adjoint will be filled in out, otherwise a new object is instantiated and returned.</p>
</div></blockquote>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">#</a></h2>
<p>A <code class="code docutils literal notranslate"><span class="pre">Function</span></code> represents a mathematical function of one or more inputs
and is intended to accept <code class="code docutils literal notranslate"><span class="pre">DataContainers</span></code> as input as well as any
additional parameters.</p>
<p>Fixed parameters can be passed in during the creation of the function object.
The methods of the function reflect the properties of it, for example, if the function
represented is differentiable the function should contain a method <code class="code docutils literal notranslate"><span class="pre">gradient</span></code>
which should return the gradient of the function evaluated at an input point.
If the function is not differentiable but allows a simple proximal operator,
the method <code class="code docutils literal notranslate"><span class="pre">proximal</span></code> should return the proximal operator evaluated at an
input point. The function value is evaluated by calling the function itself,
e.g. <code class="code docutils literal notranslate"><span class="pre">f(x)</span></code> for a <code class="code docutils literal notranslate"><span class="pre">Function</span> <span class="pre">f</span></code> and input point <code class="code docutils literal notranslate"><span class="pre">x</span></code>.</p>
<section id="base-classes">
<h3>Base classes<a class="headerlink" href="#base-classes" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.Function">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">Function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">L</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#Function"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function" title="Permalink to this definition">#</a></dt>
<dd><p>Abstract class representing a function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>L</strong> (<em>number</em><em>, </em><em>positive</em><em>, </em><em>default None</em>) – Lipschitz constant of the gradient of the function F(x), when it is differentiable.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Lipschitz of the gradient of the function is a positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L \|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.Function.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#Function.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of function <span class="math notranslate nohighlight">\(F\)</span>  evaluated at <span class="math notranslate nohighlight">\(x\)</span>, if it is differentiable</p>
<div class="math notranslate nohighlight">
\[F'(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the value of the gradient of the function at x or <cite>None</cite> if <cite>out</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.Function.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#Function.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of function <span class="math notranslate nohighlight">\(\tau F\)</span>  evaluated at x</p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F}(x) = \underset{z}{\text{argmin}} \frac{1}{2}\|z - x\|^{2} + \tau F(z)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the proximal operator of the function at x with scalar <span class="math notranslate nohighlight">\(\tau\)</span> or <cite>None</cite> if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.Function.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#Function.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Evaluation of the function F* at x, where F* is the convex conjugate of function F,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x}{\sup} \langle x^{*}, x \rangle - F(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The value of the convex conjugate of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.Function.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#Function.proximal_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.proximal_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.Function.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#Function.centered_at"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.centered_at" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.Function.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.Function.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">SumFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">functions</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#SumFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SumFunction" title="Permalink to this definition">#</a></dt>
<dd><p>SumFunction represents the sum of <span class="math notranslate nohighlight">\(n\geq2\)</span> functions</p>
<div class="math notranslate nohighlight">
\[(F_{1} + F_{2} + ... + F_{n})(\cdot)  = F_{1}(\cdot) + F_{2}(\cdot) + ... + F_{n}(\cdot)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>*functions</strong> (<em>Functions</em>) – Functions to set up a <a class="reference internal" href="#cil.optimisation.functions.SumFunction" title="cil.optimisation.functions.SumFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">SumFunction</span></code></a></p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the number of function is strictly less than 2.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="math notranslate nohighlight">
\[F(x) = \|x\|^{2} + \frac{1}{2}\|x - 1\|^{2}\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cil.optimisation.functions</span> <span class="kn">import</span> <span class="n">L2NormSquared</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cil.framework</span> <span class="kn">import</span> <span class="n">ImageGeometry</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">L2NormSquared</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">L2NormSquared</span><span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">SumFunction</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">)</span>
</pre></div>
</div>
<div class="math notranslate nohighlight">
\[F(x) = \sum_{i=1}^{50} \|x - i\|^{2}\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">SumFunction</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">L2NormSquared</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">)])</span>
</pre></div>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumFunction.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.SumFunction.L" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the Lipschitz constant for the SumFunction</p>
<div class="math notranslate nohighlight">
\[L = \sum_{i} L_{i}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{i}\)</span> is the Lipschitz constant of the smooth function <span class="math notranslate nohighlight">\(F_{i}\)</span>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumFunction.Lmax">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Lmax</span></span><a class="headerlink" href="#cil.optimisation.functions.SumFunction.Lmax" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the maximum Lipschitz constant for the SumFunction</p>
<div class="math notranslate nohighlight">
\[L = \max_{i}\{L_{i}\}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{i}\)</span> is the Lipschitz constant of the smooth function <span class="math notranslate nohighlight">\(F_{i}\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumFunction.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#SumFunction.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SumFunction.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the sum of the gradient of functions evaluated at <span class="math notranslate nohighlight">\(x\)</span>, if all of them are differentiable.</p>
<div class="math notranslate nohighlight">
\[(F'_{1} + F'_{2} + ... + F'_{n})(x) = F'_{1}(x) + F'_{2}(x) + ... + F'_{n}(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – Point to evaluate the gradient at.</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the value of the sum of the gradients evaluated at point <span class="math notranslate nohighlight">\(x\)</span> or <cite>None</cite> if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumFunction.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SumFunction.centered_at" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumFunction.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SumFunction.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Evaluation of the function F* at x, where F* is the convex conjugate of function F,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x}{\sup} \langle x^{*}, x \rangle - F(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The value of the convex conjugate of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumFunction.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SumFunction.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of function <span class="math notranslate nohighlight">\(\tau F\)</span>  evaluated at x</p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F}(x) = \underset{z}{\text{argmin}} \frac{1}{2}\|z - x\|^{2} + \tau F(z)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the proximal operator of the function at x with scalar <span class="math notranslate nohighlight">\(\tau\)</span> or <cite>None</cite> if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumFunction.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SumFunction.proximal_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.ScaledFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">ScaledFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalar</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#ScaledFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction" title="Permalink to this definition">#</a></dt>
<dd><p>ScaledFunction represents the scalar multiplication with a Function.</p>
<p>Let a function F then and a scalar <span class="math notranslate nohighlight">\(\alpha\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(G(x) = \alpha F(x)\)</span> then:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(G(x) = \alpha  F(x)\)</span> ( __call__ method )</p></li>
<li><p><span class="math notranslate nohighlight">\(G'(x) = \alpha  F'(x)\)</span> ( gradient method )</p></li>
<li><p><span class="math notranslate nohighlight">\(G^{*}(x^{*}) = \alpha  F^{*}(\frac{x^{*}}{\alpha})\)</span> ( convex_conjugate method )</p></li>
<li><p><span class="math notranslate nohighlight">\(\text{prox}_{\tau G}(x) = \text{prox}_{(\tau\alpha) F}(x)\)</span> ( proximal method )</p></li>
</ol>
<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.ScaledFunction.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ScaledFunction.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#ScaledFunction.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the convex conjugate of the scaled function.</p>
<div class="math notranslate nohighlight">
\[G^{*}(x^{*}) = \alpha  F^{*}(\frac{x^{*}}{\alpha})\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The value of the convex conjugate of the scaled function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ScaledFunction.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#ScaledFunction.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the gradient of the scaled function evaluated at <span class="math notranslate nohighlight">\(x\)</span>.</p>
<div class="math notranslate nohighlight">
\[G'(x) = \alpha  F'(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – Point to evaluate the gradient at.</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the value of the gradient of the scaled function evaluated at <span class="math notranslate nohighlight">\(x\)</span> or <cite>None</cite> if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ScaledFunction.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#ScaledFunction.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the scaled function, evaluated at <span class="math notranslate nohighlight">\(x\)</span>.</p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau G}(x) = \text{prox}_{(\tau\alpha) F}(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the proximal operator of the scaled function evaluated at <span class="math notranslate nohighlight">\(x\)</span> with scalar <span class="math notranslate nohighlight">\(\tau\)</span> or <cite>None</cite> if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ScaledFunction.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#ScaledFunction.proximal_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.proximal_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>This returns the proximal  conjugate operator for the function at <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(\tau\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the proximal conjugate operator for the function evaluated at <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(\tau\)</span> or <cite>None</cite> if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ScaledFunction.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.centered_at" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumScalarFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">SumScalarFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#SumScalarFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction" title="Permalink to this definition">#</a></dt>
<dd><p>SumScalarFunction represents the sum a function with a scalar.</p>
<div class="math notranslate nohighlight">
\[(F + scalar)(x)  = F(x) + scalar\]</div>
<p>Although SumFunction has no general expressions for</p>
<ol class="lowerroman simple">
<li><p>convex_conjugate</p></li>
<li><p>proximal</p></li>
<li><p>proximal_conjugate</p></li>
</ol>
<p>if the second argument is a ConstantFunction then we can derive the above analytically.</p>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumScalarFunction.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#SumScalarFunction.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the convex conjugate of a <span class="math notranslate nohighlight">\((F+scalar)\)</span>, evaluated at <span class="math notranslate nohighlight">\(x\)</span>.</p>
<div class="math notranslate nohighlight">
\[(F+scalar)^{*}(x^{*}) = F^{*}(x^{*}) - scalar\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The value of the convex conjugate evaluated at <span class="math notranslate nohighlight">\(x\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumScalarFunction.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#SumScalarFunction.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of <span class="math notranslate nohighlight">\(F+scalar\)</span></p>
<div class="math notranslate nohighlight">
\[ext{prox}_{     au (F+scalar)}(x) =     ext{prox}_{     au F}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the evaluation of the proximal operator evaluated at <span class="math notranslate nohighlight">\(x\)</span> and :math:`       au` or <cite>None</cite> if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumScalarFunction.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction.L" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the Lipschitz constant for the SumFunction</p>
<div class="math notranslate nohighlight">
\[L = \sum_{i} L_{i}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{i}\)</span> is the Lipschitz constant of the smooth function <span class="math notranslate nohighlight">\(F_{i}\)</span>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumScalarFunction.Lmax">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Lmax</span></span><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction.Lmax" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the maximum Lipschitz constant for the SumFunction</p>
<div class="math notranslate nohighlight">
\[L = \max_{i}\{L_{i}\}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{i}\)</span> is the Lipschitz constant of the smooth function <span class="math notranslate nohighlight">\(F_{i}\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumScalarFunction.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction.centered_at" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumScalarFunction.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the sum of the gradient of functions evaluated at <span class="math notranslate nohighlight">\(x\)</span>, if all of them are differentiable.</p>
<div class="math notranslate nohighlight">
\[(F'_{1} + F'_{2} + ... + F'_{n})(x) = F'_{1}(x) + F'_{2}(x) + ... + F'_{n}(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – Point to evaluate the gradient at.</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the value of the sum of the gradients evaluated at point <span class="math notranslate nohighlight">\(x\)</span> or <cite>None</cite> if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumScalarFunction.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction.proximal_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.TranslateFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">TranslateFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#TranslateFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction" title="Permalink to this definition">#</a></dt>
<dd><p>TranslateFunction represents the translation of function F with respect to the center b.</p>
<p>Let a function F and consider <span class="math notranslate nohighlight">\(G(x) = F(x - center)\)</span>.</p>
<p>Function F is centered at 0, whereas G is centered at point b.</p>
<p>If <span class="math notranslate nohighlight">\(G(x) = F(x - b)\)</span> then:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(G(x) = F(x - b)\)</span> ( __call__ method )</p></li>
<li><p><span class="math notranslate nohighlight">\(G'(x) = F'(x - b)\)</span> ( gradient method )</p></li>
<li><p><span class="math notranslate nohighlight">\(G^{*}(x^{*}) = F^{*}(x^{*}) + &lt;x^{*}, b &gt;\)</span> ( convex_conjugate method )</p></li>
<li><p><span class="math notranslate nohighlight">\(\text{prox}_{\tau G}(x) = \text{prox}_{\tau F}(x - b)  + b\)</span> ( proximal method )</p></li>
</ol>
<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.TranslateFunction.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.TranslateFunction.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction.centered_at" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.TranslateFunction.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction.proximal_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.TranslateFunction.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#TranslateFunction.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the gradient of the translated function.</p>
<div class="math notranslate nohighlight">
\[G'(x) =  F'(x - b)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – Point to evaluate the gradient at.</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the gradient of the translated function evaluated at <span class="math notranslate nohighlight">\(x\)</span> or <cite>None</cite> if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.TranslateFunction.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#TranslateFunction.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the translated function.</p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau G}(x) = \text{prox}_{\tau F}(x-b) + b\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the proximal operator of the translated function at <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(\tau\)</span> or <cite>None</cite> if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.TranslateFunction.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#TranslateFunction.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the convex conjugate of the translated function.</p>
<div class="math notranslate nohighlight">
\[G^{*}(x^{*}) = F^{*}(x^{*}) + &lt;x^{*}, b &gt;\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The value of the convex conjugate of the translated function at <span class="math notranslate nohighlight">\(x\)</span>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="simple-functions">
<h3>Simple functions<a class="headerlink" href="#simple-functions" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.ConstantFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">ConstantFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#ConstantFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction" title="Permalink to this definition">#</a></dt>
<dd><p>ConstantFunction: <span class="math notranslate nohighlight">\(F(x) = constant, constant\in\mathbb{R}\)</span></p>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ConstantFunction.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#ConstantFunction.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of the function, <span class="math notranslate nohighlight">\(F'(x)=0\)</span>
:param x: Point to evaluate the gradient at.
:type x: DataContainer
:param out:
:type out: return DataContainer, if None a new DataContainer is returned, default None.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A DataContainer of zeros, the same size as <span class="math notranslate nohighlight">\(x\)</span> or <cite>None</cite> if <cite>out</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ConstantFunction.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#ConstantFunction.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>The convex conjugate of constant function <span class="math notranslate nohighlight">\(F(x) = c\in\mathbb{R}\)</span> is</p>
<div class="math notranslate nohighlight">
\[\begin{split}F(x^{*})
=
\begin{cases}
    -c, &amp; if x^{*} = 0\\
    \infty, &amp; \mbox{otherwise}
\end{cases}\end{split}\]</div>
<p>However, <span class="math notranslate nohighlight">\(x^{*} = 0\)</span> only in the limit of iterations, so in fact this can be infinity.
We do not want to have inf values in the convex conjugate, so we have to penalise this value accordingly.
The following penalisation is useful in the PDHG algorithm, when we compute primal &amp; dual objectives
for convergence purposes.</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \sum \max\{x^{*}, 0\}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The maximum of x and 0, summed over the entries of x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ConstantFunction.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#ConstantFunction.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the constant function, which is the same element, i.e.,</p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F}(x) = x\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, equal to <span class="math notranslate nohighlight">\(x\)</span> or <cite>None</cite> if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.ConstantFunction.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ConstantFunction.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.centered_at" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ConstantFunction.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.proximal_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.ZeroFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">ZeroFunction</span></span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#ZeroFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ZeroFunction" title="Permalink to this definition">#</a></dt>
<dd><p>ZeroFunction represents the zero function, <span class="math notranslate nohighlight">\(F(x) = 0\)</span></p>
<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.ZeroFunction.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.ZeroFunction.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ZeroFunction.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.ZeroFunction.centered_at" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ZeroFunction.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.ZeroFunction.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>The convex conjugate of constant function <span class="math notranslate nohighlight">\(F(x) = c\in\mathbb{R}\)</span> is</p>
<div class="math notranslate nohighlight">
\[\begin{split}F(x^{*})
=
\begin{cases}
    -c, &amp; if x^{*} = 0\\
    \infty, &amp; \mbox{otherwise}
\end{cases}\end{split}\]</div>
<p>However, <span class="math notranslate nohighlight">\(x^{*} = 0\)</span> only in the limit of iterations, so in fact this can be infinity.
We do not want to have inf values in the convex conjugate, so we have to penalise this value accordingly.
The following penalisation is useful in the PDHG algorithm, when we compute primal &amp; dual objectives
for convergence purposes.</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \sum \max\{x^{*}, 0\}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The maximum of x and 0, summed over the entries of x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ZeroFunction.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.ZeroFunction.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of the function, <span class="math notranslate nohighlight">\(F'(x)=0\)</span>
:param x: Point to evaluate the gradient at.
:type x: DataContainer
:param out:
:type out: return DataContainer, if None a new DataContainer is returned, default None.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A DataContainer of zeros, the same size as <span class="math notranslate nohighlight">\(x\)</span> or <cite>None</cite> if <cite>out</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ZeroFunction.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.ZeroFunction.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the constant function, which is the same element, i.e.,</p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F}(x) = x\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, equal to <span class="math notranslate nohighlight">\(x\)</span> or <cite>None</cite> if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ZeroFunction.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.ZeroFunction.proximal_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.Rosenbrock">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">Rosenbrock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Rosenbrock/#Rosenbrock"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Rosenbrock" title="Permalink to this definition">#</a></dt>
<dd><p>Rosenbrock function</p>
<div class="math notranslate nohighlight">
\[\]</div>
<p>F(x,y) = (alpha - x)^2 + beta(y-x^2)^2</p>
<p>The function has a global minimum at .. math:: (x,y)=(alpha, alpha^2)</p>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.Rosenbrock.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Rosenbrock/#Rosenbrock.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Rosenbrock.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Gradient of the Rosenbrock function</p>
<div class="math notranslate nohighlight">
\[\]</div>
<p>nabla f(x,y) = left[ 2*((x-alpha) - 2beta x(y-x^2)) ; 2beta (y - x^2)  right]</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.Rosenbrock.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.Rosenbrock.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.Rosenbrock.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.Rosenbrock.centered_at" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.Rosenbrock.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.Rosenbrock.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Evaluation of the function F* at x, where F* is the convex conjugate of function F,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x}{\sup} \langle x^{*}, x \rangle - F(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The value of the convex conjugate of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.Rosenbrock.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.Rosenbrock.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of function <span class="math notranslate nohighlight">\(\tau F\)</span>  evaluated at x</p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F}(x) = \underset{z}{\text{argmin}} \frac{1}{2}\|z - x\|^{2} + \tau F(z)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the proximal operator of the function at x with scalar <span class="math notranslate nohighlight">\(\tau\)</span> or <cite>None</cite> if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.Rosenbrock.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.Rosenbrock.proximal_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="composition-of-operator-and-a-function">
<h3>Composition of operator and a function<a class="headerlink" href="#composition-of-operator-and-a-function" title="Permalink to this headline">#</a></h3>
<p>This class allows the user to write a function which does the following:</p>
<div class="math notranslate nohighlight">
\[F ( x ) = G ( Ax )\]</div>
<p>where <span class="math notranslate nohighlight">\(A\)</span> is an operator. For instance the least squares function <a href="#id51"><span class="problematic" id="id52">l2norm_</span></a> <code class="code docutils literal notranslate"><span class="pre">Norm2Sq</span></code> can
be expressed as</p>
<div class="math notranslate nohighlight">
\[F(x) = || Ax - b ||^2_2\]</div>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.OperatorCompositionFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">OperatorCompositionFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/OperatorCompositionFunction/#OperatorCompositionFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction" title="Permalink to this definition">#</a></dt>
<dd><p>Composition of a function with an operator as : <span class="math notranslate nohighlight">\((F \otimes A)(x) = F(Ax)\)</span></p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">parameter function</dt>
<dd class="field-odd"><p><code class="code docutils literal notranslate"><span class="pre">Function</span></code> F</p>
</dd>
<dt class="field-even">parameter operator</dt>
<dd class="field-even"><p><code class="code docutils literal notranslate"><span class="pre">Operator</span></code> A</p>
</dd>
</dl>
</div></blockquote>
<p>For general operator, we have no explicit formulas for convex_conjugate,
proximal and proximal_conjugate</p>
<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.OperatorCompositionFunction.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.OperatorCompositionFunction.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/OperatorCompositionFunction/#OperatorCompositionFunction.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Return the gradient of F(Ax),</p>
<p>..math ::  (F(Ax))’ = A^{T}F’(Ax)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.OperatorCompositionFunction.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction.centered_at" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.OperatorCompositionFunction.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Evaluation of the function F* at x, where F* is the convex conjugate of function F,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x}{\sup} \langle x^{*}, x \rangle - F(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The value of the convex conjugate of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.OperatorCompositionFunction.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of function <span class="math notranslate nohighlight">\(\tau F\)</span>  evaluated at x</p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F}(x) = \underset{z}{\text{argmin}} \frac{1}{2}\|z - x\|^{2} + \tau F(z)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the proximal operator of the function at x with scalar <span class="math notranslate nohighlight">\(\tau\)</span> or <cite>None</cite> if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.OperatorCompositionFunction.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction.proximal_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="indicator-box">
<h3>Indicator box<a class="headerlink" href="#indicator-box" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.IndicatorBox">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">IndicatorBox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accelerated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/IndicatorBox/#IndicatorBox"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox" title="Permalink to this definition">#</a></dt>
<dd><p>Indicator function for box constraint</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}f(x) = \mathbb{I}_{[a, b]} = \begin{cases}
                                   0, \text{ if } x \in [a, b] \\
                                   \infty, \text{otherwise}
                            \end{cases}\end{split}\]</div>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lower</strong> (<em>float</em><em>, </em><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><em>numpy array</em><em>, </em><em>default None</em>) – Lower bound. If set to None, it is equivalent to <code class="docutils literal notranslate"><span class="pre">-np.inf</span></code>.</p></li>
<li><p><strong>upper</strong> (<em>float</em><em>, </em><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><em>numpy array</em><em>, </em><em>default None</em>) – Upper bound. If set to None, it is equivalent to <code class="docutils literal notranslate"><span class="pre">np.inf</span></code>.</p></li>
<li><p><strong>accelerated</strong> (<em>bool</em><em>, </em><em>default True</em>) – Specifies whether to use the accelerated version or not, using numba or
numpy backends respectively.</p></li>
</ul>
</dd>
</dl>
<p>If <code class="docutils literal notranslate"><span class="pre">lower</span></code> or <code class="docutils literal notranslate"><span class="pre">upper</span></code> are passed a <code class="docutils literal notranslate"><span class="pre">DataContainer</span></code> (or derived class
such as <code class="docutils literal notranslate"><span class="pre">ImageData</span></code> or <code class="docutils literal notranslate"><span class="pre">AcquisitionData</span></code>) or a <code class="docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>, the bounds
can be set to different values for each element.</p>
<p>In order to save computing time it is possible to suppress the evaluation of
the function. This is achieved by setting <code class="docutils literal notranslate"><span class="pre">suppress_evaluation</span></code> to <code class="docutils literal notranslate"><span class="pre">True</span></code>.
<code class="docutils literal notranslate"><span class="pre">IndicatorBox</span></code> evaluated on any input will then return 0.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">accelerated</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> (default), the Numba backend is used.
Otherwise, the Numpy backend is used. An optional parameter to set the number of
threads used by Numba can be set with <code class="docutils literal notranslate"><span class="pre">set_num_threads</span></code>. Setting the number of
threads when <code class="docutils literal notranslate"><span class="pre">accelerate</span></code> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code> will not have any effect.
The default number of threads is defined in the <code class="docutils literal notranslate"><span class="pre">cil.utilities.multiprocessing</span></code>
module, and it is equivalent to half of the CPU cores available.</p>
<p>In order to save computing time it is possible to suppress the evaluation of the
function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ib</span> <span class="o">=</span> <span class="n">IndicatorBox</span><span class="p">(</span><span class="n">lower</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ib</span><span class="o">.</span><span class="n">set_suppress_evaluation</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ib</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># returns 0</span>
</pre></div>
</div>
<p>Set the number of threads used in accelerated mode.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">num_threads</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">ib</span> <span class="o">=</span> <span class="n">IndicatorBox</span><span class="p">(</span><span class="n">lower</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ib</span><span class="o">.</span><span class="n">set_num_threads</span><span class="p">(</span><span class="n">num_threads</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.IndicatorBox.set_suppress_evaluation">
<span class="sig-name descname"><span class="pre">set_suppress_evaluation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/IndicatorBox/#IndicatorBox.set_suppress_evaluation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.set_suppress_evaluation" title="Permalink to this definition">#</a></dt>
<dd><p>Suppresses the evaluation of the function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>value</strong> (<em>bool</em>) – If True, the function evaluation on any input will return 0, without calculation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.IndicatorBox.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/IndicatorBox/#IndicatorBox.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Proximal operator of IndicatorBox at x</p>
<div class="math notranslate nohighlight">
\[prox_{\tau * f}(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – Input to the proximal operator</p></li>
<li><p><strong>tau</strong> (<em>float</em>) – Step size. Notice it is ignored in IndicatorBox</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>optional</em>) – Output of the proximal operator. If not provided, a new DataContainer is created.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">tau</span></code> is ignored but it is in the signature of the generic Function class</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.IndicatorBox.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/IndicatorBox/#IndicatorBox.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>IndicatorBox is not differentiable, so calling gradient will raise a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.IndicatorBox.num_threads">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_threads</span></span><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.num_threads" title="Permalink to this definition">#</a></dt>
<dd><p>Get the optional number of threads parameter to use for the accelerated version.</p>
<p>Defaults to the value set in the CIL multiprocessing module.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.IndicatorBox.set_num_threads">
<span class="sig-name descname"><span class="pre">set_num_threads</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/IndicatorBox/#IndicatorBox.set_num_threads"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.set_num_threads" title="Permalink to this definition">#</a></dt>
<dd><p>Set the optional number of threads parameter to use for the accelerated version.</p>
<p>This is discarded if <code class="docutils literal notranslate"><span class="pre">accelerated=False</span></code>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.IndicatorBox.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.IndicatorBox.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.centered_at" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.IndicatorBox.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Evaluation of the function F* at x, where F* is the convex conjugate of function F,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x}{\sup} \langle x^{*}, x \rangle - F(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The value of the convex conjugate of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.IndicatorBox.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.proximal_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="kullbackleibler">
<h3>KullbackLeibler<a class="headerlink" href="#kullbackleibler" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.KullbackLeibler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">KullbackLeibler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'numba'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/KullbackLeibler/#KullbackLeibler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler" title="Permalink to this definition">#</a></dt>
<dd><p>Kullback Leibler</p>
<div class="math notranslate nohighlight">
\[\begin{split}F(u, v)
= \begin{cases}
u \log(\frac{u}{v}) - u + v &amp; \mbox{ if } u &gt; 0, v &gt; 0\\
v &amp; \mbox{ if } u = 0, v \ge 0 \\
\infty, &amp; \mbox{otherwise}
\end{cases}\end{split}\]</div>
<p>where the <span class="math notranslate nohighlight">\(0\log0 := 0\)</span> convention is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>b</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>non-negative</em>) – Translates the function at point <cite>b</cite>.</p></li>
<li><p><strong>eta</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>default = 0</em>) – Background noise</p></li>
<li><p><strong>mask</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>default = None</em>) – Mask for the data <cite>b</cite></p></li>
<li><p><strong>backend</strong> (<em>{'numba'</em><em>,</em><em>'numpy'}</em><em>, </em><em>optional</em>) – Backend for the KullbackLeibler methods. Numba is the default backend.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Kullback-Leibler function is used in practice as a fidelity term in minimisation problems where the
acquired data follow Poisson distribution. If we denote the acquired data with <code class="code docutils literal notranslate"><span class="pre">b</span></code>
then, we write</p>
<div class="math notranslate nohighlight">
\[\underset{i}{\sum} F(b_{i}, (v + \eta)_{i})\]</div>
<p>where, <span class="math notranslate nohighlight">\(\eta\)</span> is an additional noise.</p>
<p>In the case of Positron Emission Tomography reconstruction <span class="math notranslate nohighlight">\(\eta\)</span> represents
scatter and random events contribution during the PET acquisition. Hence, in that case the KullbackLeibler
fidelity measures the distance between <span class="math notranslate nohighlight">\(\mathcal{A}v + \eta\)</span> and acquisition data <span class="math notranslate nohighlight">\(b\)</span>, where
<span class="math notranslate nohighlight">\(\mathcal{A}\)</span> is the projection operator. This is related to <a class="reference external" href="http://stir.sourceforge.net/documentation/doxy/html/classstir_1_1PoissonLogLikelihoodWithLinearModelForMean.html">PoissonLogLikelihoodWithLinearModelForMean</a> ,
definition that is used in PET reconstruction in the <a class="reference external" href="https://github.com/SyneRBI/SIRF">SIRF</a> software.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default implementation uses the build-in function <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.kl_div.html">kl_div</a> from scipy.
The methods of the <a class="reference internal" href="#cil.optimisation.functions.KullbackLeibler" title="cil.optimisation.functions.KullbackLeibler.KullbackLeibler"><code class="xref py py-class docutils literal notranslate"><span class="pre">KullbackLeibler</span></code></a> are accelerated provided that <a class="reference external" href="https://numba.pydata.org/">numba</a> library is installed.</p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cil.optimisation.functions</span> <span class="kn">import</span> <span class="n">KullbackLeibler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cil.framework</span> <span class="kn">import</span> <span class="n">ImageGeometry</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ig</span> <span class="o">=</span> <span class="n">ImageGeometry</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s1">&#39;random&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">KullbackLeibler</span><span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.KullbackLeibler.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.KullbackLeibler.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler.centered_at" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.KullbackLeibler.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Evaluation of the function F* at x, where F* is the convex conjugate of function F,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x}{\sup} \langle x^{*}, x \rangle - F(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The value of the convex conjugate of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.KullbackLeibler.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of function <span class="math notranslate nohighlight">\(F\)</span>  evaluated at <span class="math notranslate nohighlight">\(x\)</span>, if it is differentiable</p>
<div class="math notranslate nohighlight">
\[F'(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the value of the gradient of the function at x or <cite>None</cite> if <cite>out</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.KullbackLeibler.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of function <span class="math notranslate nohighlight">\(\tau F\)</span>  evaluated at x</p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F}(x) = \underset{z}{\text{argmin}} \frac{1}{2}\|z - x\|^{2} + \tau F(z)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the proximal operator of the function at x with scalar <span class="math notranslate nohighlight">\(\tau\)</span> or <cite>None</cite> if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.KullbackLeibler.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler.proximal_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="l1-norm">
<h3>L1 Norm<a class="headerlink" href="#l1-norm" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.L1Norm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">L1Norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L1Norm/#L1Norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L1Norm" title="Permalink to this definition">#</a></dt>
<dd><p>L1Norm function</p>
<p>Consider the following cases:</p>
<ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[F(x) = ||x||_{1}\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[F(x) = ||x - b||_{1}\]</div>
</li>
</ol>
<p>In the weighted case, <span class="math notranslate nohighlight">\(w\)</span> is an array of positive weights.</p>
<ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[F(x) = ||x||_{L^1(w)}\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[F(x) = ||x - b||_{L^1(w)}\]</div>
</li>
</ol>
<p>with <span class="math notranslate nohighlight">\(||x||_{L^1(w)} = || x \cdot w||_1 = \sum_{i=1}^{n} |x_i| w_i\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weight</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>numpy ndarray</em><em>, </em><em>default None</em>) – Array of positive weights. If <code class="code docutils literal notranslate"><span class="pre">None</span></code> returns the L1 Norm.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>default None</em>) – Translation of the function.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.L1Norm.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L1Norm/#L1Norm.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L1Norm.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the convex conjugate of the L1 Norm function at x.</p>
<p>This is the indicator of the unit <span class="math notranslate nohighlight">\(L^{\infty}\)</span> norm:</p>
<ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \mathbb{I}_{\{\|\cdot\|_{\infty}\leq1\}}(x^{*})\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \mathbb{I}_{\{\|\cdot\|_{\infty}\leq1\}}(x^{*}) + \langle x^{*},b\rangle\]</div>
</li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbb{I}_{\{\|\cdot\|_{\infty}\leq1\}}(x^{*})
= \begin{cases}
0, \mbox{if } \|x^{*}\|_{\infty}\leq1\\
\infty, \mbox{otherwise}
\end{cases}\end{split}\]</div>
<p>In the weighted case the convex conjugate is the indicator of the unit
<span class="math notranslate nohighlight">\(L^{\infty}\)</span> norm.</p>
<p>See:
<a class="reference external" href="https://math.stackexchange.com/questions/1533217/convex-conjugate-of-l1-norm-function-with-weight">https://math.stackexchange.com/questions/1533217/convex-conjugate-of-l1-norm-function-with-weight</a></p>
<ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \mathbb{I}_{\{\|\cdot\|_{L^\infty(w^{-1})}\leq 1\}}(x^{*})\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \mathbb{I}_{\{\|\cdot\|_{L^\infty(w^{-1})}\leq 1\}}(x^{*}) + \langle x^{*},b\rangle\]</div>
</li>
</ol>
<p>with <span class="math notranslate nohighlight">\(\|x\|_{L^\infty(w^{-1})} = \max_{i} \frac{|x_i|}{w_i}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – where to evaluate the convex conjugate of the L1 Norm function.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>the value of the convex conjugate of the WeightedL1Norm function at x</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>DataContainer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.L1Norm.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L1Norm/#L1Norm.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L1Norm.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the proximal operator of the L1 Norm function at x with scaling parameter <cite>tau</cite>.</p>
<p>Consider the following cases:</p>
<ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \mathrm{ShinkOperator}(x)\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \mathrm{ShinkOperator}(x) + b\]</div>
</li>
</ol>
<p>where,</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \mathrm{ShinkOperator}(x) = sgn(x) * \max\{ |x| - \tau, 0 \}\]</div>
<p>The weighted case follows from Example 6.23 in Chapter 6 of “First-Order Methods in Optimization”
by Amir Beck, SIAM 2017 <a class="reference external" href="https://archive.siam.org/books/mo25/mo25_ch6.pdf">https://archive.siam.org/books/mo25/mo25_ch6.pdf</a></p>
<ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \mathrm{ShinkOperator}_{\tau*w}(x)\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \mathrm{ShinkOperator}_{\tau*w}(x) + b\]</div>
</li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>float</em><em>, </em><em>ndarray</em><em>, </em><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>default None</em>) – If not None, the result will be stored in this object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>The value of the proximal operator of the L1 norm function at x</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>DataContainer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.L1Norm.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.L1Norm.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.L1Norm.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.L1Norm.centered_at" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.L1Norm.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.L1Norm.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of function <span class="math notranslate nohighlight">\(F\)</span>  evaluated at <span class="math notranslate nohighlight">\(x\)</span>, if it is differentiable</p>
<div class="math notranslate nohighlight">
\[F'(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the value of the gradient of the function at x or <cite>None</cite> if <cite>out</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.L1Norm.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.L1Norm.proximal_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="l2-norm-squared">
<h3>L2 Norm Squared<a class="headerlink" href="#l2-norm-squared" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.L2NormSquared">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">L2NormSquared</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L2NormSquared/#L2NormSquared"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared" title="Permalink to this definition">#</a></dt>
<dd><p>L2NormSquared function: <span class="math notranslate nohighlight">\(F(x) = \| x\|^{2}_{2} = \underset{i}{\sum}x_{i}^{2}\)</span></p>
<p>Following cases are considered:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p><span class="math notranslate nohighlight">\(F(x) = \|x\|^{2}_{2}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(F(x) = \|x - b\|^{2}_{2}\)</span></p></li>
</ol>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>b</strong> (<cite>DataContainer</cite>, optional) – Translation of the function</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For case b) we can use <code class="code docutils literal notranslate"><span class="pre">F</span> <span class="pre">=</span> <span class="pre">L2NormSquared().centered_at(b)</span></code>, see <em>TranslateFunction</em>.</p>
</div>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">L2NormSquared</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">L2NormSquared</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">L2NormSquared</span><span class="p">()</span><span class="o">.</span><span class="n">centered_at</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.L2NormSquared.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L2NormSquared/#L2NormSquared.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of the L2NormSquared function at x.</p>
<p>Following cases are considered:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p><span class="math notranslate nohighlight">\(F'(x) = 2x\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(F'(x) = 2(x-b)\)</span></p></li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.L2NormSquared.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L2NormSquared/#L2NormSquared.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the convex conjugate of the L2NormSquared function at x.</p>
<p>Consider the following cases:</p>
<blockquote>
<div><ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \frac{1}{4}\|x^{*}\|^{2}_{2}\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \frac{1}{4}\|x^{*}\|^{2}_{2} + \langle x^{*}, b\rangle\]</div>
</li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.L2NormSquared.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L2NormSquared/#L2NormSquared.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the proximal operator of the L2NormSquared function at x.</p>
<p>Consider the following cases:</p>
<blockquote>
<div><ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[\text{prox}_{\tau F}(x) = \frac{x}{1+2\tau}\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[\text{prox}_{\tau F}(x) = \frac{x-b}{1+2\tau} + b\]</div>
</li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.L2NormSquared.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.L2NormSquared.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared.centered_at" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.L2NormSquared.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared.proximal_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.WeightedL2NormSquared">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">WeightedL2NormSquared</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L2NormSquared/#WeightedL2NormSquared"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared" title="Permalink to this definition">#</a></dt>
<dd><p>WeightedL2NormSquared function: <span class="math notranslate nohighlight">\(F(x) = \|x\|_{W,2}^2 = \Sigma_iw_ix_i^2 = \langle x, Wx\rangle = x^TWx\)</span>
where <span class="math notranslate nohighlight">\(W=\text{diag}(weight)\)</span> if <cite>weight</cite> is a <cite>DataContainer</cite> or <span class="math notranslate nohighlight">\(W=\text{weight} I\)</span> if <cite>weight</cite> is a scalar.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>**kwargs</strong> – </p></li>
<li><p><strong>weight</strong> (a <cite>scalar</cite> or a <cite>DataContainer</cite> with the same shape as the intended domain of this <cite>WeightedL2NormSquared</cite> function) – </p></li>
<li><p><strong>b</strong> (a <cite>DataContainer</cite> with the same shape as the intended domain of this <cite>WeightedL2NormSquared</cite> function) – A shift so that the function becomes  <span class="math notranslate nohighlight">\(F(x) = \| x-b\|_{W,2}^2 = \Sigma_iw_i(x_i-b_i)^2 = \langle x-b, W(x-b) \rangle = (x-b)^TW(x-b)\)</span></p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.WeightedL2NormSquared.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L2NormSquared/#WeightedL2NormSquared.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of <span class="math notranslate nohighlight">\(F'(x) = 2Wx\)</span> or, if <cite>b</cite> is defined,  <span class="math notranslate nohighlight">\(F'(x) = 2W(x-b)\)</span>
where <span class="math notranslate nohighlight">\(W=\text{diag}(weight)\)</span> if <cite>weight</cite> is a <cite>DataContainer</cite> or <span class="math notranslate nohighlight">\(\text{weight}I\)</span> if <cite>weight</cite> is a scalar.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.WeightedL2NormSquared.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L2NormSquared/#WeightedL2NormSquared.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the convex conjugate of the WeightedL2NormSquared function at x.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.WeightedL2NormSquared.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.WeightedL2NormSquared.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared.centered_at" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.WeightedL2NormSquared.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L2NormSquared/#WeightedL2NormSquared.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the proximal operator of the WeightedL2NormSquared function at x.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.WeightedL2NormSquared.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared.proximal_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="least-squares">
<h3>Least Squares<a class="headerlink" href="#least-squares" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.LeastSquares">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">LeastSquares</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/LeastSquares/#LeastSquares"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.LeastSquares" title="Permalink to this definition">#</a></dt>
<dd><p>(Weighted) Least Squares function</p>
<div class="math notranslate nohighlight">
\[F(x) = c\|Ax-b\|_2^2\]</div>
<p>or if weighted</p>
<div class="math notranslate nohighlight">
\[F(x) = c\|Ax-b\|_{2,W}^{2}\]</div>
<p>where <span class="math notranslate nohighlight">\(W=\text{diag}(weight)\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<a class="reference internal" href="#cil.optimisation.operators.LinearOperator" title="cil.optimisation.operators.LinearOperator"><em>LinearOperator</em></a>) – </p></li>
<li><p><strong>b</strong> (<em>Data</em><em>, </em><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>c</strong> (<em>Scaling Constant</em><em>, </em><em>float</em><em>, </em><em>default 1.0</em>) – </p></li>
<li><p><strong>weight</strong> (<em>DataContainer with all positive elements of size of the range of operator A</em><em>, </em><em>default None</em>) – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>L is the  Lipshitz Constant of the gradient of <span class="math notranslate nohighlight">\(F\)</span> which is <span class="math notranslate nohighlight">\(2 c ||A||_2^2 = 2 c \sigma_1(A)^2\)</span>, or <span class="math notranslate nohighlight">\(2 c ||W|| ||A||_2^2 = 2c||W|| \sigma_1(A)^2\)</span>, where <span class="math notranslate nohighlight">\(\sigma_1(A)\)</span> is the largest singular value of <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(W=\text{diag}(weight)\)</span>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.LeastSquares.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/LeastSquares/#LeastSquares.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.LeastSquares.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of <span class="math notranslate nohighlight">\(F(x)\)</span>:</p>
<div class="math notranslate nohighlight">
\[F'(x) = 2cA^T(Ax-b)\]</div>
<p>or</p>
<div class="math notranslate nohighlight">
\[F'(x) = 2cA^T(W(Ax-b))\]</div>
<p>where <span class="math notranslate nohighlight">\(W=\text{diag}(weight)\)</span>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.LeastSquares.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.LeastSquares.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.LeastSquares.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.LeastSquares.centered_at" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.LeastSquares.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.LeastSquares.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Evaluation of the function F* at x, where F* is the convex conjugate of function F,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x}{\sup} \langle x^{*}, x \rangle - F(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The value of the convex conjugate of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.LeastSquares.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.LeastSquares.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of function <span class="math notranslate nohighlight">\(\tau F\)</span>  evaluated at x</p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F}(x) = \underset{z}{\text{argmin}} \frac{1}{2}\|z - x\|^{2} + \tau F(z)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the proximal operator of the function at x with scalar <span class="math notranslate nohighlight">\(\tau\)</span> or <cite>None</cite> if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.LeastSquares.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.LeastSquares.proximal_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="mixed-l21-norm">
<h3>Mixed L21 norm<a class="headerlink" href="#mixed-l21-norm" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.MixedL21Norm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">MixedL21Norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/MixedL21Norm/#MixedL21Norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm" title="Permalink to this definition">#</a></dt>
<dd><p>MixedL21Norm function: <span class="math notranslate nohighlight">\(F(x) = ||x||_{2,1} = \sum |x|_{2} = \sum \sqrt{ (x^{1})^{2} + (x^{2})^{2} + \dots}\)</span></p>
<p>where x is a BlockDataContainer, i.e., <span class="math notranslate nohighlight">\(x=(x^{1}, x^{2}, \dots)\)</span></p>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.MixedL21Norm.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/MixedL21Norm/#MixedL21Norm.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the convex conjugate of the MixedL21Norm function at x.</p>
<p>This is the Indicator function of <span class="math notranslate nohighlight">\(\mathbb{I}_{\{\|\cdot\|_{2,\infty}\leq1\}}(x^{*})\)</span>,</p>
<p>i.e.,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbb{I}_{\{\|\cdot\|_{2, \infty}\leq1\}}(x^{*})
= \begin{cases}
0, \mbox{if } \|x\|_{2, \infty}\leq1\\
\infty, \mbox{otherwise}
\end{cases}\end{split}\]</div>
<p>where,</p>
<div class="math notranslate nohighlight">
\[\|x\|_{2,\infty} = \max\{ \|x\|_{2} \} = \max\{ \sqrt{ (x^{1})^{2} + (x^{2})^{2} + \dots}\}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.MixedL21Norm.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/MixedL21Norm/#MixedL21Norm.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the proximal operator of the MixedL21Norm function at x.</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \frac{x}{\|x\|_{2}}\max\{ \|x\|_{2} - \tau, 0 \}\]</div>
<p>where the convention 0 · (0/0) = 0 is used.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.MixedL21Norm.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.MixedL21Norm.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm.centered_at" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.MixedL21Norm.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of function <span class="math notranslate nohighlight">\(F\)</span>  evaluated at <span class="math notranslate nohighlight">\(x\)</span>, if it is differentiable</p>
<div class="math notranslate nohighlight">
\[F'(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the value of the gradient of the function at x or <cite>None</cite> if <cite>out</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.MixedL21Norm.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm.proximal_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="smooth-mixed-l21-norm">
<h3>Smooth Mixed L21 norm<a class="headerlink" href="#smooth-mixed-l21-norm" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.SmoothMixedL21Norm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">SmoothMixedL21Norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">epsilon</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/MixedL21Norm/#SmoothMixedL21Norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SmoothMixedL21Norm" title="Permalink to this definition">#</a></dt>
<dd><p>SmoothMixedL21Norm function: <span class="math notranslate nohighlight">\(F(x) = ||x||_{2,1} = \sum |x|_{2} = \sum \sqrt{ (x^{1})^{2} + (x^{2})^{2} + \epsilon^2 + \dots}\)</span></p>
<p>where x is a BlockDataContainer, i.e., <span class="math notranslate nohighlight">\(x=(x^{1}, x^{2}, \dots)\)</span></p>
<p>Conjugate, proximal and proximal conjugate methods no closed-form solution</p>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SmoothMixedL21Norm.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/MixedL21Norm/#SmoothMixedL21Norm.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SmoothMixedL21Norm.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of the SmoothMixedL21Norm function at x.</p>
<p>frac{x}{<a href="#id49"><span class="problematic" id="id50">|x|</span></a>}</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.SmoothMixedL21Norm.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.SmoothMixedL21Norm.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SmoothMixedL21Norm.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SmoothMixedL21Norm.centered_at" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SmoothMixedL21Norm.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SmoothMixedL21Norm.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Evaluation of the function F* at x, where F* is the convex conjugate of function F,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x}{\sup} \langle x^{*}, x \rangle - F(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The value of the convex conjugate of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SmoothMixedL21Norm.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SmoothMixedL21Norm.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of function <span class="math notranslate nohighlight">\(\tau F\)</span>  evaluated at x</p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F}(x) = \underset{z}{\text{argmin}} \frac{1}{2}\|z - x\|^{2} + \tau F(z)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the proximal operator of the function at x with scalar <span class="math notranslate nohighlight">\(\tau\)</span> or <cite>None</cite> if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SmoothMixedL21Norm.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SmoothMixedL21Norm.proximal_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="mixed-l11-norm">
<h3>Mixed L11 norm<a class="headerlink" href="#mixed-l11-norm" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.MixedL11Norm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">MixedL11Norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L1Norm/#MixedL11Norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL11Norm" title="Permalink to this definition">#</a></dt>
<dd><p>MixedL11Norm function</p>
<div class="math notranslate nohighlight">
\[F(x) = ||x||_{1,1} = \sum |x_{1}| + |x_{2}| + \cdots + |x_{n}|\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>MixedL11Norm is a separable function, therefore it can also be defined using the <a class="reference internal" href="#cil.optimisation.functions.BlockFunction" title="cil.optimisation.functions.BlockFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockFunction</span></code></a>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#cil.optimisation.functions.L1Norm" title="cil.optimisation.functions.L1Norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">L1Norm</span></code></a>, <a class="reference internal" href="#cil.optimisation.functions.MixedL21Norm" title="cil.optimisation.functions.MixedL21Norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MixedL21Norm</span></code></a></p>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.MixedL11Norm.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.MixedL11Norm.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.MixedL11Norm.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.MixedL11Norm.centered_at" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.MixedL11Norm.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.MixedL11Norm.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Evaluation of the function F* at x, where F* is the convex conjugate of function F,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x}{\sup} \langle x^{*}, x \rangle - F(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The value of the convex conjugate of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.MixedL11Norm.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.MixedL11Norm.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of function <span class="math notranslate nohighlight">\(F\)</span>  evaluated at <span class="math notranslate nohighlight">\(x\)</span>, if it is differentiable</p>
<div class="math notranslate nohighlight">
\[F'(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the value of the gradient of the function at x or <cite>None</cite> if <cite>out</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.MixedL11Norm.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L1Norm/#MixedL11Norm.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL11Norm.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the proximal operator of the MixedL11Norm function at x.</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \mathrm{ShinkOperator}(x)\]</div>
<p>where,</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \mathrm{ShinkOperator}(x) := sgn(x) * \max\{ |x| - \tau, 0 \}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.MixedL11Norm.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.MixedL11Norm.proximal_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="total-variation">
<h3>Total variation<a class="headerlink" href="#total-variation" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.TotalVariation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">TotalVariation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_iteration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">correlation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Space'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'c'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isotropic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">info</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strong_convexity_constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warm_start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/TotalVariation/#TotalVariation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation" title="Permalink to this definition">#</a></dt>
<dd><p>Total variation Function</p>
<div class="math notranslate nohighlight">
\[\mathrm{TV}(u) := \|\nabla u\|_{2,1} = \sum \|\nabla u\|_{2},\, (\mbox{isotropic})\]</div>
<div class="math notranslate nohighlight">
\[\mathrm{TV}(u) := \|\nabla u\|_{1,1} = \sum \|\nabla u\|_{1}\, (\mbox{anisotropic})\]</div>
<p class="rubric">Notes</p>
<p>The <code class="code docutils literal notranslate"><span class="pre">TotalVariation</span></code> (TV) <code class="code docutils literal notranslate"><span class="pre">Function</span></code> acts as a composite function, i.e.,
the composition of the <a class="reference internal" href="#cil.optimisation.functions.MixedL21Norm" title="cil.optimisation.functions.MixedL21Norm"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedL21Norm</span></code></a> function and the <a class="reference internal" href="#cil.optimisation.operators.GradientOperator" title="cil.optimisation.operators.GradientOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientOperator</span></code></a> operator,</p>
<div class="math notranslate nohighlight">
\[f(u) = \|u\|_{2,1}, \Rightarrow (f\circ\nabla)(u) = f(\nabla x) = \mathrm{TV}(u)\]</div>
<p>In that case, the proximal operator of TV does not have an exact solution and we use an iterative
algorithm to solve:</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau \mathrm{TV}}(b) := \underset{u}{\mathrm{argmin}} \frac{1}{2\tau}\|u - b\|^{2} + \mathrm{TV}(u)\]</div>
<p>The algorithm used for the proximal operator of TV is the Fast Gradient Projection algorithm (or FISTA)
applied to the _dual <a href="#id53"><span class="problematic" id="id54">problem_</span></a> of the above problem, see <span id="id16">[<a class="reference internal" href="#id43" title="Amir Beck and Marc Teboulle. A fast iterative shrinkage-thresholding algorithm for linear inverse problems. SIAM Journal on Imaging Sciences, 2(1):183-202, 2009. URL: https://doi.org/10.1137/080716542, arXiv:https://doi.org/10.1137/080716542, doi:10.1137/080716542.">1</a>]</span>, <span id="id17">[<a class="reference internal" href="#id42" title="Amir Beck and Marc Teboulle. Fast gradient-based algorithms for constrained total variation image denoising and deblurring problems. IEEE Transactions on Image Processing, 18(11):2419-2434, 2009. doi:10.1109/TIP.2009.2028250.">2</a>]</span>, <span id="id18">[<a class="reference internal" href="#id46" title="Mingqiang Zhu, Stephen J. Wright, and Tony F. Chan. Duality-based algorithms for total-variation-regularized image restoration. Computational Optimization and Applications, 47(3):377-400, Nov 2010. URL: https://doi.org/10.1007/s10589-008-9225-2, doi:10.1007/s10589-008-9225-2.">11</a>]</span>.</p>
<p>See also “Multicontrast MRI Reconstruction with Structure-Guided Total Variation”, Ehrhardt, Betcke, 2016.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>max_iteration</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, default = 5) – Maximum number of iterations for the FGP algorithm to solve to solve the dual problem
of the Total Variation Denoising problem (ROF). If warm_start=False, this should be around 100,
or larger, with a set tolerance.</p></li>
<li><p><strong>tolerance</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, default = None) – <p>Stopping criterion for the FGP algorithm used to to solve the dual problem
of the Total Variation Denoising problem (ROF). If the difference between iterates in the FGP algorithm is less than the tolerance
the iterations end before the max_iteration number.</p>
<div class="math notranslate nohighlight">
\[\|x^{k+1} - x^{k}\|_{2} &lt; \mathrm{tolerance}\]</div>
</p></li>
<li><p><strong>correlation</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>, default = <cite>Space</cite>) – Correlation between <cite>Space</cite> and/or <cite>SpaceChannels</cite> for the <a class="reference internal" href="#cil.optimisation.operators.GradientOperator" title="cil.optimisation.operators.GradientOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientOperator</span></code></a>.</p></li>
<li><p><strong>backend</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>, default = <cite>c</cite>) – Backend to compute the <a class="reference internal" href="#cil.optimisation.operators.GradientOperator" title="cil.optimisation.operators.GradientOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientOperator</span></code></a></p></li>
<li><p><strong>lower</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">'float</span></code>, default = None) – A constraint is enforced using the <a class="reference internal" href="#cil.optimisation.functions.IndicatorBox" title="cil.optimisation.functions.IndicatorBox"><code class="xref py py-class docutils literal notranslate"><span class="pre">IndicatorBox</span></code></a> function, e.g., <code class="code docutils literal notranslate"><span class="pre">IndicatorBox(lower,</span> <span class="pre">upper)</span></code>.</p></li>
<li><p><strong>upper</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">'float</span></code>, default = None) – A constraint is enforced using the <a class="reference internal" href="#cil.optimisation.functions.IndicatorBox" title="cil.optimisation.functions.IndicatorBox"><code class="xref py py-class docutils literal notranslate"><span class="pre">IndicatorBox</span></code></a> function, e.g., <code class="code docutils literal notranslate"><span class="pre">IndicatorBox(lower,</span> <span class="pre">upper)</span></code>.</p></li>
<li><p><strong>isotropic</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">boolean</span></code>, default = True) – <p>Use either isotropic or anisotropic definition of TV.</p>
<div class="math notranslate nohighlight">
\[|x|_{2} = \sqrt{x_{1}^{2} + x_{2}^{2}},\, (\mbox{isotropic})\]</div>
<div class="math notranslate nohighlight">
\[|x|_{1} = |x_{1}| + |x_{2}|\, (\mbox{anisotropic})\]</div>
</p></li>
<li><p><strong>split</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">boolean</span></code>, default = False) – Splits the Gradient into spatial gradient and spectral or temporal gradient for multichannel data.</p></li>
<li><p><strong>info</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">boolean</span></code>, default = False) – Information is printed for the stopping criterion of the FGP algorithm used to solve the dual problem
of the Total Variation Denoising problem (ROF).</p></li>
<li><p><strong>strong_convexity_constant</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, default = 0) – <p>A strongly convex term weighted by the <code class="code docutils literal notranslate"><span class="pre">strong_convexity_constant</span></code> (<span class="math notranslate nohighlight">\(\gamma\)</span>) parameter is added to the Total variation.
Now the <code class="code docutils literal notranslate"><span class="pre">TotalVariation</span></code> function is <span class="math notranslate nohighlight">\(\gamma\)</span> - strongly convex and the proximal operator is</p>
<div class="math notranslate nohighlight">
\[\underset{u}{\mathrm{argmin}} \frac{1}{2\tau}\|u - b\|^{2} + \mathrm{TV}(u) + \frac{\gamma}{2}\|u\|^{2} \Leftrightarrow\]</div>
<div class="math notranslate nohighlight">
\[\underset{u}{\mathrm{argmin}} \frac{1}{2\frac{\tau}{1+\gamma\tau}}\|u - \frac{b}{1+\gamma\tau}\|^{2} + \mathrm{TV}(u)\]</div>
</p></li>
<li><p><strong>warm_start</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">boolean</span></code>, default = True) – If set to true, the FGP algorithm used to solve the dual problem of the Total Variation Denoising problem (ROF) is initiated by the final value from the previous iteration and not at zero.
This allows the max_iteration value to be reduced to 5-10 iterations.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>With warm_start set to the default, True, the TV function will keep in memory the range of the gradient of the image to be denoised, i.e. N times the dimensionality of the image. This increases the memory requirements.
However, during the evaluation of <cite>proximal</cite> the memory requirements will be unchanged as the same amount of memory will need to be allocated and deallocated.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the case where the Total variation becomes a <span class="math notranslate nohighlight">\(\gamma\)</span> - strongly convex function, i.e.,</p>
<div class="math notranslate nohighlight">
\[\mathrm{TV}(u) + \frac{\gamma}{2}\|u\|^{2}\]</div>
<p><span class="math notranslate nohighlight">\(\gamma\)</span> should be relatively small, so as the second term above will not act as an additional regulariser.
For more information, see <span id="id19">[<a class="reference internal" href="#id44" title="Julian Rasch and Antonin Chambolle. Inexact first-order primal–dual algorithms. Computational Optimization and Applications, 76(2):381-430, Jun 2020. URL: https://doi.org/10.1007/s10589-020-00186-y, doi:10.1007/s10589-020-00186-y.">10</a>]</span>, <span id="id20">[<a class="reference internal" href="#id38" title="Antonin Chambolle and Thomas Pock. A first-order primal-dual algorithm for convex problems with applications to imaging. Journal of Mathematical Imaging and Vision, 40(1):120-145, May 2011. URL: https://doi.org/10.1007/s10851-010-0251-1, doi:10.1007/s10851-010-0251-1.">3</a>]</span>.</p>
</div>
<p class="rubric">Examples</p>
<div class="math notranslate nohighlight">
\[\underset{u}{\mathrm{argmin}} \frac{1}{2}\|u - b\|^{2} + \alpha\|\nabla u\|_{2,1}\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TV</span> <span class="o">=</span> <span class="n">TotalVariation</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">TV</span><span class="o">.</span><span class="n">proximal</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="math notranslate nohighlight">
\[\underset{u}{\mathrm{argmin}} \frac{1}{2}\|u - b\|^{2} + \alpha\|\nabla u\|_{1,1} + \mathbb{I}_{C}(u)\]</div>
<p>where <span class="math notranslate nohighlight">\(C = \{1.0\leq u\leq 2.0\}\)</span>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TV</span> <span class="o">=</span> <span class="n">TotalVariation</span><span class="p">(</span><span class="n">isotropic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">TV</span><span class="o">.</span><span class="n">proximal</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="math notranslate nohighlight">
\[\underset{u}{\mathrm{argmin}} \frac{1}{2}\|u - b\|^{2} + (\alpha\|\nabla u\|_{2,1} + \frac{\gamma}{2}\|u\|^{2})\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gamma</span> <span class="o">=</span> <span class="mf">1e-3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TV</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">TotalVariation</span><span class="p">(</span><span class="n">isotropic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">strong_convexity_constant</span><span class="o">=</span><span class="n">gamma</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">TV</span><span class="o">.</span><span class="n">proximal</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.TotalVariation.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/TotalVariation/#TotalVariation.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the TotalVariation function at <code class="code docutils literal notranslate"><span class="pre">x</span></code> .</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.TotalVariation.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/TotalVariation/#TotalVariation.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of convex conjugate of the TotalVariation function at <code class="code docutils literal notranslate"><span class="pre">x</span></code> .</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.TotalVariation.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.TotalVariation.calculate_Lipschitz">
<span class="sig-name descname"><span class="pre">calculate_Lipschitz</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/TotalVariation/#TotalVariation.calculate_Lipschitz"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.calculate_Lipschitz" title="Permalink to this definition">#</a></dt>
<dd><p>Default value for the Lipschitz constant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.TotalVariation.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.centered_at" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.TotalVariation.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of function <span class="math notranslate nohighlight">\(F\)</span>  evaluated at <span class="math notranslate nohighlight">\(x\)</span>, if it is differentiable</p>
<div class="math notranslate nohighlight">
\[F'(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the value of the gradient of the function at x or <cite>None</cite> if <cite>out</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.TotalVariation.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.proximal_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p></li>
<li><p><strong>tau</strong> (<em>scalar</em>) – </p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.TotalVariation.gradient_operator">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">gradient_operator</span></span><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.gradient_operator" title="Permalink to this definition">#</a></dt>
<dd><p>GradientOperator is created if it is not instantiated yet. The domain of the <cite>_gradient</cite>,
is created in the <cite>__call__</cite> and <cite>proximal</cite> methods.</p>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="utilities">
<h2>Utilities<a class="headerlink" href="#utilities" title="Permalink to this headline">#</a></h2>
<p>Contains utilities for the CIL optimisation framework.</p>
<section id="samplers">
<h3>Samplers<a class="headerlink" href="#samplers" title="Permalink to this headline">#</a></h3>
<p>Here, we define samplers that select from a list of indices {0, 1, …, N-1} either randomly or by some deterministic pattern.
The <cite>cil.optimisation.utilities.sampler</cite> class defines a function next() which gives the next sample. It also has utility to <cite>get_samples</cite> to access which samples have or will be drawn.</p>
<p>For ease of use we provide the following static methods in <cite>cil.optimisation.utilities.sampler</cite> that allow you to configure your sampler object rather than initialising the classes directly:</p>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.utilities.Sampler.from_function">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Sampler.</span></span><span class="sig-name descname"><span class="pre">from_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler.from_function"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.Sampler.from_function" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>Instantiate a sampler that wraps a function for index selection.</p>
<dl class="simple">
<dt>num_indices: int</dt><dd><p>The sampler will select from a range of indices 0 to num_indices.</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>function<span class="classifier">callable</span></dt><dd><p>A deterministic function that takes an integer as an argument, representing the iteration number, and returns an integer between 0 and num_indices. The function signature should be function(iteration_number: int) -&gt; int</p>
<dl class="simple">
<dt>prob_weights: list of floats of length num_indices that sum to 1. Default is [1 / num_indices] * num_indices</dt><dd><p>Consider that the sampler is incremented a large number of times this argument holds the expected number of times each index would be outputted,  normalised to 1.</p>
</dd>
</dl>
<dl class="simple">
<dt>Sampler</dt><dd><p>An instance of the Sampler class which samples from a function.</p>
</dd>
</dl>
<p>This example creates a sampler that always outputs 2.  The probability weights are passed to the sampler as they are not uniform.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">num_indices</span><span class="o">=</span><span class="mi">3</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">my_sampling_function</span><span class="p">(</span><span class="n">iteration_number</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">from_function</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="n">num_indices</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">my_sampling_function</span><span class="p">,</span> <span class="n">prob_weights</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">12</span><span class="p">)))</span>
<span class="go">[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]</span>
</pre></div>
</div>
<p>This example creates a sampler that outputs sequential indices, starting from 1.  The probability weights are not passed to the sampler as they are uniform.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">num_indices</span><span class="o">=</span><span class="mi">10</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">my_sampling_function</span><span class="p">(</span><span class="n">iteration_number</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="p">(</span><span class="n">iteration_number</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">10</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">from_function</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="n">num_indices</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">my_sampling_function</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">25</span><span class="p">)))</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5]</span>
</pre></div>
</div>
<p>This example creates a sampler that samples in order from a custom list. The num_indices  is 6, although note that the index 5 is never output by the sampler. The number of indices must be at least one greater than any of the elements in the custom_list.
The probability weights are passed to the sampler as they are not uniform.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">custom_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">num_indices</span> <span class="o">=</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">my_sampling_function</span><span class="p">(</span><span class="n">iteration_number</span><span class="p">,</span> <span class="n">custom_list</span><span class="o">=</span><span class="n">custom_list</span><span class="p">]):</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="k">return</span><span class="p">(</span><span class="n">custom_list</span><span class="p">[</span><span class="n">iteration_number</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">custom_list</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">from_function</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="n">num_indices</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">my_sampling_function</span><span class="p">,</span> <span class="n">prob_weights</span><span class="o">=</span><span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">25</span><span class="p">)))</span>
<span class="go">[0, 0, 0, 0, 0, 0, 3, 2, 1, 4, 0, 0, 0, 0, 0, 0, 3, 2, 1, 4, 0, 0, 0, 0, 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="p">)</span>
<span class="go">Sampler that wraps a function that takes an iteration number and selects from a list of indices {0, 1, …, N-1}, where N is the number of indices.</span>
<span class="go">Type : from_function</span>
<span class="go">Current iteration number : 0</span>
<span class="go">number of indices : 6</span>
<span class="go">Probability weights : [0.6, 0.1, 0.1, 0.1, 0.1, 0.0]</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.utilities.Sampler.sequential">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Sampler.</span></span><span class="sig-name descname"><span class="pre">sequential</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_indices</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler.sequential"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.Sampler.sequential" title="Permalink to this definition">#</a></dt>
<dd><p>Instantiates a sampler that outputs sequential indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>num_indices</strong> (<em>int</em>) – The sampler will select from a range of indices 0 to num_indices.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An instance of the Sampler class that will generate indices sequentially.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#cil.optimisation.utilities.Sampler" title="cil.optimisation.utilities.Sampler">Sampler</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">sequential</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">sampler</span><span class="p">))</span>
<span class="go">0</span>
<span class="go">[0 1 2 3 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">next</span><span class="p">())</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.utilities.Sampler.staggered">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Sampler.</span></span><span class="sig-name descname"><span class="pre">staggered</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stride</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler.staggered"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.Sampler.staggered" title="Permalink to this definition">#</a></dt>
<dd><p>Instantiates a sampler which outputs in a staggered order.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_indices</strong> (<em>int</em>) – The sampler will select from a range of indices 0 to num_indices.</p></li>
<li><p><strong>stride</strong> (<em>int</em>) – The stride between returned indices. The stride should be less than the num_indices.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An instance of the Sampler class that will generate indices in a staggered pattern.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#cil.optimisation.utilities.Sampler" title="cil.optimisation.utilities.Sampler">Sampler</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">staggered</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="mi">21</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">sampler</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">next</span><span class="p">())</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">[ 0  4  8 12 16]</span>
</pre></div>
</div>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">staggered</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="mi">17</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">sampler</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">next</span><span class="p">())</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">[ 0  8  16 1 9 2 10 3 11 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.utilities.Sampler.herman_meyer">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Sampler.</span></span><span class="sig-name descname"><span class="pre">herman_meyer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_indices</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler.herman_meyer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.Sampler.herman_meyer" title="Permalink to this definition">#</a></dt>
<dd><p>Instantiates a sampler which outputs in a Herman Meyer order.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_indices</strong> (<em>int</em>) – The sampler will select from a range of indices 0 to num_indices. For Herman-Meyer sampling this number should not be prime.</p></li>
<li><p><strong>Reference</strong> – </p></li>
<li><p><strong>----------</strong> – </p></li>
<li><p><strong>in</strong> (<em>The sampling method was introduced</em>) – </p></li>
<li><p><strong>I</strong> (<em>Singh</em>) – </p></li>
<li><p><strong>MIC</strong> (<em>et al. Deep Image Prior PET Reconstruction using a SIRF-Based Objective - IEEE</em>) – </p></li>
<li><p><strong>https</strong> (<em>NSS &amp; RTSD 2022.</em>) – </p></li>
<li><p><strong>in</strong> – </p></li>
<li><p><strong>GT</strong> (<em>Herman</em>) – </p></li>
<li><p><strong>doi</strong> (<em>Meyer LB. Algebraic reconstruction techniques can be made computationally efficient. IEEE Trans Med Imaging.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An instance of the Sampler class which outputs in a Herman Meyer order.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#cil.optimisation.utilities.Sampler" title="cil.optimisation.utilities.Sampler">Sampler</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span><span class="o">=</span><span class="n">Sampler</span><span class="o">.</span><span class="n">herman_meyer</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
<span class="go">[ 0  6  3  9  1  7  4 10  2  8  5 11  0  6  3  9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.utilities.Sampler.random_with_replacement">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Sampler.</span></span><span class="sig-name descname"><span class="pre">random_with_replacement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler.random_with_replacement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.Sampler.random_with_replacement" title="Permalink to this definition">#</a></dt>
<dd><p>Instantiates a sampler which outputs an index between 0 - num_indices with a given probability.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_indices</strong> (<em>int</em>) – The sampler will select from a range of indices 0 to num_indices</p></li>
<li><p><strong>prob</strong> (<em>list of floats</em><em>, </em><em>optional</em>) – The probability for each index to be selected by the ‘next’ operation. If not provided, the indices will be sampled uniformly. The list should have a length equal to num_indices, and the values should sum to 1</p></li>
<li><p><strong>seed</strong> (<em>int</em><em>, </em><em>optional</em>) – Used to initialise the random number generator where repeatability is required.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An instance of the <cite>RandomSampler</cite> class that will generate indices randomly with replacement</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>RandomSampler</cite></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">random_with_replacement</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">[3 4 0 0 2 3 3 2 2 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">sampler</span><span class="p">))</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">next</span><span class="p">())</span>
<span class="go">4</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">random_with_replacement</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="p">[</span><span class="mf">0.7</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">[0 1 3 0 0 3 0 0 0 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.utilities.Sampler.random_without_replacement">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Sampler.</span></span><span class="sig-name descname"><span class="pre">random_without_replacement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler.random_without_replacement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.Sampler.random_without_replacement" title="Permalink to this definition">#</a></dt>
<dd><p>Instantiates a sampler which outputs an index between 0 - num_indices. Once sampled the index will not be sampled again until all indices have been returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_indices</strong> (<em>int</em>) – The sampler will select from a range of indices 0 to num_indices.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em>, </em><em>optional</em>) – Used to initialise the random number generator where repeatability is required.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An instance of the <cite>RandomSampler</cite> class that will generate indices randomly without replacement</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>RandomSampler</cite></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span><span class="o">=</span><span class="n">Sampler</span><span class="o">.</span><span class="n">randomWithoutReplacement</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
<span class="go">[6 2 1 0 4 3 5 1 0 4 2 5 6 3 3 2]</span>
</pre></div>
</div>
</dd></dl>

<p>They will all instantiate a Sampler defined in the following class:</p>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.utilities.Sampler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.utilities.</span></span><span class="sig-name descname"><span class="pre">Sampler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.Sampler" title="Permalink to this definition">#</a></dt>
<dd><p>Initialises a sampler that returns and then increments indices from a sequence defined by a function.</p>
<p>Static methods to easily configure several samplers are provided, such as sequential, staggered, Herman-Mayer, random with and without replacement.</p>
<p>Custom deterministic samplers can be created by using the <cite>from_function</cite> static method or by subclassing this sampler class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>Callable</em><em>[</em><em>[</em><em>int</em><em>]</em><em>, </em><em>int</em><em>]</em>) – A function that takes an integer iteration number and returns an integer between 0 and num_indices.</p></li>
<li><p><strong>num_indices</strong> (<em>int</em>) – The sampler will select from a range of indices 0 to num_indices.</p></li>
<li><p><strong>sampling_type</strong> (<em>str</em><em>, </em><em>optional</em><em>,  </em><em>default = None</em>) – The sampling type used. This is recorded for reference and printed when <cite>print</cite> is called.</p></li>
<li><p><strong>prob_weights</strong> (<em>list of floats of length num_indices that sum to 1.  Default is</em><em> [</em><em>1 / num_indices</em><em>] </em><em>* num_indices</em>) – Consider that the sampler is incremented a large number of times this argument holds the expected number of times each index would be outputted,  normalised to 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An instance of the Sampler class representing the desired configuration.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#cil.optimisation.utilities.Sampler" title="cil.optimisation.utilities.Sampler">Sampler</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">random_with_replacement</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="go">[3 4 0 0 2 3 3 2 2 1 1 4 4 3 0 2 4 4 2 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">sampler</span><span class="p">))</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">next</span><span class="p">())</span>
<span class="go">4</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">staggered</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="mi">21</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">sampler</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">next</span><span class="p">())</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">[ 0  4  8 12 16]</span>
</pre></div>
</div>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">sequential</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">sampler</span><span class="p">))</span>
<span class="go">0</span>
<span class="go">[0 1 2 3 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">next</span><span class="p">())</span>
<span class="go">1</span>
</pre></div>
</div>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">herman_meyer</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
<span class="go">[ 0  6  3  9  1  7  4 10  2  8  5 11  0  6  3  9]</span>
</pre></div>
</div>
<p class="rubric">Example</p>
<p>This example creates a sampler that outputs sequential indices, starting from 1.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">num_indices</span><span class="o">=</span><span class="mi">10</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">my_sampling_function</span><span class="p">(</span><span class="n">iteration_number</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="p">(</span><span class="n">iteration_number</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">10</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">from_function</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="n">num_indices</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">my_sampling_function</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">25</span><span class="p">)))</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The optimal choice of sampler depends on the data and the number of calls to the sampler.  Note that a low number of calls to a random sampler won’t give an even distribution.
For a small number of samples (e.g. <cite>&lt;5*num_indices</cite>) the user may wish to consider another sampling method e.g. random without replacement, which, when calling <cite>num_indices</cite> samples is guaranteed to draw each index exactly once.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.utilities.Sampler.next">
<span class="sig-name descname"><span class="pre">next</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler.next"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.Sampler.next" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a sample from the list of indices <a href="#id21"><span class="problematic" id="id22">`</span></a>{0, 1, …, N-1}, where N is the number of indices and increments the sampler.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.utilities.Sampler.get_samples">
<span class="sig-name descname"><span class="pre">get_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_samples</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler.get_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.Sampler.get_samples" title="Permalink to this definition">#</a></dt>
<dd><p>Generates a list of the first num_samples output by the sampler. Calling this does not increment the sampler index or affect the behaviour of the sampler .</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>num_samples</strong> (<em>int</em>) – The number of samples to return.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The first <a href="#id23"><span class="problematic" id="id24">`</span></a>num_samples” output by the sampler.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>List</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id0">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sequential</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_indices</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler.sequential"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id0" title="Permalink to this definition">#</a></dt>
<dd><p>Instantiates a sampler that outputs sequential indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>num_indices</strong> (<em>int</em>) – The sampler will select from a range of indices 0 to num_indices.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An instance of the Sampler class that will generate indices sequentially.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#cil.optimisation.utilities.Sampler" title="cil.optimisation.utilities.Sampler">Sampler</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">sequential</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">sampler</span><span class="p">))</span>
<span class="go">0</span>
<span class="go">[0 1 2 3 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">next</span><span class="p">())</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id25">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">staggered</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stride</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler.staggered"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id25" title="Permalink to this definition">#</a></dt>
<dd><p>Instantiates a sampler which outputs in a staggered order.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_indices</strong> (<em>int</em>) – The sampler will select from a range of indices 0 to num_indices.</p></li>
<li><p><strong>stride</strong> (<em>int</em>) – The stride between returned indices. The stride should be less than the num_indices.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An instance of the Sampler class that will generate indices in a staggered pattern.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#cil.optimisation.utilities.Sampler" title="cil.optimisation.utilities.Sampler">Sampler</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">staggered</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="mi">21</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">sampler</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">next</span><span class="p">())</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">[ 0  4  8 12 16]</span>
</pre></div>
</div>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">staggered</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="mi">17</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">sampler</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">next</span><span class="p">())</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">[ 0  8  16 1 9 2 10 3 11 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id26">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">random_with_replacement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler.random_with_replacement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id26" title="Permalink to this definition">#</a></dt>
<dd><p>Instantiates a sampler which outputs an index between 0 - num_indices with a given probability.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_indices</strong> (<em>int</em>) – The sampler will select from a range of indices 0 to num_indices</p></li>
<li><p><strong>prob</strong> (<em>list of floats</em><em>, </em><em>optional</em>) – The probability for each index to be selected by the ‘next’ operation. If not provided, the indices will be sampled uniformly. The list should have a length equal to num_indices, and the values should sum to 1</p></li>
<li><p><strong>seed</strong> (<em>int</em><em>, </em><em>optional</em>) – Used to initialise the random number generator where repeatability is required.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An instance of the <cite>RandomSampler</cite> class that will generate indices randomly with replacement</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>RandomSampler</cite></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">random_with_replacement</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">[3 4 0 0 2 3 3 2 2 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">sampler</span><span class="p">))</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">next</span><span class="p">())</span>
<span class="go">4</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">random_with_replacement</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="p">[</span><span class="mf">0.7</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">[0 1 3 0 0 3 0 0 0 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id27">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">random_without_replacement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler.random_without_replacement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id27" title="Permalink to this definition">#</a></dt>
<dd><p>Instantiates a sampler which outputs an index between 0 - num_indices. Once sampled the index will not be sampled again until all indices have been returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_indices</strong> (<em>int</em>) – The sampler will select from a range of indices 0 to num_indices.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em>, </em><em>optional</em>) – Used to initialise the random number generator where repeatability is required.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An instance of the <cite>RandomSampler</cite> class that will generate indices randomly without replacement</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>RandomSampler</cite></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span><span class="o">=</span><span class="n">Sampler</span><span class="o">.</span><span class="n">randomWithoutReplacement</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
<span class="go">[6 2 1 0 4 3 5 1 0 4 2 5 6 3 3 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id28">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler.from_function"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id28" title="Permalink to this definition">#</a></dt>
<dd><blockquote>
<div><p>Instantiate a sampler that wraps a function for index selection.</p>
<dl class="simple">
<dt>num_indices: int</dt><dd><p>The sampler will select from a range of indices 0 to num_indices.</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>function<span class="classifier">callable</span></dt><dd><p>A deterministic function that takes an integer as an argument, representing the iteration number, and returns an integer between 0 and num_indices. The function signature should be function(iteration_number: int) -&gt; int</p>
<dl class="simple">
<dt>prob_weights: list of floats of length num_indices that sum to 1. Default is [1 / num_indices] * num_indices</dt><dd><p>Consider that the sampler is incremented a large number of times this argument holds the expected number of times each index would be outputted,  normalised to 1.</p>
</dd>
</dl>
<dl class="simple">
<dt>Sampler</dt><dd><p>An instance of the Sampler class which samples from a function.</p>
</dd>
</dl>
<p>This example creates a sampler that always outputs 2.  The probability weights are passed to the sampler as they are not uniform.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">num_indices</span><span class="o">=</span><span class="mi">3</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">my_sampling_function</span><span class="p">(</span><span class="n">iteration_number</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">from_function</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="n">num_indices</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">my_sampling_function</span><span class="p">,</span> <span class="n">prob_weights</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">12</span><span class="p">)))</span>
<span class="go">[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]</span>
</pre></div>
</div>
<p>This example creates a sampler that outputs sequential indices, starting from 1.  The probability weights are not passed to the sampler as they are uniform.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">num_indices</span><span class="o">=</span><span class="mi">10</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">my_sampling_function</span><span class="p">(</span><span class="n">iteration_number</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="p">(</span><span class="n">iteration_number</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">10</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">from_function</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="n">num_indices</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">my_sampling_function</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">25</span><span class="p">)))</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5]</span>
</pre></div>
</div>
<p>This example creates a sampler that samples in order from a custom list. The num_indices  is 6, although note that the index 5 is never output by the sampler. The number of indices must be at least one greater than any of the elements in the custom_list.
The probability weights are passed to the sampler as they are not uniform.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">custom_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">num_indices</span> <span class="o">=</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">my_sampling_function</span><span class="p">(</span><span class="n">iteration_number</span><span class="p">,</span> <span class="n">custom_list</span><span class="o">=</span><span class="n">custom_list</span><span class="p">]):</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="k">return</span><span class="p">(</span><span class="n">custom_list</span><span class="p">[</span><span class="n">iteration_number</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">custom_list</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">from_function</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="n">num_indices</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">my_sampling_function</span><span class="p">,</span> <span class="n">prob_weights</span><span class="o">=</span><span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">25</span><span class="p">)))</span>
<span class="go">[0, 0, 0, 0, 0, 0, 3, 2, 1, 4, 0, 0, 0, 0, 0, 0, 3, 2, 1, 4, 0, 0, 0, 0, 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="p">)</span>
<span class="go">Sampler that wraps a function that takes an iteration number and selects from a list of indices {0, 1, …, N-1}, where N is the number of indices.</span>
<span class="go">Type : from_function</span>
<span class="go">Current iteration number : 0</span>
<span class="go">number of indices : 6</span>
<span class="go">Probability weights : [0.6, 0.1, 0.1, 0.1, 0.1, 0.0]</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id29">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">herman_meyer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_indices</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler.herman_meyer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id29" title="Permalink to this definition">#</a></dt>
<dd><p>Instantiates a sampler which outputs in a Herman Meyer order.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_indices</strong> (<em>int</em>) – The sampler will select from a range of indices 0 to num_indices. For Herman-Meyer sampling this number should not be prime.</p></li>
<li><p><strong>Reference</strong> – </p></li>
<li><p><strong>----------</strong> – </p></li>
<li><p><strong>in</strong> (<em>The sampling method was introduced</em>) – </p></li>
<li><p><strong>I</strong> (<em>Singh</em>) – </p></li>
<li><p><strong>MIC</strong> (<em>et al. Deep Image Prior PET Reconstruction using a SIRF-Based Objective - IEEE</em>) – </p></li>
<li><p><strong>https</strong> (<em>NSS &amp; RTSD 2022.</em>) – </p></li>
<li><p><strong>in</strong> – </p></li>
<li><p><strong>GT</strong> (<em>Herman</em>) – </p></li>
<li><p><strong>doi</strong> (<em>Meyer LB. Algebraic reconstruction techniques can be made computationally efficient. IEEE Trans Med Imaging.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An instance of the Sampler class which outputs in a Herman Meyer order.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#cil.optimisation.utilities.Sampler" title="cil.optimisation.utilities.Sampler">Sampler</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span><span class="o">=</span><span class="n">Sampler</span><span class="o">.</span><span class="n">herman_meyer</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
<span class="go">[ 0  6  3  9  1  7  4 10  2  8  5 11  0  6  3  9]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<p>In addition, we provide a random sampling class which is a child class of  <cite>cil.optimisation.utilities.sampler</cite> and provides options for sampling with and without replacement:</p>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.utilities.SamplerRandom">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.utilities.</span></span><span class="sig-name descname"><span class="pre">SamplerRandom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'random_with_replacement'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#SamplerRandom"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.SamplerRandom" title="Permalink to this definition">#</a></dt>
<dd><p>The user is recommended to not instantiate this class  directly but instead use one of the static methods  in the parent Sampler class that will return instances of different samplers.</p>
<p>This class produces Samplers that output random samples with and without replacement from the set {0, 1, …, N-1} where N=num_indices.</p>
<p>Custom random samplers can be created by subclassing this sampler class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_indices</strong> (<em>int</em>) – The sampler will select from a range of indices 0 to num_indices.</p></li>
<li><p><strong>sampling_type</strong> (<em>str</em><em>, </em><em>optional</em><em>,  </em><em>default = 'random_with_replacement&quot;</em>) – The sampling type used. This is recorded for reference and printed when <cite>print</cite> is called.</p></li>
<li><p><strong>prob_weights</strong> (<em>list of floats of length num_indices that sum to 1.  Default is</em><em> [</em><em>1 / num_indices</em><em>] </em><em>* num_indices</em>) – Consider that the sampler is incremented a large number of times this argument holds the expected number of times each index would be outputted,  normalised to 1.</p></li>
<li><p><strong>replace</strong> (<em>bool</em><em>, </em><em>default is True</em>) – If True, sample with replace, otherwise sample without replacement</p></li>
<li><p><strong>seed</strong> (<em>int</em><em>, </em><em>optional</em>) – Used to initialise the random number generator where repeatability is required.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An instance of the Sampler class representing the desired configuration.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#cil.optimisation.utilities.Sampler" title="cil.optimisation.utilities.Sampler">Sampler</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">random_with_replacement</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="go">[3 4 0 0 2 3 3 2 2 1 1 4 4 3 0 2 4 4 2 4]</span>
</pre></div>
</div>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span><span class="o">=</span><span class="n">Sampler</span><span class="o">.</span><span class="n">randomWithoutReplacement</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
<span class="go">[6 2 1 0 4 3 5 1 0 4 2 5 6 3 3 2]</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.utilities.SamplerRandom.get_samples">
<span class="sig-name descname"><span class="pre">get_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_samples</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#SamplerRandom.get_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.SamplerRandom.get_samples" title="Permalink to this definition">#</a></dt>
<dd><p>Generates a list of the first num_samples output by the sampler. Calling this does not increment the sampler index or affect the behaviour of the sampler .</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>num_samples</strong> (<em>int</em>) – The number of samples to return.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The first <cite>num_samples</cite> produced by the sampler</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>
</section>
<section id="block-framework">
<h1>Block Framework<a class="headerlink" href="#block-framework" title="Permalink to this headline">#</a></h1>
<p>To be able to express more advanced optimisation problems we developed the
<a class="reference internal" href="#block-framework">Block Framework</a>, which provides a generic strategy to treat variational
problems in the following form:</p>
<div class="math notranslate nohighlight">
\[\min \text{Regulariser} + \text{Fidelity}\]</div>
<p>The block framework consists of:</p>
<ul class="simple">
<li><p><a class="reference external" href="framework.html#cil.framework.BlockDataContainer">BlockDataContainer</a></p></li>
<li><p><a class="reference external" href="optimisation.html#cil.optimisation.functions.BlockFunction">BlockFunction</a></p></li>
<li><p><a class="reference external" href="optimisation.html#cil.optimisation.operators.BlockOperators">BlockOperator</a></p></li>
</ul>
<p>The block framework allows writing more advanced <a href="#id55"><span class="problematic" id="id56">`optimisation problems`_</span></a>. Consider the typical
<a class="reference external" href="https://en.wikipedia.org/wiki/Tikhonov_regularization">Tikhonov regularisation</a>:</p>
<div class="math notranslate nohighlight">
\[\underset{u}{\mathrm{argmin}}\begin{Vmatrix}A u - b \end{Vmatrix}^2_2 + \alpha^2\|Lu\|^2_2\]</div>
<p>where,</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(A\)</span> is the projection operator</p></li>
<li><p><span class="math notranslate nohighlight">\(b\)</span> is the acquired data</p></li>
<li><p><span class="math notranslate nohighlight">\(u\)</span> is the unknown image to be solved for</p></li>
<li><p><span class="math notranslate nohighlight">\(\alpha\)</span> is the regularisation parameter</p></li>
<li><p><span class="math notranslate nohighlight">\(L\)</span> is a regularisation operator</p></li>
</ul>
<p>The first term measures the fidelity of the solution to the data. The second term measures the
fidelity to the prior knowledge we have imposed on the system, operator <span class="math notranslate nohighlight">\(L\)</span>.</p>
<p>This can be re-written equivalently in the block matrix form:</p>
<div class="math notranslate nohighlight">
\[\underset{u}{\mathrm{argmin}}\begin{Vmatrix}\binom{A}{\alpha L} u - \binom{b}{0}\end{Vmatrix}^2_2\]</div>
<p>With the definitions:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\tilde{A} = \binom{A}{\alpha L}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\tilde{b} = \binom{b}{0}\)</span></p></li>
</ul>
<p>this can now be recognised as a least squares problem which can be solved by any algorithm in the <code class="code docutils literal notranslate"><span class="pre">cil.optimisation</span></code>
which can solve least squares problem, e.g. CGLS.</p>
<div class="math notranslate nohighlight">
\[\underset{u}{\mathrm{argmin}}\begin{Vmatrix}\tilde{A} u - \tilde{b}\end{Vmatrix}^2_2\]</div>
<p>To be able to express our optimisation problems in the matrix form above, we developed the so-called,
Block Framework comprising 4 main actors: <code class="code docutils literal notranslate"><span class="pre">BlockGeometry</span></code>, <code class="code docutils literal notranslate"><span class="pre">BlockDataContainer</span></code>,
<code class="code docutils literal notranslate"><span class="pre">BlockFunction</span></code> and <code class="code docutils literal notranslate"><span class="pre">BlockOperator</span></code>.</p>
<section id="blockdatacontainer">
<h2>BlockDataContainer<a class="headerlink" href="#blockdatacontainer" title="Permalink to this headline">#</a></h2>
<p><a class="reference external" href="framework.html#cil.framework.BlockDataContainer">BlockDataContainer</a> holds <a href="#id57"><span class="problematic" id="id58">`DataContainer`_</span></a> as column vector. It is possible to
do basic algebra between <a class="reference external" href="framework.html#cil.framework.BlockDataContainer">BlockDataContainer</a> s and with numbers, list or numpy arrays.</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}x = [x_{1}, x_{2} ]\in (X_{1}\times X_{2})\\y = [y_{1}, y_{2}, y_{3} ]\in(Y_{1}\times Y_{2} \times Y_{3})\end{aligned}\end{align} \]</div>
<dl class="py class">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.framework.</span></span><span class="sig-name descname"><span class="pre">BlockDataContainer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/BlockDataContainer/#BlockDataContainer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer" title="Permalink to this definition">#</a></dt>
<dd><p>Class to hold DataContainers as column vector</p>
<p>Provides basic algebra between BlockDataContainer’s, DataContainer’s and
subclasses and Numbers</p>
<ol class="arabic simple">
<li><p>algebra between <a href="#id30"><span class="problematic" id="id31">`</span></a>BlockDataContainer`s will be element-wise, only if
the shape of the 2 <a href="#id32"><span class="problematic" id="id33">`</span></a>BlockDataContainer`s is the same, otherwise it
will fail</p></li>
<li><p>algebra between <cite>BlockDataContainer`s and `list</cite> or <cite>numpy array</cite> will
work as long as the number of <cite>rows</cite> and element of the arrays match,
independently on the fact that the <cite>BlockDataContainer</cite> could be nested</p></li>
<li><p>algebra between <cite>BlockDataContainer</cite> and one <cite>DataContainer</cite> is possible.
It will require all the <cite>DataContainers</cite> in the block to be
compatible with the <cite>DataContainer</cite> we want to operate with.</p></li>
<li><p>algebra between <cite>BlockDataContainer</cite> and a <cite>Number</cite> is possible and it
will be done with each element of the <cite>BlockDataContainer</cite> even if nested</p></li>
</ol>
<p>A = [ [B,C] , D]
A * 3 = [ 3 * [B,C] , 3* D] = [ [ 3*B, 3*C]  , 3*D ]</p>
<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.__iter__">
<span class="sig-name descname"><span class="pre">__iter__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/BlockDataContainer/#BlockDataContainer.__iter__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__iter__" title="Permalink to this definition">#</a></dt>
<dd><p>BlockDataContainer is Iterable</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.next">
<span class="sig-name descname"><span class="pre">next</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/BlockDataContainer/#BlockDataContainer.next"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.next" title="Permalink to this definition">#</a></dt>
<dd><p>python2 backwards compatibility</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.is_compatible">
<span class="sig-name descname"><span class="pre">is_compatible</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/BlockDataContainer/#BlockDataContainer.is_compatible"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.is_compatible" title="Permalink to this definition">#</a></dt>
<dd><p>basic check if the size of the 2 objects fit</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/BlockDataContainer/#BlockDataContainer.add"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.add" title="Permalink to this definition">#</a></dt>
<dd><p>Algebra: add method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>other (number, DataContainer or subclasses or BlockDataContainer</p>
</dd>
<dt class="field-even">Param</dt>
<dd class="field-even"><p>out (optional): provides a placehold for the resul.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.subtract">
<span class="sig-name descname"><span class="pre">subtract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/BlockDataContainer/#BlockDataContainer.subtract"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.subtract" title="Permalink to this definition">#</a></dt>
<dd><p>Algebra: subtract method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>other (number, DataContainer or subclasses or BlockDataContainer</p>
</dd>
<dt class="field-even">Param</dt>
<dd class="field-even"><p>out (optional): provides a placeholder for the result.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.multiply">
<span class="sig-name descname"><span class="pre">multiply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/BlockDataContainer/#BlockDataContainer.multiply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.multiply" title="Permalink to this definition">#</a></dt>
<dd><p>Algebra: multiply method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>other (number, DataContainer or subclasses or BlockDataContainer)</p>
</dd>
<dt class="field-even">Param</dt>
<dd class="field-even"><p>out (optional): provides a placeholder for the result.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.divide">
<span class="sig-name descname"><span class="pre">divide</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/BlockDataContainer/#BlockDataContainer.divide"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.divide" title="Permalink to this definition">#</a></dt>
<dd><p>Algebra: divide method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>other (number, DataContainer or subclasses or BlockDataContainer)</p>
</dd>
<dt class="field-even">Param</dt>
<dd class="field-even"><p>out (optional): provides a placeholder for the result.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.power">
<span class="sig-name descname"><span class="pre">power</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/BlockDataContainer/#BlockDataContainer.power"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.power" title="Permalink to this definition">#</a></dt>
<dd><p>Algebra: power method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>other (number, DataContainer or subclasses or BlockDataContainer</p>
</dd>
<dt class="field-even">Param</dt>
<dd class="field-even"><p>out (optional): provides a placeholder for the result.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.maximum">
<span class="sig-name descname"><span class="pre">maximum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/BlockDataContainer/#BlockDataContainer.maximum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.maximum" title="Permalink to this definition">#</a></dt>
<dd><p>Algebra: power method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>other (number, DataContainer or subclasses or BlockDataContainer)</p>
</dd>
<dt class="field-even">Param</dt>
<dd class="field-even"><p>out (optional): provides a placeholder for the result.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.minimum">
<span class="sig-name descname"><span class="pre">minimum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/BlockDataContainer/#BlockDataContainer.minimum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.minimum" title="Permalink to this definition">#</a></dt>
<dd><p>Algebra: power method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>other (number, DataContainer or subclasses or BlockDataContainer)</p>
</dd>
<dt class="field-even">Param</dt>
<dd class="field-even"><p>out (optional): provides a placeholder for the result.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.sapyb">
<span class="sig-name descname"><span class="pre">sapyb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/BlockDataContainer/#BlockDataContainer.sapyb"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.sapyb" title="Permalink to this definition">#</a></dt>
<dd><p>performs axpby element-wise on the BlockDataContainer containers</p>
<p>Does the operation .. math:: a*x+b*y and stores the result in out, where x is self</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – scalar</p></li>
<li><p><strong>b</strong> – scalar</p></li>
<li><p><strong>y</strong> – compatible (Block)DataContainer</p></li>
<li><p><strong>out</strong> – (Block)DataContainer to store the result</p></li>
</ul>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ig</span> <span class="o">=</span> <span class="n">ImageGeometry</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bdc1</span> <span class="o">=</span> <span class="n">BlockDataContainer</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bdc2</span> <span class="o">=</span> <span class="n">BlockDataContainer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">bdc1</span><span class="o">.</span><span class="n">sapyb</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">bdc2</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.axpby">
<span class="sig-name descname"><span class="pre">axpby</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_threads=2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/BlockDataContainer/#BlockDataContainer.axpby"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.axpby" title="Permalink to this definition">#</a></dt>
<dd><p>Deprecated method. Alias of sapyb</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.binary_operations">
<span class="sig-name descname"><span class="pre">binary_operations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/BlockDataContainer/#BlockDataContainer.binary_operations"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.binary_operations" title="Permalink to this definition">#</a></dt>
<dd><p>Algebra: generic method of algebric operation with BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<p>Provides commutativity with DataContainer and subclasses, i.e. this
class’s reverse algebraic methods take precedence w.r.t. direct algebraic
methods of DataContainer and subclasses.</p>
<p>This method is not to be used directly</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.unary_operations">
<span class="sig-name descname"><span class="pre">unary_operations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operation</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/BlockDataContainer/#BlockDataContainer.unary_operations"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.unary_operations" title="Permalink to this definition">#</a></dt>
<dd><p>Unary operation on BlockDataContainer:</p>
<p>generic method of unary operation with BlockDataContainer: abs, sign, sqrt and conjugate</p>
<p>This method is not to be used directly</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/BlockDataContainer/#BlockDataContainer.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.copy" title="Permalink to this definition">#</a></dt>
<dd><p>alias of clone</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/BlockDataContainer/#BlockDataContainer.__radd__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__radd__" title="Permalink to this definition">#</a></dt>
<dd><p>Reverse addition</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/BlockDataContainer/#BlockDataContainer.__rsub__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__rsub__" title="Permalink to this definition">#</a></dt>
<dd><p>Reverse subtraction</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/BlockDataContainer/#BlockDataContainer.__rmul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__rmul__" title="Permalink to this definition">#</a></dt>
<dd><p>Reverse multiplication</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.__rdiv__">
<span class="sig-name descname"><span class="pre">__rdiv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/BlockDataContainer/#BlockDataContainer.__rdiv__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__rdiv__" title="Permalink to this definition">#</a></dt>
<dd><p>Reverse division</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.__rtruediv__">
<span class="sig-name descname"><span class="pre">__rtruediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/BlockDataContainer/#BlockDataContainer.__rtruediv__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__rtruediv__" title="Permalink to this definition">#</a></dt>
<dd><p>Reverse truedivision</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.__rpow__">
<span class="sig-name descname"><span class="pre">__rpow__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/BlockDataContainer/#BlockDataContainer.__rpow__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__rpow__" title="Permalink to this definition">#</a></dt>
<dd><p>Reverse power</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.__iadd__">
<span class="sig-name descname"><span class="pre">__iadd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/BlockDataContainer/#BlockDataContainer.__iadd__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__iadd__" title="Permalink to this definition">#</a></dt>
<dd><p>Inline addition</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.__isub__">
<span class="sig-name descname"><span class="pre">__isub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/BlockDataContainer/#BlockDataContainer.__isub__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__isub__" title="Permalink to this definition">#</a></dt>
<dd><p>Inline subtraction</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.__imul__">
<span class="sig-name descname"><span class="pre">__imul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/BlockDataContainer/#BlockDataContainer.__imul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__imul__" title="Permalink to this definition">#</a></dt>
<dd><p>Inline multiplication</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.__idiv__">
<span class="sig-name descname"><span class="pre">__idiv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/BlockDataContainer/#BlockDataContainer.__idiv__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__idiv__" title="Permalink to this definition">#</a></dt>
<dd><p>Inline division</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.__itruediv__">
<span class="sig-name descname"><span class="pre">__itruediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/BlockDataContainer/#BlockDataContainer.__itruediv__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__itruediv__" title="Permalink to this definition">#</a></dt>
<dd><p>Inline truedivision</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/BlockDataContainer/#BlockDataContainer.__neg__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__neg__" title="Permalink to this definition">#</a></dt>
<dd><p>Return - self</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.__weakref__">
<span class="sig-name descname"><span class="pre">__weakref__</span></span><a class="headerlink" href="#cil.framework.BlockDataContainer.__weakref__" title="Permalink to this definition">#</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

</section>
<section id="block-function">
<h2>Block Function<a class="headerlink" href="#block-function" title="Permalink to this headline">#</a></h2>
<p><a class="reference external" href="optimisation.html#cil.optimisation.functions.BlockFunction">BlockFunction</a> acts on <a class="reference external" href="framework.html#cil.framework.BlockDataContainer">BlockDataContainer</a> as a separable sum function:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}f = [f_1,...,f_n] \newline\\f([x_1,...,x_n]) = f_1(x_1) +  .... + f_n(x_n)\end{aligned}\end{align} \]</div>
</div></blockquote>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}Y = \begin{bmatrix}
y_{1}\\
y_{2}\\
y_{3}\\
\end{bmatrix}, \quad  F  = [ f_{1}, f_{2}, f_{3} ]\end{split}\\F(Y) : = f_{1}(y_{1}) + f_{2}(y_{2}) + f_{3}(y_{3})\end{aligned}\end{align} \]</div>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.BlockFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">BlockFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">functions</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/BlockFunction/#BlockFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction" title="Permalink to this definition">#</a></dt>
<dd><p>BlockFunction represents a <em>separable sum</em> function <span class="math notranslate nohighlight">\(F\)</span> defined as</p>
<div class="math notranslate nohighlight">
\[F:X_{1}\times X_{2}\cdots\times X_{m} \rightarrow (-\infty, \infty]\]</div>
<p>where <span class="math notranslate nohighlight">\(F\)</span> is the separable sum of functions <span class="math notranslate nohighlight">\((f_{i})_{i=1}^{m}\)</span>,</p>
<div class="math notranslate nohighlight">
\[F(x_{1}, x_{2}, \cdots, x_{m}) = \overset{m}{\underset{i=1}{\sum}}f_{i}(x_{i}), \mbox{ with } f_{i}: X_{i} \rightarrow (-\infty, \infty].\]</div>
<p>A nice property (due to it’s separability structure) is that the proximal operator
can be decomposed along the proximal operators of each function <span class="math notranslate nohighlight">\(f_{i}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = ( \mathrm{prox}_{\tau f_{i}}(x_{i}) )_{i=1}^{m}\]</div>
<p>In addition, if <span class="math notranslate nohighlight">\(\tau := (\tau_{1},\dots,\tau_{m})\)</span>, then</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = ( \mathrm{prox}_{\tau_{i} f_{i}}(x_{i}) )_{i=1}^{m}\]</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.BlockFunction.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">functions</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/BlockFunction/#BlockFunction.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.__init__" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.BlockFunction.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.BlockFunction.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/BlockFunction/#BlockFunction.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the BlockFunction <span class="math notranslate nohighlight">\(F\)</span></p>
<div class="math notranslate nohighlight">
\[F(x) = \overset{m}{\underset{i=1}{\sum}}f_{i}(x_{i}), \mbox{ where } x = (x_{1}, x_{2}, \cdots, x_{m}), \quad i = 1,2,\dots,m\]</div>
<p>Parameter:</p>
<blockquote>
<div><p>x : BlockDataContainer and must have as many rows as self.length</p>
<p>returns ..math:: sum(f_i(x_i))</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.BlockFunction.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/BlockFunction/#BlockFunction.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the convex conjugate of the BlockFunction at <span class="math notranslate nohighlight">\(x^{*}\)</span>.</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \overset{m}{\underset{i=1}{\sum}}f_{i}^{*}(x^{*}_{i})\]</div>
<p>Parameter:</p>
<blockquote>
<div><p>x : BlockDataContainer and must have as many rows as self.length</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.BlockFunction.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/BlockFunction/#BlockFunction.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Proximal operator of the BlockFunction at x:</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) =  (\mathrm{prox}_{\tau f_{i}}(x_{i}))_{i=1}^{m}\]</div>
<p>Parameter:</p>
<blockquote>
<div><p>x : BlockDataContainer and must have as many rows as self.length</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.BlockFunction.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/BlockFunction/#BlockFunction.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of the BlockFunction function at x.</p>
<div class="math notranslate nohighlight">
\[F'(x) = [f_{1}'(x_{1}), ... , f_{m}'(x_{m})]\]</div>
<p>Parameter:</p>
<blockquote>
<div><p>x : BlockDataContainer and must have as many rows as self.length</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.BlockFunction.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/BlockFunction/#BlockFunction.proximal_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.proximal_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Proximal operator of the convex conjugate of BlockFunction at x:</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F^{*}}(x) = (\mathrm{prox}_{\tau f^{*}_{i}}(x^{*}_{i}))_{i=1}^{m}\]</div>
<p>Parameter:</p>
<blockquote>
<div><p>x : BlockDataContainer and must have as many rows as self.length</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.BlockFunction.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/BlockFunction/#BlockFunction.__rmul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.__rmul__" title="Permalink to this definition">#</a></dt>
<dd><p>Define multiplication with a scalar</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> – number</p>
</dd>
</dl>
<p>Returns a new <a class="reference external" href="optimisation.html#cil.optimisation.functions.BlockFunction">BlockFunction</a> containing the product of the scalar with all the functions in the block</p>
</dd></dl>

</dd></dl>

</section>
<section id="block-operator">
<h2>Block Operator<a class="headerlink" href="#block-operator" title="Permalink to this headline">#</a></h2>
<p><a class="reference external" href="optimisation.html#cil.optimisation.operators.BlockOperators">BlockOperator</a> represent a block matrix with operators</p>
<div class="math notranslate nohighlight">
\[\begin{split}K = \begin{bmatrix}
     A_{1} &amp; A_{2} \\
     A_{3} &amp; A_{4} \\
     A_{5} &amp; A_{6}
\end{bmatrix}_{(3,2)} *  \quad \underbrace{\begin{bmatrix}
x_{1} \\
x_{2}
\end{bmatrix}_{(2,1)}}_{\textbf{x}} =  \begin{bmatrix}
A_{1}x_{1}  + A_{2}x_{2}\\
A_{3}x_{1}  + A_{4}x_{2}\\
A_{5}x_{1}  + A_{6}x_{2}\\
\end{bmatrix}_{(3,1)} =  \begin{bmatrix}
y_{1}\\
y_{2}\\
y_{3}
\end{bmatrix}_{(3,1)} = \textbf{y}\end{split}\]</div>
<p>Column: Share the same domains <span class="math notranslate nohighlight">\(X_{1}, X_{2}\)</span></p>
<p>Rows: Share the same ranges <span class="math notranslate nohighlight">\(Y_{1}, Y_{2}, Y_{3}\)</span></p>
<div class="math notranslate nohighlight">
\[K : (X_{1}\times X_{2}) \rightarrow (Y_{1}\times Y_{2} \times Y_{3})\]</div>
<p><span class="math notranslate nohighlight">\(A_{1}, A_{3}, A_{5}\)</span>: share the same domain <span class="math notranslate nohighlight">\(X_{1}\)</span> and
<span class="math notranslate nohighlight">\(A_{2}, A_{4}, A_{6}\)</span>: share the same domain <span class="math notranslate nohighlight">\(X_{2}\)</span></p>
<div class="math notranslate nohighlight">
\[\begin{split}A_{1}: X_{1} \rightarrow Y_{1} \\
A_{3}: X_{1} \rightarrow Y_{2} \\
A_{5}: X_{1} \rightarrow Y_{3} \\
A_{2}: X_{2} \rightarrow Y_{1} \\
A_{4}: X_{2} \rightarrow Y_{2} \\
A_{6}: X_{2} \rightarrow Y_{3}\end{split}\]</div>
<p>For instance with these ingredients one may write the following objective
function,</p>
<div class="math notranslate nohighlight">
\[\alpha ||\nabla u||_{2,1} + ||u - g||_2^2\]</div>
<p>where <span class="math notranslate nohighlight">\(g\)</span> represent the measured values, <span class="math notranslate nohighlight">\(u\)</span> the solution
<span class="math notranslate nohighlight">\(\nabla\)</span> is the gradient operator, <span class="math notranslate nohighlight">\(|| ~~ ||_{2,1}\)</span> is a norm for
the output of the gradient operator and <span class="math notranslate nohighlight">\(|| x-g ||^2_2\)</span> is
least squares fidelity function as</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}K = \begin{bmatrix}
          \nabla \\
          \mathbb{1}
        \end{bmatrix}\end{split}\\F(x) = \Big[ \alpha \lVert ~x~ \rVert_{2,1} ~~ , ~~ || x - g||_2^2 \Big]\\w = [ u ]\end{aligned}\end{align} \]</div>
<p>Then we have rewritten the problem as</p>
<div class="math notranslate nohighlight">
\[F(Kw) =   \alpha \left\lVert \nabla u \right\rVert_{2,1} + ||u-g||^2_2\]</div>
<p>Which in Python would be like</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">op1</span> <span class="o">=</span> <span class="n">GradientOperator</span><span class="p">(</span><span class="n">ig</span><span class="p">,</span> <span class="n">correlation</span><span class="o">=</span><span class="n">GradientOperator</span><span class="o">.</span><span class="n">CORRELATION_SPACE</span><span class="p">)</span>
<span class="n">op2</span> <span class="o">=</span> <span class="n">IdentityOperator</span><span class="p">(</span><span class="n">ig</span><span class="p">,</span> <span class="n">ag</span><span class="p">)</span>

<span class="c1"># Create BlockOperator</span>
<span class="n">K</span> <span class="o">=</span> <span class="n">BlockOperator</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>

<span class="c1"># Create functions</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">BlockFunction</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">MixedL21Norm</span><span class="p">(),</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">L2NormSquared</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="n">noisy_data</span><span class="p">))</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">BlockOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator" title="Permalink to this definition">#</a></dt>
<dd><p>A Block matrix containing Operators</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> (<a class="reference internal" href="#cil.optimisation.operators.Operator" title="cil.optimisation.operators.Operator"><em>Operator</em></a>) – Operators in the block.</p></li>
<li><p><strong>**kwargs</strong> (<em>dict</em>) – shape (<code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code>, optional): If shape is passed the Operators in vararg are considered input in a row-by-row fashion.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Block Framework is a generic strategy to treat variational problems in the
following form:</p>
<div class="math notranslate nohighlight">
\[\min Regulariser + Fidelity\]</div>
</div>
<p>BlockOperators have a generic shape M x N, and when applied on an
Nx1 BlockDataContainer, will yield and Mx1 BlockDataContainer.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>BlockDatacontainer are only allowed to have the shape of N x 1, with
N rows and 1 column.</p>
<p>User may specify the shape of the block, by default is a row vector</p>
<p>Operators in a Block are required to have the same domain column-wise and the
same range row-wise.</p>
</div>
<p class="rubric">Examples</p>
<p>BlockOperator(op0,op1) results in a row block</p>
<p>BlockOperator(op0,op1,shape=(1,2)) results in a column block</p>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.__init__" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.column_wise_compatible">
<span class="sig-name descname"><span class="pre">column_wise_compatible</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.column_wise_compatible"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.column_wise_compatible" title="Permalink to this definition">#</a></dt>
<dd><p>Operators in a Block should have the same domain per column</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.row_wise_compatible">
<span class="sig-name descname"><span class="pre">row_wise_compatible</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.row_wise_compatible"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.row_wise_compatible" title="Permalink to this definition">#</a></dt>
<dd><p>Operators in a Block should have the same range per row</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.get_item">
<span class="sig-name descname"><span class="pre">get_item</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">row</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.get_item"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.get_item" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the Operator at specified row and col
:param row: The row index required.
:type row: <cite>int</cite>
:param col: The column index required.
:type col: <cite>int</cite></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.norm" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the Euclidean norm of the norms of the individual operators in the BlockOperators</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.get_norms_as_list">
<span class="sig-name descname"><span class="pre">get_norms_as_list</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.get_norms_as_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.get_norms_as_list" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a list of the individual norms of the Operators in the BlockOperator</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.set_norms">
<span class="sig-name descname"><span class="pre">set_norms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norms</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.set_norms"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.set_norms" title="Permalink to this definition">#</a></dt>
<dd><p>Uses the set_norm() function in Operator to set the norms of the operators in the BlockOperator from a list of custom values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>norms</strong> (<em>list</em>) – A list of positive real values the same length as the number of operators in the BlockOperator.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Direct operation for the BlockOperator</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>BlockOperators work on BlockDataContainers, but they will also work on DataContainers
and inherited classes by simple wrapping the input in a BlockDataContainer of shape (1,1)</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>Adjoint operation for the BlockOperator</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>BlockOperator may contain both LinearOperator and Operator
This method exists in BlockOperator as it is not known what type of
Operator it will contain.</p>
<p>BlockOperators work on BlockDataContainers, but they will also work on DataContainers
and inherited classes by simple wrapping the input in a BlockDataContainer of shape (1,1)</p>
<p>Raises: ValueError if the contained Operators are not linear</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.is_linear">
<span class="sig-name descname"><span class="pre">is_linear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.is_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.is_linear" title="Permalink to this definition">#</a></dt>
<dd><p>Returns whether all the elements of the BlockOperator are linear</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.get_output_shape">
<span class="sig-name descname"><span class="pre">get_output_shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xshape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adjoint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.get_output_shape"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.get_output_shape" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the shape of the output BlockDataContainer
:param xshape:
:type xshape: BlockDataContainer
:param adjoint:
:type adjoint: <cite>bool</cite></p>
<p class="rubric">Examples</p>
<p>A(N,M) direct u(M,1) -&gt; N,1</p>
<p>A(N,M)^T adjoint u(N,1) -&gt; M,1</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scalar</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.__rmul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.__rmul__" title="Permalink to this definition">#</a></dt>
<dd><p>Defines the left multiplication with a scalar. Returns a block operator with Scaled Operators inside.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>scalar</strong> (<em>number</em><em> or </em><em>iterable containing numbers</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.T">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">T</span></span><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.T" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the transposed of self.</p>
<p>Recall the input list is shaped in a row-by-row fashion</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.domain_geometry">
<span class="sig-name descname"><span class="pre">domain_geometry</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.domain_geometry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.domain_geometry" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the domain of the BlockOperator</p>
<p>If the shape of the BlockOperator is (N,1) the domain is a ImageGeometry or AcquisitionGeometry.
Otherwise it is a BlockGeometry.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.range_geometry">
<span class="sig-name descname"><span class="pre">range_geometry</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.range_geometry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.range_geometry" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the range of the BlockOperator</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.__getitem__">
<span class="sig-name descname"><span class="pre">__getitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.__getitem__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.__getitem__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the index-th operator in the block irrespectively of it’s shape</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.get_as_list">
<span class="sig-name descname"><span class="pre">get_as_list</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.get_as_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.get_as_list" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the list of operators</p>
</dd></dl>

</dd></dl>

<p><a class="reference internal" href="../#mastertoc"><span class="std std-ref">Return Home</span></a></p>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<div class="docutils container" id="id35">
<dl class="citation">
<dt class="label" id="id43"><span class="brackets">1</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id5">2</a>,<a href="#id16">3</a>)</span></dt>
<dd><p>Amir Beck and Marc Teboulle. A fast iterative shrinkage-thresholding algorithm for linear inverse problems. <em>SIAM Journal on Imaging Sciences</em>, 2(1):183–202, 2009. URL: <a class="reference external" href="https://doi.org/10.1137/080716542">https://doi.org/10.1137/080716542</a>, <a class="reference external" href="https://arxiv.org/abs/https://doi.org/10.1137/080716542">arXiv:https://doi.org/10.1137/080716542</a>, <a class="reference external" href="https://doi.org/10.1137/080716542">doi:10.1137/080716542</a>.</p>
</dd>
<dt class="label" id="id42"><span class="brackets">2</span><span class="fn-backref">(<a href="#id3">1</a>,<a href="#id6">2</a>,<a href="#id17">3</a>)</span></dt>
<dd><p>Amir Beck and Marc Teboulle. Fast gradient-based algorithms for constrained total variation image denoising and deblurring problems. <em>IEEE Transactions on Image Processing</em>, 18(11):2419–2434, 2009. <a class="reference external" href="https://doi.org/10.1109/TIP.2009.2028250">doi:10.1109/TIP.2009.2028250</a>.</p>
</dd>
<dt class="label" id="id38"><span class="brackets">3</span><span class="fn-backref">(<a href="#id9">1</a>,<a href="#id20">2</a>)</span></dt>
<dd><p>Antonin Chambolle and Thomas Pock. A first-order primal-dual algorithm for convex problems with applications to imaging. <em>Journal of Mathematical Imaging and Vision</em>, 40(1):120–145, May 2011. URL: <a class="reference external" href="https://doi.org/10.1007/s10851-010-0251-1">https://doi.org/10.1007/s10851-010-0251-1</a>, <a class="reference external" href="https://doi.org/10.1007/s10851-010-0251-1">doi:10.1007/s10851-010-0251-1</a>.</p>
</dd>
<dt class="label" id="id39"><span class="brackets"><a class="fn-backref" href="#id10">4</a></span></dt>
<dd><p>Ernie Esser, Xiaoqun Zhang, and Tony F. Chan. A general framework for a class of first order primal-dual algorithms for convex optimization in imaging science. <em>SIAM Journal on Imaging Sciences</em>, 3(4):1015–1046, 2010. URL: <a class="reference external" href="https://doi.org/10.1137/09076934X">https://doi.org/10.1137/09076934X</a>, <a class="reference external" href="https://arxiv.org/abs/https://doi.org/10.1137/09076934X">arXiv:https://doi.org/10.1137/09076934X</a>, <a class="reference external" href="https://doi.org/10.1137/09076934X">doi:10.1137/09076934X</a>.</p>
</dd>
<dt class="label" id="id36"><span class="brackets"><a class="fn-backref" href="#id8">5</a></span></dt>
<dd><p>Osman Güler. New proximal point algorithms for convex minimization. <em>SIAM Journal on Optimization</em>, 2(4):649–664, 1992.</p>
</dd>
<dt class="label" id="id41"><span class="brackets"><a class="fn-backref" href="#id11">6</a></span></dt>
<dd><p>J. S. Jörgensen, E. Ametova, G. Burca, G. Fardell, E. Papoutsellis, E. Pasca, K. Thielemans, M. Turner, R. Warr, W. R. B. Lionheart, and P. J. Withers. Core imaging library - part i: a versatile python framework for tomographic imaging. <em>Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences</em>, 379(2204):20200192, 2021. URL: <a class="reference external" href="https://royalsocietypublishing.org/doi/abs/10.1098/rsta.2020.0192">https://royalsocietypublishing.org/doi/abs/10.1098/rsta.2020.0192</a>, <a class="reference external" href="https://arxiv.org/abs/https://royalsocietypublishing.org/doi/pdf/10.1098/rsta.2020.0192">arXiv:https://royalsocietypublishing.org/doi/pdf/10.1098/rsta.2020.0192</a>, <a class="reference external" href="https://doi.org/10.1098/rsta.2020.0192">doi:10.1098/rsta.2020.0192</a>.</p>
</dd>
<dt class="label" id="id45"><span class="brackets"><a class="fn-backref" href="#id1">7</a></span></dt>
<dd><p>Avinash C. Kak and Malcolm Slaney. <em>Principles of Computerized Tomographic Imaging</em>. Society for Industrial and Applied Mathematics, January 2001. URL: <a class="reference external" href="https://doi.org/10.1137/1.9780898719277">https://doi.org/10.1137/1.9780898719277</a>, <a class="reference external" href="https://doi.org/10.1137/1.9780898719277">doi:10.1137/1.9780898719277</a>.</p>
</dd>
<dt class="label" id="id37"><span class="brackets"><a class="fn-backref" href="#id7">8</a></span></dt>
<dd><p>Yurii Nesterov. <em>Introductory lectures on convex optimization: A basic course</em>. Volume 87. Springer Science &amp; Business Media, 2003.</p>
</dd>
<dt class="label" id="id40"><span class="brackets"><a class="fn-backref" href="#id12">9</a></span></dt>
<dd><p>Evangelos Papoutsellis, Evelina Ametova, Claire Delplancke, Gemma Fardell, Jakob S. Jörgensen, Edoardo Pasca, Martin Turner, Ryan Warr, William R. B. Lionheart, and Philip J. Withers. Core imaging library - part ii: multichannel reconstruction for dynamic and spectral tomography. <em>Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences</em>, 379(2204):20200193, 2021. URL: <a class="reference external" href="https://royalsocietypublishing.org/doi/abs/10.1098/rsta.2020.0193">https://royalsocietypublishing.org/doi/abs/10.1098/rsta.2020.0193</a>, <a class="reference external" href="https://arxiv.org/abs/https://royalsocietypublishing.org/doi/pdf/10.1098/rsta.2020.0193">arXiv:https://royalsocietypublishing.org/doi/pdf/10.1098/rsta.2020.0193</a>, <a class="reference external" href="https://doi.org/10.1098/rsta.2020.0193">doi:10.1098/rsta.2020.0193</a>.</p>
</dd>
<dt class="label" id="id44"><span class="brackets"><a class="fn-backref" href="#id19">10</a></span></dt>
<dd><p>Julian Rasch and Antonin Chambolle. Inexact first-order primal–dual algorithms. <em>Computational Optimization and Applications</em>, 76(2):381–430, Jun 2020. URL: <a class="reference external" href="https://doi.org/10.1007/s10589-020-00186-y">https://doi.org/10.1007/s10589-020-00186-y</a>, <a class="reference external" href="https://doi.org/10.1007/s10589-020-00186-y">doi:10.1007/s10589-020-00186-y</a>.</p>
</dd>
<dt class="label" id="id46"><span class="brackets"><a class="fn-backref" href="#id18">11</a></span></dt>
<dd><p>Mingqiang Zhu, Stephen J. Wright, and Tony F. Chan. Duality-based algorithms for total-variation-regularized image restoration. <em>Computational Optimization and Applications</em>, 47(3):377–400, Nov 2010. URL: <a class="reference external" href="https://doi.org/10.1007/s10589-008-9225-2">https://doi.org/10.1007/s10589-008-9225-2</a>, <a class="reference external" href="https://doi.org/10.1007/s10589-008-9225-2">doi:10.1007/s10589-008-9225-2</a>.</p>
</dd>
</dl>
</div>
</section>
</section>
</section>


                </article>
              
              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="../io/"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Read/ write AcquisitionData and ImageData</p>
      </div>
    </a>
    <a class="right-next"
       href="../processors/"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Processors</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">
  <p class="copyright">
    
      © Copyright 2017-2024.
      <br/>
    
  </p>
</div>
      
    </div>
  
  
</div>

  </footer>
  </body>
</html>