
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Optimisation framework &#8212; CIL 21.4.0 documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/styles/pydata-sphinx-theme.css" type="text/css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Processors" href="processors.html" />
    <link rel="prev" title="Read/ write AcquisitionData and ImageData" href="io.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    
<a class="navbar-brand" href="index.html">
<p class="title">CIL</p>
</a>

    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="framework.html">
  Framework
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="io.html">
  Read/ write AcquisitionData and ImageData
 </a>
</li>

<li class="toctree-l1 current active nav-item">
 <a class="current reference internal nav-link" href="#">
  Optimisation framework
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="processors.html">
  Processors
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="recon.html">
  Recon
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="utilities.html">
  Utilities
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="plugins.html">
  CIL Plugins
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="developer_guide.html">
  Developer’s guide
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
              <div class="sidebar-start-items">
<h3><a href="index.html">Table of Contents</a></h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="framework.html">Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="io.html">Read/ write AcquisitionData and ImageData</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Optimisation framework</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#algorithm">Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#operator">Operator</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#operator-base-classes">Operator base classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#trivial-operators">Trivial operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#gradientoperator">GradientOperator</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#function">Function</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#base-classes">Base classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simple-functions">Simple functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#composition-of-operator-and-a-function">Composition of operator and a function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#indicator-box">Indicator box</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kullbackleibler">KullbackLeibler</a></li>
<li class="toctree-l3"><a class="reference internal" href="#l1-norm">L1 Norm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#squared-l2-norm-squared">Squared L2 norm squared</a></li>
<li class="toctree-l3"><a class="reference internal" href="#least-squares">Least Squares</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mixed-l21-norm">Mixed L21 norm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#smooth-mixed-l21-norm">Smooth Mixed L21 norm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#total-variation">Total variation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#block-framework">Block Framework</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#blockdatacontainer">BlockDataContainer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#block-function">Block Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="#block-operator">Block Operator</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="processors.html">Processors</a></li>
<li class="toctree-l1"><a class="reference internal" href="recon.html">Recon</a></li>
<li class="toctree-l1"><a class="reference internal" href="utilities.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="plugins.html">CIL Plugins</a></li>
<li class="toctree-l1"><a class="reference internal" href="developer_guide.html">Developer’s guide</a></li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/optimisation.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
              </div>
              <div class="sidebar-end-items">
              </div>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage mt-5 pt-1 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#">
   Optimisation framework
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#algorithm">
     Algorithm
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#operator">
     Operator
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#operator-base-classes">
       Operator base classes
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#trivial-operators">
       Trivial operators
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#gradientoperator">
       GradientOperator
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#function">
     Function
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#base-classes">
       Base classes
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#simple-functions">
       Simple functions
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#composition-of-operator-and-a-function">
       Composition of operator and a function
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#indicator-box">
       Indicator box
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#kullbackleibler">
       KullbackLeibler
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#l1-norm">
       L1 Norm
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#squared-l2-norm-squared">
       Squared L2 norm squared
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#least-squares">
       Least Squares
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#mixed-l21-norm">
       Mixed L21 norm
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#smooth-mixed-l21-norm">
       Smooth Mixed L21 norm
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#total-variation">
       Total variation
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#block-framework">
   Block Framework
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#blockdatacontainer">
     BlockDataContainer
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#block-function">
     Block Function
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#block-operator">
     Block Operator
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#references">
       References
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <div class="section" id="optimisation-framework">
<h1>Optimisation framework<a class="headerlink" href="#optimisation-framework" title="Permalink to this headline">#</a></h1>
<p>This package allows rapid prototyping of optimisation-based reconstruction problems, i.e. defining and solving different optimization problems to enforce different properties on the reconstructed image.</p>
<p>Firstly, it provides an object-oriented framework for defining mathematical operators and functions as well a collection of useful example operators and functions. Both smooth and non-smooth functions can be used.</p>
<p>Further, it provides a number of high-level generic implementations of optimisation algorithms to solve genericlly formulated optimisation problems constructed from operator and function objects.</p>
<p>The fundamental components are:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">Operator</span></code>: A class specifying a (currently linear) operator</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">Function</span></code>: A class specifying mathematical functions such as a least squares data fidelity.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">Algorithm</span></code>: Implementation of an iterative optimisation algorithm to solve a particular generic optimisation problem. Algorithms are iterable Python object which can be run in a for loop. Can be stopped and warm restarted.</p></li>
</ul>
<div class="section" id="algorithm">
<h2>Algorithm<a class="headerlink" href="#algorithm" title="Permalink to this headline">#</a></h2>
<p>A number of generic algorithm implementations are provided including
Gradient Descent (GD), Conjugate Gradient Least Squares (CGLS),
Simultaneous Iterative Reconstruction Technique (SIRT), Primal Dual Hybrid
Gradient (PDHG) and Fast Iterative Shrinkage Thresholding Algorithm (FISTA).</p>
<p>An algorithm is designed for a particular generic optimisation problem accepts and number of
:code:<a href="#id1"><span class="problematic" id="id2">`</span></a>Function`s and/or :code:<a href="#id3"><span class="problematic" id="id4">`</span></a>Operator`s as input to define a specific instance of
the generic optimisation problem to be solved.
They are iterable objects which can be run in a for loop.
The user can provide a stopping criterion different than the default max_iteration.</p>
<p>New algorithms can be easily created by extending the <code class="code docutils literal notranslate"><span class="pre">Algorithm</span></code> class.
The user is required to implement only 4 methods: set_up, __init__, update and update_objective.</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">set_up</span></code> and <code class="code docutils literal notranslate"><span class="pre">__init__</span></code> are used to configure the algorithm</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">update</span></code> is the actual iteration updating the solution</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">update_objective</span></code> defines how the objective is calculated.</p></li>
</ul>
<p>For example, the implementation of the update of the Gradient Descent
algorithm to minimise a Function will only be:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective_function</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">update_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objective_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>The <code class="code docutils literal notranslate"><span class="pre">Algorithm</span></code> provides the infrastructure to continue iteration, to access the values of the
objective function in subsequent iterations, the time for each iteration, and to provide a nice
print to screen of the status of the optimisation.</p>
<dl class="py class">
<dt id="cil.optimisation.algorithms.Algorithm">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></code><code class="sig-name descname"><span class="pre">Algorithm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm" title="Permalink to this definition">#</a></dt>
<dd><p>Base class for iterative algorithms</p>
<p>provides the minimal infrastructure.</p>
<p>Algorithms are iterables so can be easily run in a for loop. They will
stop as soon as the stop cryterion is met.
The user is required to implement the <code class="code docutils literal notranslate"><span class="pre">set_up</span></code>, <code class="code docutils literal notranslate"><span class="pre">__init__</span></code>, <code class="code docutils literal notranslate"><span class="pre">update</span></code> and
and <code class="code docutils literal notranslate"><span class="pre">update_objective</span></code> methods</p>
<p>A courtesy method <code class="code docutils literal notranslate"><span class="pre">run</span></code> is available to run <code class="code docutils literal notranslate"><span class="pre">n</span></code> iterations. The method accepts
a <code class="code docutils literal notranslate"><span class="pre">callback</span></code> function that receives the current iteration number and the actual objective
value and can be used to trigger print to screens and other user interactions. The <code class="code docutils literal notranslate"><span class="pre">run</span></code>
method will stop when the stopping cryterion is met.</p>
<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Constructor</p>
<p>Set the minimal number of parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>max_iteration</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default 0</em>) – maximum number of iterations</p></li>
<li><p><strong>update_objectice_interval</strong> – the interval every which we would save the current                                       objective. 1 means every iteration, 2 every 2 iteration                                       and so forth. This is by default 1 and should be increased                                       when evaluating the objective is computationally expensive.</p></li>
<li><p><strong>log_file</strong> (<em>str</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – log verbose output to file</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.set_up">
<code class="sig-name descname"><span class="pre">set_up</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.set_up" title="Permalink to this definition">#</a></dt>
<dd><p>Set up the algorithm</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.update">
<code class="sig-name descname"><span class="pre">update</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.update" title="Permalink to this definition">#</a></dt>
<dd><p>A single iteration of the algorithm</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.should_stop">
<code class="sig-name descname"><span class="pre">should_stop</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.should_stop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.should_stop" title="Permalink to this definition">#</a></dt>
<dd><p>default stopping cryterion: number of iterations</p>
<p>The user can change this in concrete implementatition of iterative algorithms.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.__set_up_logger">
<code class="sig-name descname"><span class="pre">__set_up_logger</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.__set_up_logger" title="Permalink to this definition">#</a></dt>
<dd><p>Set up the logger if desired</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.max_iteration_stop_cryterion">
<code class="sig-name descname"><span class="pre">max_iteration_stop_cryterion</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.max_iteration_stop_cryterion"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.max_iteration_stop_cryterion" title="Permalink to this definition">#</a></dt>
<dd><p>default stop cryterion for iterative algorithm: max_iteration reached</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.__iter__">
<code class="sig-name descname"><span class="pre">__iter__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.__iter__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.__iter__" title="Permalink to this definition">#</a></dt>
<dd><p>Algorithm is an iterable</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.next">
<code class="sig-name descname"><span class="pre">next</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.next"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.next" title="Permalink to this definition">#</a></dt>
<dd><p>Algorithm is an iterable</p>
<p>python2 backwards compatibility</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.__next__">
<code class="sig-name descname"><span class="pre">__next__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.__next__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.__next__" title="Permalink to this definition">#</a></dt>
<dd><p>Algorithm is an iterable</p>
<p>calling this method triggers update and update_objective</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.update_previous_solution">
<code class="sig-name descname"><span class="pre">update_previous_solution</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.update_previous_solution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.update_previous_solution" title="Permalink to this definition">#</a></dt>
<dd><p>Update the previous solution with the current one</p>
<p>The concrete algorithm calls update_previous_solution. Normally this would
entail the swapping of pointers:</p>
<p>tmp = self.x_old
self.x_old = self.x
self.x = tmp</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.get_output">
<code class="sig-name descname"><span class="pre">get_output</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.get_output"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.get_output" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the solution found</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.get_last_loss">
<code class="sig-name descname"><span class="pre">get_last_loss</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.get_last_loss"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.get_last_loss" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.get_last_objective">
<code class="sig-name descname"><span class="pre">get_last_objective</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.get_last_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.get_last_objective" title="Permalink to this definition">#</a></dt>
<dd><p>alias to get_last_loss</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.update_objective">
<code class="sig-name descname"><span class="pre">update_objective</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.update_objective" title="Permalink to this definition">#</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.iterations">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">iterations</span></code><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.iterations" title="Permalink to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.loss">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">loss</span></code><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.loss" title="Permalink to this definition">#</a></dt>
<dd><p>returns the list of the values of the objective during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when
the update_objective_interval &gt; 1</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.objective">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">objective</span></code><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.objective" title="Permalink to this definition">#</a></dt>
<dd><p>alias of loss</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.max_iteration">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">max_iteration</span></code><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.max_iteration" title="Permalink to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.run">
<code class="sig-name descname"><span class="pre">run</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.run"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.run" title="Permalink to this definition">#</a></dt>
<dd><p>run n iterations and update the user with the callback if specified</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> – number of iterations to run. If not set the algorithm will
run until max_iteration or until stop criterion is reached</p></li>
<li><p><strong>verbose</strong> – sets the verbosity output to screen, 0 no verbose, 1 medium, 2 highly verbose</p></li>
<li><p><strong>callback</strong> – is a function that receives: current iteration number,
last objective function value and the current solution and gets executed at each update_objective_interval</p></li>
<li><p><strong>print_interval</strong> – integer, controls every how many iteration there’s a print to
screen. Notice that printing will not evaluate the objective function
and so the print might be out of sync wrt the calculation of the objective.
In such cases nan will be printed.</p></li>
<li><p><strong>very_verbose</strong> – deprecated bool, useful for algorithms with primal and dual objectives (PDHG),
prints to screen both primal and dual</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="cil.optimisation.algorithms.Algorithm.__weakref__">
<code class="sig-name descname"><span class="pre">__weakref__</span></code><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.__weakref__" title="Permalink to this definition">#</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.verbose_output">
<code class="sig-name descname"><span class="pre">verbose_output</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.verbose_output"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.verbose_output" title="Permalink to this definition">#</a></dt>
<dd><p>Creates a nice tabulated output</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.algorithms.GD">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></code><code class="sig-name descname"><span class="pre">GD</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">objective_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/GD.html#GD"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD" title="Permalink to this definition">#</a></dt>
<dd><p>Gradient Descent algorithm</p>
<dl class="py method">
<dt id="cil.optimisation.algorithms.GD.set_up">
<code class="sig-name descname"><span class="pre">set_up</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">objective_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/GD.html#GD.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD.set_up" title="Permalink to this definition">#</a></dt>
<dd><p>initialisation of the algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial</strong> – initial guess</p></li>
<li><p><strong>objective_function</strong> – objective function to be minimised</p></li>
<li><p><strong>step_size</strong> – step size</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.GD.update">
<code class="sig-name descname"><span class="pre">update</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/GD.html#GD.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD.update" title="Permalink to this definition">#</a></dt>
<dd><p>Single iteration</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.GD.update_objective">
<code class="sig-name descname"><span class="pre">update_objective</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/GD.html#GD.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD.update_objective" title="Permalink to this definition">#</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.GD.armijo_rule">
<code class="sig-name descname"><span class="pre">armijo_rule</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/GD.html#GD.armijo_rule"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD.armijo_rule" title="Permalink to this definition">#</a></dt>
<dd><p>Applies the Armijo rule to calculate the step size (step_size)</p>
<p><a class="reference external" href="https://projecteuclid.org/download/pdf_1/euclid.pjm/1102995080">https://projecteuclid.org/download/pdf_1/euclid.pjm/1102995080</a></p>
<p>The Armijo rule runs a while loop to find the appropriate step_size by starting
from a very large number (alpha). The step_size is found by dividing alpha by 2
in an iterative way until a certain criterion is met. To avoid infinite loops, we
add a maximum number of times the while loop is run.</p>
<p>This rule would allow to reach a minimum step_size of 10^-alpha.</p>
<p>if
alpha = numpy.power(10,gamma)
delta = 3
step_size = numpy.power(10, -delta)
with armijo rule we can get to step_size from initial alpha by repeating the while loop k times
where
alpha / 2^k = step_size
10^gamma / 2^k = 10^-delta
2^k = 10^(gamma+delta)
k = gamma+delta / log10(2) approx 3.3 * (gamma+delta)</p>
<p>if we would take by default delta = gamma
kmax = numpy.ceil ( 2 * gamma / numpy.log10(2) )
kmax = numpy.ceil (2 * numpy.log10(alpha) / numpy.log10(2))</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.GD.should_stop">
<code class="sig-name descname"><span class="pre">should_stop</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/GD.html#GD.should_stop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD.should_stop" title="Permalink to this definition">#</a></dt>
<dd><p>default stopping cryterion: number of iterations</p>
<p>The user can change this in concrete implementatition of iterative algorithms.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.algorithms.CGLS">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></code><code class="sig-name descname"><span class="pre">CGLS</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/CGLS.html#CGLS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS" title="Permalink to this definition">#</a></dt>
<dd><p>Conjugate Gradient Least Squares algorithm</p>
<p>Problem:</p>
<div class="math notranslate nohighlight">
\[\min || A x - b ||^2_2\]</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Parameters :</p>
<blockquote>
<div><p>:parameter operator : Linear operator for the inverse problem
:parameter initial : Initial guess ( Default initial = 0)
:parameter data : Acquired data to reconstruct
:parameter tolerance: Tolerance/ Stopping Criterion to end CGLS algorithm</p>
</div></blockquote>
<dl class="simple">
<dt>Reference:</dt><dd><p><a class="reference external" href="https://web.stanford.edu/group/SOL/software/cgls/">https://web.stanford.edu/group/SOL/software/cgls/</a></p>
</dd>
</dl>
<dl class="py method">
<dt id="cil.optimisation.algorithms.CGLS.set_up">
<code class="sig-name descname"><span class="pre">set_up</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/CGLS.html#CGLS.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.set_up" title="Permalink to this definition">#</a></dt>
<dd><p>initialisation of the algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> – Linear operator for the inverse problem</p></li>
<li><p><strong>initial</strong> – Initial guess ( Default initial = 0)</p></li>
<li><p><strong>data</strong> – Acquired data to reconstruct</p></li>
<li><p><strong>tolerance</strong> – Tolerance/ Stopping Criterion to end CGLS algorithm</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.CGLS.update">
<code class="sig-name descname"><span class="pre">update</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/CGLS.html#CGLS.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.update" title="Permalink to this definition">#</a></dt>
<dd><p>single iteration</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.CGLS.update_objective">
<code class="sig-name descname"><span class="pre">update_objective</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/CGLS.html#CGLS.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.update_objective" title="Permalink to this definition">#</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.CGLS.should_stop">
<code class="sig-name descname"><span class="pre">should_stop</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/CGLS.html#CGLS.should_stop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.should_stop" title="Permalink to this definition">#</a></dt>
<dd><p>stopping criterion</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.CGLS.flag">
<code class="sig-name descname"><span class="pre">flag</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/CGLS.html#CGLS.flag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.flag" title="Permalink to this definition">#</a></dt>
<dd><p>returns whether the tolerance has been reached</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.algorithms.SIRT">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></code><code class="sig-name descname"><span class="pre">SIRT</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/SIRT.html#SIRT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SIRT" title="Permalink to this definition">#</a></dt>
<dd><p>Simultaneous Iterative Reconstruction Technique, see <span id="id5">[<a class="reference internal" href="#id21" title="Avinash C. Kak and Malcolm Slaney. Principles of Computerized Tomographic Imaging. Society for Industrial and Applied Mathematics, January 2001. URL: https://doi.org/10.1137/1.9780898719277, doi:10.1137/1.9780898719277.">4</a>]</span>.</p>
<p>Simultaneous Iterative Reconstruction Technique (SIRT) solves
the following problem</p>
<div class="math notranslate nohighlight">
\[A x = b\]</div>
<p>The SIRT algorithm is</p>
<div class="math notranslate nohighlight">
\[x^{k+1} =  \mathrm{proj}_{C}( x^{k} + D ( A^{T} ( M * (b - Ax) ) ) ),\]</div>
<p>where <span class="math notranslate nohighlight">\(M = \frac{1}{A*\mathbb{1}}\)</span>, <span class="math notranslate nohighlight">\(D = \frac{1}{A^{T}\mathbb{1}}\)</span>, <span class="math notranslate nohighlight">\(\mathbb{1}\)</span> is a <code class="code docutils literal notranslate"><span class="pre">DataContainer</span></code> of ones
and <span class="math notranslate nohighlight">\(\mathrm{prox}_{C}\)</span> is the projection over a set <span class="math notranslate nohighlight">\(C\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial</strong> (<a class="reference internal" href="framework.html#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>default = None</em>) – Starting point of the algorithm, default value = Zero DataContainer</p></li>
<li><p><strong>operator</strong> (<a class="reference internal" href="#cil.optimisation.operators.LinearOperator" title="cil.optimisation.operators.LinearOperator"><em>LinearOperator</em></a>) – The operator A.</p></li>
<li><p><strong>data</strong> (<a class="reference internal" href="framework.html#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The data b.</p></li>
<li><p><strong>lower</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, default = None) – Lower bound constraint, default value = <code class="code docutils literal notranslate"><span class="pre">-inf</span></code>.</p></li>
<li><p><strong>upper</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, default = None) – Upper bound constraint, default value = <code class="code docutils literal notranslate"><span class="pre">-inf</span></code>.</p></li>
<li><p><strong>constraint</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a><em>, </em><em>default = None</em>) – A function with <code class="code docutils literal notranslate"><span class="pre">proximal</span></code> method, e.g., <a class="reference internal" href="#cil.optimisation.functions.IndicatorBox" title="cil.optimisation.functions.IndicatorBox"><code class="xref py py-class docutils literal notranslate"><span class="pre">IndicatorBox</span></code></a> function and <a class="reference internal" href="#cil.optimisation.functions.IndicatorBox.proximal" title="cil.optimisation.functions.IndicatorBox.proximal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">IndicatorBox.proximal()</span></code></a>,
or <a class="reference internal" href="#cil.optimisation.functions.TotalVariation" title="cil.optimisation.functions.TotalVariation"><code class="xref py py-class docutils literal notranslate"><span class="pre">TotalVariation</span></code></a> function and <a class="reference internal" href="#cil.optimisation.functions.TotalVariation.proximal" title="cil.optimisation.functions.TotalVariation.proximal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TotalVariation.proximal()</span></code></a>.</p></li>
<li><p><strong>kwargs</strong> – Keyword arguments used from the base class <a class="reference internal" href="#cil.optimisation.algorithms.Algorithm" title="cil.optimisation.algorithms.Algorithm"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algorithm</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="code docutils literal notranslate"><span class="pre">constraint</span></code> is not passed, then <code class="code docutils literal notranslate"><span class="pre">lower</span></code> and <code class="code docutils literal notranslate"><span class="pre">upper</span></code> are looked at and an <a class="reference internal" href="#cil.optimisation.functions.IndicatorBox" title="cil.optimisation.functions.IndicatorBox"><code class="xref py py-class docutils literal notranslate"><span class="pre">IndicatorBox</span></code></a>
function is created.</p>
<p>If <code class="code docutils literal notranslate"><span class="pre">constraint</span></code> is passed, <code class="code docutils literal notranslate"><span class="pre">proximal</span></code> method is required to be implemented.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The preconditioning arrays (weights) <code class="code docutils literal notranslate"><span class="pre">M</span></code> and <code class="code docutils literal notranslate"><span class="pre">D</span></code> used in SIRT are defined as</p>
<div class="math notranslate nohighlight">
\[M = \frac{1}{A*\mathbb{1}} = \frac{1}{\sum_{j}a_{i,j}}\]</div>
<div class="math notranslate nohighlight">
\[D = \frac{1}{A*\mathbb{1}} = \frac{1}{\sum_{i}a_{i,j}}\]</div>
<p>In case of division errors above, <code class="xref py py-meth docutils literal notranslate"><span class="pre">_fix_weights()</span></code> can be used, where <code class="code docutils literal notranslate"><span class="pre">np.nan</span></code>, <code class="code docutils literal notranslate"><span class="pre">+np.inf</span></code> and <code class="code docutils literal notranslate"><span class="pre">-np.inf</span></code> values
are replaced with 1.0.</p>
</div>
<p class="rubric">Examples</p>
<div class="math notranslate nohighlight">
\[\underset{x}{\mathrm{argmin}} \| x - d\|^{2}\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sirt</span> <span class="o">=</span> <span class="n">SIRT</span><span class="p">(</span><span class="n">initial</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">operator</span> <span class="o">=</span> <span class="n">A</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="p">,</span> <span class="n">max_iteration</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt id="cil.optimisation.algorithms.SIRT.update">
<code class="sig-name descname"><span class="pre">update</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/SIRT.html#SIRT.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.update" title="Permalink to this definition">#</a></dt>
<dd><p>Performs a single iteration of the SIRT algorithm</p>
<div class="math notranslate nohighlight">
\[x^{k+1} =  \mathrm{proj}_{C}( x^{k} + D ( A^{T} ( M * (b - Ax) ) ) )\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SIRT.update_objective">
<code class="sig-name descname"><span class="pre">update_objective</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/SIRT.html#SIRT.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.update_objective" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the objective</p>
<div class="math notranslate nohighlight">
\[\|A x - b\|^{2}\]</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.algorithms.FISTA">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></code><code class="sig-name descname"><span class="pre">FISTA</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">initial=None</span></em>, <em class="sig-param"><span class="pre">f=None</span></em>, <em class="sig-param"><span class="pre">g=&lt;cil.optimisation.functions.Function.ZeroFunction</span> <span class="pre">object&gt;</span></em>, <em class="sig-param"><span class="pre">**kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/FISTA.html#FISTA"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.FISTA" title="Permalink to this definition">#</a></dt>
<dd><p>Fast Iterative Shrinkage-Thresholding Algorithm</p>
<p>Problem :</p>
<div class="math notranslate nohighlight">
\[\min_{x} f(x) + g(x)\]</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Parameters :</p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">param initial</dt>
<dd class="field-odd"><p>Initial guess ( Default initial = 0)</p>
</dd>
<dt class="field-even">param f</dt>
<dd class="field-even"><p>Differentiable function</p>
</dd>
<dt class="field-odd">param g</dt>
<dd class="field-odd"><p>Convex function with ” simple ” proximal operator</p>
</dd>
</dl>
</div></blockquote>
<p>Reference:</p>
<blockquote>
<div><p>Beck, A. and Teboulle, M., 2009. A fast iterative shrinkage-thresholding
algorithm for linear inverse problems.
SIAM journal on imaging sciences,2(1), pp.183-202.</p>
</div></blockquote>
<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">initial=None</span></em>, <em class="sig-param"><span class="pre">f=None</span></em>, <em class="sig-param"><span class="pre">g=&lt;cil.optimisation.functions.Function.ZeroFunction</span> <span class="pre">object&gt;</span></em>, <em class="sig-param"><span class="pre">**kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/FISTA.html#FISTA.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>FISTA algorithm creator</p>
<p>initialisation can be done at creation time if all
proper variables are passed or later with set_up</p>
<p>Optional parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial</strong> – Initial guess ( Default initial = 0)</p></li>
<li><p><strong>f</strong> – Differentiable function</p></li>
<li><p><strong>g</strong> – Convex function with ” simple ” proximal operator</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.set_up">
<code class="sig-name descname"><span class="pre">set_up</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">initial</span></em>, <em class="sig-param"><span class="pre">f</span></em>, <em class="sig-param"><span class="pre">g=&lt;cil.optimisation.functions.Function.ZeroFunction</span> <span class="pre">object&gt;</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/FISTA.html#FISTA.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.set_up" title="Permalink to this definition">#</a></dt>
<dd><p>initialisation of the algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial</strong> – Initial guess ( Default initial = 0)</p></li>
<li><p><strong>f</strong> – Differentiable function</p></li>
<li><p><strong>g</strong> – Convex function with ” simple ” proximal operator</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.update">
<code class="sig-name descname"><span class="pre">update</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/FISTA.html#FISTA.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.update" title="Permalink to this definition">#</a></dt>
<dd><p>A single iteration of the algorithm</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.update_previous_solution">
<code class="sig-name descname"><span class="pre">update_previous_solution</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/FISTA.html#FISTA.update_previous_solution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.update_previous_solution" title="Permalink to this definition">#</a></dt>
<dd><p>Update the previous solution with the current one</p>
<p>The concrete algorithm calls update_previous_solution. Normally this would
entail the swapping of pointers:</p>
<p>tmp = self.x_old
self.x_old = self.x
self.x = tmp</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.update_objective">
<code class="sig-name descname"><span class="pre">update_objective</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/FISTA.html#FISTA.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.update_objective" title="Permalink to this definition">#</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.algorithms.PDHG">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></code><code class="sig-name descname"><span class="pre">PDHG</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/PDHG.html#PDHG"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG" title="Permalink to this definition">#</a></dt>
<dd><p>Primal Dual Hybrid Gradient (PDHG) algorithm, see <span id="id6">[<a class="reference internal" href="#id17" title="Antonin Chambolle and Thomas Pock. A first-order primal-dual algorithm for convex problems with applications to imaging. Journal of Mathematical Imaging and Vision, 40(1):120-145, May 2011. URL: https://doi.org/10.1007/s10851-010-0251-1, doi:10.1007/s10851-010-0251-1.">1</a>]</span>, <span id="id7">[<a class="reference internal" href="#id18" title="Ernie Esser, Xiaoqun Zhang, and Tony F. Chan. A general framework for a class of first order primal-dual algorithms for convex optimization in imaging science. SIAM Journal on Imaging Sciences, 3(4):1015-1046, 2010. URL: https://doi.org/10.1137/09076934X, arXiv:https://doi.org/10.1137/09076934X, doi:10.1137/09076934X.">2</a>]</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – A convex function with a “simple” proximal method of its conjugate.</p></li>
<li><p><strong>g</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – A convex function with a “simple” proximal.</p></li>
<li><p><strong>operator</strong> (<a class="reference internal" href="#cil.optimisation.operators.LinearOperator" title="cil.optimisation.operators.LinearOperator"><em>LinearOperator</em></a>) – A Linear Operator.</p></li>
<li><p><strong>sigma</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, or <cite>np.ndarray</cite>, <cite>DataContainer</cite>, <cite>BlockDataContainer</cite>, optional, default=None) – Step size for the dual problem.</p></li>
<li><p><strong>tau</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, or <cite>np.ndarray</cite>, <cite>DataContainer</cite>, <cite>BlockDataContainer</cite>, optional, default=None) – Step size for the primal problem.</p></li>
<li><p><strong>initial</strong> (<a class="reference internal" href="framework.html#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Initial point for the PDHG algorithm.</p></li>
<li><p><strong>gamma_g</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, optional, default=None) – Strongly convex constant if the function g is strongly convex. Allows primal acceleration of the PDHG algorithm.</p></li>
<li><p><strong>gamma_fconj</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, optional, default=None) – Strongly convex constant if the convex conjugate of f is strongly convex. Allows dual acceleration of the PDHG algorithm.</p></li>
<li><p><strong>**kwargs</strong> – <p>Keyward arguments used from the base class <a class="reference internal" href="#cil.optimisation.algorithms.Algorithm" title="cil.optimisation.algorithms.Algorithm"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algorithm</span></code></a>.</p>
<dl>
<dt>max_iteration<span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional, default=0</span></dt><dd><p>Maximum number of iterations of the PDHG.</p>
</dd>
<dt>update_objective_interval<span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional, default=1</span></dt><dd><p>Evaluates objectives, e.g., primal/dual/primal-dual gap every <code class="docutils literal notranslate"><span class="pre">update_objective_interval</span></code>.</p>
</dd>
<dt>check_convergence<span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">boolean</span></code>, default=True</span></dt><dd><p>Checks scalar sigma and tau values satisfy convergence criterion</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<p>In our <a class="reference external" href="https://github.com/TomographicImaging/CIL-Demos/blob/main/binder/TomographyReconstruction.ipynb">CIL-Demos</a> repositoryyou can find examples using the PDHG algorithm for different imaging problems, such as Total Variation denoising, Total Generalised Variation inpaintingand Total Variation Tomography reconstruction. More examples can also be found in <span id="id8">[<a class="reference internal" href="#id20" title="J. S. Jörgensen, E. Ametova, G. Burca, G. Fardell, E. Papoutsellis, E. Pasca, K. Thielemans, M. Turner, R. Warr, W. R. B. Lionheart, and P. J. Withers. Core imaging library - part i: a versatile python framework for tomographic imaging. Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences, 379(2204):20200192, 2021. URL: https://royalsocietypublishing.org/doi/abs/10.1098/rsta.2020.0192, arXiv:https://royalsocietypublishing.org/doi/pdf/10.1098/rsta.2020.0192, doi:10.1098/rsta.2020.0192.">3</a>]</span>, <span id="id9">[<a class="reference internal" href="#id19" title="Evangelos Papoutsellis, Evelina Ametova, Claire Delplancke, Gemma Fardell, Jakob S. Jörgensen, Edoardo Pasca, Martin Turner, Ryan Warr, William R. B. Lionheart, and Philip J. Withers. Core imaging library - part ii: multichannel reconstruction for dynamic and spectral tomography. Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences, 379(2204):20200193, 2021. URL: https://royalsocietypublishing.org/doi/abs/10.1098/rsta.2020.0193, arXiv:https://royalsocietypublishing.org/doi/pdf/10.1098/rsta.2020.0193, doi:10.1098/rsta.2020.0193.">5</a>]</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, the strongly convex constants are passed as parameters of PDHG.
In the future, these parameters will be properties of the corresponding functions.</p>
</div>
<p class="rubric">Notes</p>
<p>A first-order primal-dual algorithm for convex optimization problems with known saddle-point structure with applications in imaging.</p>
<p>The general problem considered in the PDHG algorithm is the generic saddle-point problem</p>
<div class="math notranslate nohighlight">
\[\min_{x\in X}\max_{y\in Y} \langle Kx, y \rangle + g(x) - f^{*}(x)\]</div>
<p>where <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> are convex functions with “simple” proximal operators.</p>
<p><span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> are two two finite-dimensional vector spaces with an inner product and representing the domain of <span class="math notranslate nohighlight">\(g\)</span> and <span class="math notranslate nohighlight">\(f^{*}\)</span>, the convex conjugate of <span class="math notranslate nohighlight">\(f\)</span>, respectively.</p>
<p>The operator <span class="math notranslate nohighlight">\(K\)</span> is a continuous linear operator with operator norm defined as</p>
<div class="math notranslate nohighlight">
\[\|K\| = \max\{ \|Kx\| : x\in X, \|x\|\leq1\}\]</div>
<p>The saddle point problem is decomposed into the primal problem:</p>
<div class="math notranslate nohighlight">
\[\min_{x\in X} f(Kx) + g(x),\]</div>
<p>and its corresponding dual problem</p>
<div class="math notranslate nohighlight">
\[\max_{y\in Y} - g^{*}(-K^{*}y) - f^{*}(y).\]</div>
<p>The PDHG algorithm consists of three steps:</p>
<ul class="simple">
<li><p>gradient ascent step for the dual problem,</p></li>
<li><p>gradient descent step for the primal problem and</p></li>
<li><p>an over-relaxation of the primal variable.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[y^{n+1} = \mathrm{prox}_{\sigma f^{*}}(y^{n} + \sigma K \bar{x}^{n})\]</div>
<div class="math notranslate nohighlight">
\[x^{n+1} = \mathrm{prox}_{\tau g}(x^{n} - \tau K^{*}y^{n+1})\]</div>
<div class="math notranslate nohighlight">
\[\bar{x}^{n+1} = x^{n+1} + \theta (x^{n+1} - x^{n})\]</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Convergence is guaranteed if <span class="math notranslate nohighlight">\(\theta\)</span> = 1.0,  the operator norm <span class="math notranslate nohighlight">\(\|K\|\)</span>, the dual step size <span class="math notranslate nohighlight">\(\sigma\)</span> and the primal step size <span class="math notranslate nohighlight">\(\tau\)</span>, satisfy the following inequality:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\tau \sigma \|K\|^2 &lt; 1\]</div>
<ul>
<li><p>By default, the step sizes <span class="math notranslate nohighlight">\(\sigma\)</span> and <span class="math notranslate nohighlight">\(\tau\)</span> are positive scalars and defined as below:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">sigma</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code> and <code class="docutils literal notranslate"><span class="pre">tau</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\sigma = \frac{1}{\|K\|},  \tau = \frac{1}{\|K\|}\]</div>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">tau</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\tau = \frac{1}{\sigma\|K\|^{2}}\]</div>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">sigma</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\sigma = \frac{1}{\tau\|K\|^{2}}\]</div>
</li>
<li><p>To monitor the convergence of the algorithm, we compute the primal/dual objectives and the primal-dual gap in <a class="reference internal" href="#cil.optimisation.algorithms.PDHG.update_objective" title="cil.optimisation.algorithms.PDHG.update_objective"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update_objective()</span></code></a>.</p>
<p>The primal objective is</p>
<div class="math notranslate nohighlight">
\[f(Kx) + g(x)\]</div>
<p>and the dual objective is</p>
<div class="math notranslate nohighlight">
\[- g^{*}(-K^{*}y) - f^{*}(y)\]</div>
<p>The primal-dual gap (or duality gap) is</p>
<div class="math notranslate nohighlight">
\[f(Kx) + g(x) + g^{*}(-K^{*}y) + f^{*}(y)\]</div>
<p>and measures how close is the primal-dual pair (x,y) to the primal-dual solution. It is always non-negative and is used to monitor convergence of the PDHG algorithm. For more information, see <a class="reference external" href="https://en.wikipedia.org/wiki/Duality_gap">Duality Gap</a>.</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>The primal objective is printed if <cite>verbose=1</cite>, <code class="docutils literal notranslate"><span class="pre">pdhg.run(verbose=1)</span></code>.</p></li>
<li><p>All the objectives are printed if <cite>verbose=2</cite>, <code class="docutils literal notranslate"><span class="pre">pdhg.run(verbose=2)</span></code>.</p></li>
</ul>
<p>Computing these objectives can be costly, so it is better to compute every some iterations. To do this, use <code class="docutils literal notranslate"><span class="pre">update_objective_interval</span> <span class="pre">=</span> <span class="pre">#number</span></code>.</p>
</div>
<ul>
<li><p>PDHG algorithm can be accelerated if the functions <span class="math notranslate nohighlight">\(f^{*}\)</span> and/or <span class="math notranslate nohighlight">\(g\)</span> are strongly convex. In these cases, the step-sizes <span class="math notranslate nohighlight">\(\sigma\)</span> and <span class="math notranslate nohighlight">\(\tau\)</span> are updated using the <a class="reference internal" href="#cil.optimisation.algorithms.PDHG.update_step_sizes" title="cil.optimisation.algorithms.PDHG.update_step_sizes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update_step_sizes()</span></code></a> method. A function <span class="math notranslate nohighlight">\(f\)</span> is strongly convex with constant <span class="math notranslate nohighlight">\(\gamma&gt;0\)</span> if</p>
<div class="math notranslate nohighlight">
\[f(x) - \frac{\gamma}{2}\|x\|^{2} \quad\mbox{ is convex. }\]</div>
<ul class="simple">
<li><p>For instance the function <span class="math notranslate nohighlight">\(\frac{1}{2}\|x\|^{2}_{2}\)</span> is <span class="math notranslate nohighlight">\(\gamma\)</span> strongly convex for <span class="math notranslate nohighlight">\(\gamma\in(-\infty,1]\)</span>. We say it is 1-strongly convex because it is the largest constant for which <span class="math notranslate nohighlight">\(f - \frac{1}{2}\|\cdot\|^{2}\)</span> is convex.</p></li>
<li><p>The <span class="math notranslate nohighlight">\(\|\cdot\|_{1}\)</span> norm is not strongly convex. For more information, see <a class="reference external" href="https://en.wikipedia.org/wiki/Convex_function#Strongly_convex_functions">Strongly Convex</a>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(g\)</span> is strongly convex with constant <span class="math notranslate nohighlight">\(\gamma\)</span> then the step-sizes <span class="math notranslate nohighlight">\(\sigma\)</span>, <span class="math notranslate nohighlight">\(\tau\)</span> and <span class="math notranslate nohighlight">\(\theta\)</span> are updated as:</p></li>
</ul>
<div class="math notranslate nohighlight">
   \begin{aligned}

       \theta_{n} &amp; = \frac{1}{\sqrt{1 + 2\gamma\tau_{n}}}\\
       \tau_{n+1} &amp; = \theta_{n}\tau_{n}\\
       \sigma_{n+1} &amp; = \frac{\sigma_{n}}{\theta_{n}}

   \end{aligned}</div><ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(f^{*}\)</span> is strongly convex, we swap <span class="math notranslate nohighlight">\(\sigma\)</span> with <span class="math notranslate nohighlight">\(\tau\)</span>.</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The case where both functions are strongly convex is not available at the moment.</p>
</div>
<div class="admonition-todo admonition" id="id10">
<p class="admonition-title">Todo</p>
<p>Implement acceleration of PDHG when both functions are strongly convex.</p>
</div>
<dl class="py method">
<dt id="cil.optimisation.algorithms.PDHG.update">
<code class="sig-name descname"><span class="pre">update</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/PDHG.html#PDHG.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.update" title="Permalink to this definition">#</a></dt>
<dd><p>Performs a single iteration of the PDHG algorithm</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.PDHG.set_step_sizes">
<code class="sig-name descname"><span class="pre">set_step_sizes</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/PDHG.html#PDHG.set_step_sizes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.set_step_sizes" title="Permalink to this definition">#</a></dt>
<dd><p>Sets sigma and tau step-sizes for the PDHG algorithm. The step sizes can be either scalar or array-objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sigma</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, or <cite>np.ndarray</cite>, <cite>DataContainer</cite>, <cite>BlockDataContainer</cite>, optional, default=None) – Step size for the dual problem.</p></li>
<li><p><strong>tau</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, or <cite>np.ndarray</cite>, <cite>DataContainer</cite>, <cite>BlockDataContainer</cite>, optional, default=None) – Step size for the primal problem.</p></li>
</ul>
</dd>
</dl>
<p>The user can set either, both or none. Values passed by the user will be accepted as long as they are positive numbers,
or correct shape array like objects.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.PDHG.update_step_sizes">
<code class="sig-name descname"><span class="pre">update_step_sizes</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/PDHG.html#PDHG.update_step_sizes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.update_step_sizes" title="Permalink to this definition">#</a></dt>
<dd><p>Updates step sizes in the cases of primal or dual acceleration using the strongly convexity property. The case where both functions are strongly convex is not available at the moment.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.PDHG.update_objective">
<code class="sig-name descname"><span class="pre">update_objective</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/PDHG.html#PDHG.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.update_objective" title="Permalink to this definition">#</a></dt>
<dd><p>Evaluates the primal objective, the dual objective and the primal-dual gap.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.algorithms.LADMM">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></code><code class="sig-name descname"><span class="pre">LADMM</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/ADMM.html#LADMM"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.LADMM" title="Permalink to this definition">#</a></dt>
<dd><p>LADMM is the Linearized Alternating Direction Method of Multipliers (LADMM)</p>
<p>General form of ADMM : min_{x} f(x) + g(y), subject to Ax + By = b</p>
<p>Case: A = Id, B = -K, b = 0   ==&gt; min_x f(Kx) + g(x)</p>
<p>The quadratic term in the augmented Lagrangian is linearized for the x-update.</p>
<p>Main algorithmic difference is that in ADMM we compute two proximal subproblems,
where in the PDHG a proximal and proximal conjugate.</p>
<p>Reference (Section 8) : <a class="reference external" href="https://link.springer.com/content/pdf/10.1007/s10107-018-1321-1.pdf">https://link.springer.com/content/pdf/10.1007/s10107-018-1321-1.pdf</a></p>
<blockquote>
<div><p>x^{k} = prox_{      au f } (x^{k-1} - tau/sigma A^{T}(Ax^{k-1} - z^{k-1} + u^{k-1} )</p>
<p>z^{k} = prox_{sigma g} (Ax^{k} + u^{k-1})</p>
<p>u^{k} = u^{k-1} + Ax^{k} - z^{k}</p>
</div></blockquote>
<dl class="py method">
<dt id="cil.optimisation.algorithms.LADMM.set_up">
<code class="sig-name descname"><span class="pre">set_up</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/ADMM.html#LADMM.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.set_up" title="Permalink to this definition">#</a></dt>
<dd><p>Set up the algorithm</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.LADMM.update">
<code class="sig-name descname"><span class="pre">update</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/ADMM.html#LADMM.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.update" title="Permalink to this definition">#</a></dt>
<dd><p>A single iteration of the algorithm</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.LADMM.update_objective">
<code class="sig-name descname"><span class="pre">update_objective</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/ADMM.html#LADMM.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.update_objective" title="Permalink to this definition">#</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.algorithms.SPDHG">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></code><code class="sig-name descname"><span class="pre">SPDHG</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/SPDHG.html#SPDHG"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG" title="Permalink to this definition">#</a></dt>
<dd><p>Stochastic Primal Dual Hybrid Gradient</p>
<p>Problem:</p>
<div class="math notranslate nohighlight">
\[\min_{x} f(Kx) + g(x) = \min_{x} \sum f_i(K_i x) + g(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<a class="reference internal" href="#cil.optimisation.functions.BlockFunction" title="cil.optimisation.functions.BlockFunction"><em>BlockFunction</em></a>) – Each must be a convex function with a “simple” proximal method of its conjugate</p></li>
<li><p><strong>g</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – A convex function with a “simple” proximal</p></li>
<li><p><strong>operator</strong> (<a class="reference internal" href="#cil.optimisation.operators.BlockOperator" title="cil.optimisation.operators.BlockOperator"><em>BlockOperator</em></a>) – BlockOperator must contain Linear Operators</p></li>
<li><p><strong>tau</strong> (<em>positive float</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Step size parameter for Primal problem</p></li>
<li><p><strong>sigma</strong> (<em>list of positive float</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – List of Step size parameters for Dual problem</p></li>
<li><p><strong>initial</strong> (<a class="reference internal" href="framework.html#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Initial point for the SPDHG algorithm</p></li>
<li><p><strong>prob</strong> (<em>list of floats</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – List of probabilities. If None each subset will have probability = 1/number of subsets</p></li>
<li><p><strong>gamma</strong> (<em>float</em>) – parameter controlling the trade-off between the primal and dual step sizes</p></li>
<li><p><strong>**kwargs</strong> – </p></li>
<li><p><strong>norms</strong> (<em>list of floats</em>) – precalculated list of norms of the operators</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<p>Example of usage: See <a class="reference external" href="https://github.com/vais-ral/CIL-Demos/blob/master/Tomography/Simulated/Single%20Channel/PDHG_vs_SPDHG.py">https://github.com/vais-ral/CIL-Demos/blob/master/Tomography/Simulated/Single%20Channel/PDHG_vs_SPDHG.py</a></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Convergence is guaranted provided that [2, eq. (12)]:</p>
<div class="math notranslate nohighlight">
\[\]</div>
<p>|sigma[i]^{1/2} * K[i] * tau^{1/2} |^2  &lt; p_i for all i</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<dl class="simple">
<dt>Notation for primal and dual step-sizes are reversed with comparison</dt><dd><p>to PDGH.py</p>
</dd>
</dl>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<dl class="simple">
<dt>this code implements serial sampling only, as presented in [2]</dt><dd><p>(to be extended to more general case of [1] as future work)</p>
</dd>
</dl>
</div>
<p class="rubric">References</p>
<p>[1]”Stochastic primal-dual hybrid gradient algorithm with arbitrary
sampling and imaging applications”,
Chambolle, Antonin, Matthias J. Ehrhardt, Peter Richtárik, and Carola-Bibiane Schonlieb,
SIAM Journal on Optimization 28, no. 4 (2018): 2783-2808.</p>
<p>[2]”Faster PET reconstruction with non-smooth priors by randomization and preconditioning”,
Matthias J Ehrhardt, Pawel Markiewicz and Carola-Bibiane Schönlieb,
Physics in Medicine &amp; Biology, Volume 64, Number 22, 2019.</p>
<dl class="py method">
<dt id="cil.optimisation.algorithms.SPDHG.set_up">
<code class="sig-name descname"><span class="pre">set_up</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/SPDHG.html#SPDHG.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.set_up" title="Permalink to this definition">#</a></dt>
<dd><p>set-up of the algorithm
:param f: Each must be a convex function with a “simple” proximal method of its conjugate
:type f: BlockFunction
:param g: A convex function with a “simple” proximal
:type g: Function
:param operator: BlockOperator must contain Linear Operators
:type operator: BlockOperator
:param tau: Step size parameter for Primal problem
:type tau: positive float, optional, default=None
:param sigma: List of Step size parameters for Dual problem
:type sigma: list of positive float, optional, default=None
:param initial: Initial point for the SPDHG algorithm
:type initial: DataContainer, optional, default=None
:param prob: List of probabilities. If None each subset will have probability = 1/number of subsets
:type prob: list of floats, optional, default=None
:param gamma: parameter controlling the trade-off between the primal and dual step sizes
:type gamma: float
:param **kwargs:
:param norms: precalculated list of norms of the operators
:type norms: list of floats</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SPDHG.update">
<code class="sig-name descname"><span class="pre">update</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/SPDHG.html#SPDHG.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.update" title="Permalink to this definition">#</a></dt>
<dd><p>A single iteration of the algorithm</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SPDHG.update_objective">
<code class="sig-name descname"><span class="pre">update_objective</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/SPDHG.html#SPDHG.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.update_objective" title="Permalink to this definition">#</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SPDHG.objective">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">objective</span></code><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.objective" title="Permalink to this definition">#</a></dt>
<dd><p>alias of loss</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="operator">
<h2>Operator<a class="headerlink" href="#operator" title="Permalink to this headline">#</a></h2>
<p>The two most important methods are <code class="code docutils literal notranslate"><span class="pre">direct</span></code> and <code class="code docutils literal notranslate"><span class="pre">adjoint</span></code>
methods that describe the result of applying the operator, and its
adjoint respectively, onto a compatible <code class="code docutils literal notranslate"><span class="pre">DataContainer</span></code> input.
The output is another <code class="code docutils literal notranslate"><span class="pre">DataContainer</span></code> object or subclass
hereof. An important special case is to represent the tomographic
forward and backprojection operations.</p>
<div class="section" id="operator-base-classes">
<h3>Operator base classes<a class="headerlink" href="#operator-base-classes" title="Permalink to this headline">#</a></h3>
<p>All operators extend the <code class="code docutils literal notranslate"><span class="pre">Operator</span></code> class. A special class is the <code class="code docutils literal notranslate"><span class="pre">LinearOperator</span></code>
which represents an operator for which the <code class="code docutils literal notranslate"><span class="pre">adjoint</span></code> operation is defined.
A <code class="code docutils literal notranslate"><span class="pre">ScaledOperator</span></code> represents the multiplication of any operator with a scalar.</p>
<dl class="py class">
<dt id="cil.optimisation.operators.Operator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">Operator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator" title="Permalink to this definition">#</a></dt>
<dd><p>Operator that maps from a space X -&gt; Y</p>
<dl class="py method">
<dt id="cil.optimisation.operators.Operator.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> – domain of the operator</p></li>
<li><p><strong>range_geometry</strong> (<em>optional</em><em>, </em><em>default None</em>) – range of the operator</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.Operator.is_linear">
<code class="sig-name descname"><span class="pre">is_linear</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.is_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.is_linear" title="Permalink to this definition">#</a></dt>
<dd><p>Returns if the operator is linear</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.Operator.direct">
<code class="sig-name descname"><span class="pre">direct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the application of the Operator on x</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.Operator.norm">
<code class="sig-name descname"><span class="pre">norm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.norm" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the norm of the Operator. On first call the norm will be calculated using the operator’s calculate_norm
method. Subsequent calls will return the cached norm.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>norm</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>positive:<cite>float</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.Operator.set_norm">
<code class="sig-name descname"><span class="pre">set_norm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.set_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.set_norm" title="Permalink to this definition">#</a></dt>
<dd><p>Sets the norm of the operator to a custom value.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.Operator.calculate_norm">
<code class="sig-name descname"><span class="pre">calculate_norm</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.calculate_norm" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the norm of the Operator</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.Operator.range_geometry">
<code class="sig-name descname"><span class="pre">range_geometry</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.range_geometry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.range_geometry" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the range of the Operator: Y space</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.Operator.domain_geometry">
<code class="sig-name descname"><span class="pre">domain_geometry</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.domain_geometry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.domain_geometry" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the domain of the Operator: X space</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.Operator.__rmul__">
<code class="sig-name descname"><span class="pre">__rmul__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scalar</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.__rmul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.__rmul__" title="Permalink to this definition">#</a></dt>
<dd><p>Defines the multiplication by a scalar on the left</p>
<p>returns a ScaledOperator</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.Operator.__neg__">
<code class="sig-name descname"><span class="pre">__neg__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.__neg__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.__neg__" title="Permalink to this definition">#</a></dt>
<dd><p>Return -self</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.Operator.__sub__">
<code class="sig-name descname"><span class="pre">__sub__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.__sub__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.__sub__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the subtraction of the operators.</p>
</dd></dl>

<dl class="py attribute">
<dt id="cil.optimisation.operators.Operator.__weakref__">
<code class="sig-name descname"><span class="pre">__weakref__</span></code><a class="headerlink" href="#cil.optimisation.operators.Operator.__weakref__" title="Permalink to this definition">#</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.operators.LinearOperator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">LinearOperator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#LinearOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator" title="Permalink to this definition">#</a></dt>
<dd><p>A Linear Operator that maps from a space X &lt;-&gt; Y</p>
<dl class="py method">
<dt id="cil.optimisation.operators.LinearOperator.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#LinearOperator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> – domain of the operator</p></li>
<li><p><strong>range_geometry</strong> (<em>optional</em><em>, </em><em>default None</em>) – range of the operator</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.LinearOperator.is_linear">
<code class="sig-name descname"><span class="pre">is_linear</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#LinearOperator.is_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator.is_linear" title="Permalink to this definition">#</a></dt>
<dd><p>Returns if the operator is linear</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.LinearOperator.adjoint">
<code class="sig-name descname"><span class="pre">adjoint</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#LinearOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>returns the adjoint/inverse operation</p>
<p>only available to linear operators</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.LinearOperator.PowerMethod">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">PowerMethod</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iteration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">deprecated_args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#LinearOperator.PowerMethod"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator.PowerMethod" title="Permalink to this definition">#</a></dt>
<dd><p>Power method or Power iteration algorithm</p>
<p>The Power method computes the largest (dominant) eigenvalue of a square matrix in magnitude, e.g.,
absolute value in the real case and module in the complex case.
For the non-square case, the power method is applied for the matrix :math: A^{T}*A.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> (<a class="reference internal" href="#cil.optimisation.operators.LinearOperator" title="cil.optimisation.operators.LinearOperator"><em>LinearOperator</em></a>) – </p></li>
<li><p><strong>max_iteration</strong> (positive:<cite>int</cite>, default=10) – Number of iterations for the Power method algorithm.</p></li>
<li><p><strong>initial</strong> (<a class="reference internal" href="framework.html#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>default = None</em>) – Starting point for the Power method.</p></li>
<li><p><strong>tolerance</strong> (positive:<cite>float</cite>, default = 1e-5) – Stopping criterion for the Power method. Check if two consecutive eigenvalue evaluations are below the tolerance.</p></li>
<li><p><strong>return_all</strong> (<em>boolean</em><em>, </em><em>default = False</em>) – Toggles the verbosity of the return</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>dominant eigenvalue</strong> (positive:<cite>float</cite>)</p></li>
<li><p><strong>number of iterations</strong> (positive:<cite>int</cite>) – Number of iterations run. Only returned if return_all is True.</p></li>
<li><p><strong>eigenvector</strong> (<em>DataContainer</em>) – Corresponding eigenvector of the dominant eigenvalue. Only returned if return_all is True.</p></li>
<li><p><strong>list of eigenvalues</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code>) – List of eigenvalues. Only returned if return_all is True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Mop</span> <span class="o">=</span> <span class="n">MatrixOperator</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Mop_norm</span> <span class="o">=</span> <span class="n">Mop</span><span class="o">.</span><span class="n">PowerMethod</span><span class="p">(</span><span class="n">Mop</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Mop_norm</span>
<span class="go">2.0000654846240296</span>
</pre></div>
</div>
<p><cite>PowerMethod</cite> is called when we compute the norm of a matrix or a <cite>LinearOperator</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Mop_norm</span> <span class="o">=</span> <span class="n">Mop</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
<span class="go">2.0005647295658866</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.LinearOperator.calculate_norm">
<code class="sig-name descname"><span class="pre">calculate_norm</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#LinearOperator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator.calculate_norm" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the norm of the LinearOperator calculated by the PowerMethod with default values.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.LinearOperator.dot_test">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">dot_test</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#LinearOperator.dot_test"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator.dot_test" title="Permalink to this definition">#</a></dt>
<dd><p>Does a dot linearity test on the operator</p>
<p>Evaluates if the following equivalence holds</p>
<div class="math notranslate nohighlight">
\[Ax\times y = y \times A^Tx\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> – operator to test the dot_test</p></li>
<li><p><strong>range_init</strong> – optional initialisation container in the operator range</p></li>
<li><p><strong>domain_init</strong> – optional initialisation container in the operator domain</p></li>
<li><p><strong>seed</strong> – Seed random generator</p></li>
</ul>
</dd>
</dl>
<p>:type : int, default = 1
:param tolerance: Check if the following expression is below the tolerance
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span><span class="n">Ax</span>\<span class="n">times</span> <span class="n">y</span> <span class="o">-</span> <span class="n">y</span> \<span class="n">times</span> <span class="n">A</span><span class="o">^</span><span class="n">Tx</span><span class="o">|/</span><span class="p">(</span>\<span class="o">|</span><span class="n">A</span>\<span class="o">|</span>\<span class="o">|</span><span class="n">x</span>\<span class="o">|</span>\<span class="o">|</span><span class="n">y</span>\<span class="o">|</span> <span class="o">+</span> <span class="mf">1e-12</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tolerance</span>
</pre></div>
</div>
<p>:type : float, default 1e-6
:returns: boolean, True if the test is passed.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.operators.ScaledOperator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">ScaledOperator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalar</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#ScaledOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ScaledOperator" title="Permalink to this definition">#</a></dt>
<dd><p>A class to represent the scalar multiplication of an Operator with a scalar.
It holds an operator and a scalar. Basically it returns the multiplication
of the result of direct and adjoint of the operator with the scalar.
For the rest it behaves like the operator it holds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> – a Operator or LinearOperator</p></li>
<li><p><strong>scalar</strong> – a scalar multiplier</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<p>The scaled operator behaves like the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sop</span> <span class="o">=</span> <span class="n">ScaledOperator</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">scalar</span><span class="p">)</span>
<span class="n">sop</span><span class="o">.</span><span class="n">direct</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">scalar</span> <span class="o">*</span> <span class="n">operator</span><span class="o">.</span><span class="n">direct</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">sop</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">scalar</span> <span class="o">*</span> <span class="n">operator</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">sop</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
<span class="n">sop</span><span class="o">.</span><span class="n">range_geometry</span><span class="p">()</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">range_geometry</span><span class="p">()</span>
<span class="n">sop</span><span class="o">.</span><span class="n">domain_geometry</span><span class="p">()</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">domain_geometry</span><span class="p">()</span>
</pre></div>
</div>
<dl class="py method">
<dt id="cil.optimisation.operators.ScaledOperator.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalar</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#ScaledOperator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ScaledOperator.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> – a Operator or LinearOperator</p></li>
<li><p><strong>scalar</strong> (<em>Number</em>) – a scalar multiplier</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.ScaledOperator.direct">
<code class="sig-name descname"><span class="pre">direct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#ScaledOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ScaledOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>direct method</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.ScaledOperator.adjoint">
<code class="sig-name descname"><span class="pre">adjoint</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#ScaledOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ScaledOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>adjoint method</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.ScaledOperator.norm">
<code class="sig-name descname"><span class="pre">norm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#ScaledOperator.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ScaledOperator.norm" title="Permalink to this definition">#</a></dt>
<dd><p>norm of the operator</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.ScaledOperator.is_linear">
<code class="sig-name descname"><span class="pre">is_linear</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#ScaledOperator.is_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ScaledOperator.is_linear" title="Permalink to this definition">#</a></dt>
<dd><p>returns whether the operator is linear</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>boolean</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.operators.CompositionOperator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">CompositionOperator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">operators</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#CompositionOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.CompositionOperator" title="Permalink to this definition">#</a></dt>
<dd><dl class="py method">
<dt id="cil.optimisation.operators.CompositionOperator.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">operators</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#CompositionOperator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.CompositionOperator.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> – domain of the operator</p></li>
<li><p><strong>range_geometry</strong> (<em>optional</em><em>, </em><em>default None</em>) – range of the operator</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.CompositionOperator.direct">
<code class="sig-name descname"><span class="pre">direct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#CompositionOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.CompositionOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the application of the Operator on x</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.CompositionOperator.is_linear">
<code class="sig-name descname"><span class="pre">is_linear</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#CompositionOperator.is_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.CompositionOperator.is_linear" title="Permalink to this definition">#</a></dt>
<dd><p>Returns if the operator is linear</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.operators.DiagonalOperator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">DiagonalOperator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diagonal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/DiagonalOperator.html#DiagonalOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.DiagonalOperator" title="Permalink to this definition">#</a></dt>
<dd><p>Performs an element-wise multiplication, i.e., <a class="reference external" href="https://en.wikipedia.org/wiki/Hadamard_product_(matrices)#:~:text=In%20mathematics%2C%20the%20Hadamard%20product,elements%20i%2C%20j%20of%20the">Hadamard Product</a>
of a <code class="xref py py-class docutils literal notranslate"><span class="pre">DataContainer</span></code> <cite>x</cite> and <code class="xref py py-class docutils literal notranslate"><span class="pre">DataContainer</span></code> <cite>diagonal</cite>, <cite>d</cite> .</p>
<div class="math notranslate nohighlight">
\[(D\circ x) = \sum_{i,j}^{M,N} D_{i,j} x_{i, j}\]</div>
<p>In matrix-vector interpretation, if <cite>D</cite> is a <span class="math notranslate nohighlight">\(M\times N\)</span> dense matrix and is flattened, we have a <span class="math notranslate nohighlight">\(M*N \times M*N\)</span> vector.
A sparse diagonal matrix, i.e., <code class="xref py py-class docutils literal notranslate"><span class="pre">DigaonalOperator</span></code> can be created if we add the vector above to the main diagonal.
If the <code class="xref py py-class docutils literal notranslate"><span class="pre">DataContainer</span></code> <cite>x</cite> is also flattened, we have a <span class="math notranslate nohighlight">\(M*N\)</span> vector.
Now, matrix-vector multiplcation is allowed and results to a <span class="math notranslate nohighlight">\((M*N,1)\)</span> vector. After reshaping we recover a <span class="math notranslate nohighlight">\(M\times N\)</span> <code class="xref py py-class docutils literal notranslate"><span class="pre">DataContainer</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>diagonal</strong> (<a class="reference internal" href="framework.html#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – DataContainer with the same dimensions as the data to be operated on.</p></li>
<li><p><strong>domain_geometry</strong> (<a class="reference internal" href="framework.html#cil.framework.ImageGeometry" title="cil.framework.ImageGeometry"><em>ImageGeometry</em></a>) – Specifies the geometry of the operator domain. If ‘None’ will use the diagonal geometry directly. default=None .</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="cil.optimisation.operators.DiagonalOperator.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diagonal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/DiagonalOperator.html#DiagonalOperator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.DiagonalOperator.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> – domain of the operator</p></li>
<li><p><strong>range_geometry</strong> (<em>optional</em><em>, </em><em>default None</em>) – range of the operator</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.DiagonalOperator.direct">
<code class="sig-name descname"><span class="pre">direct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/DiagonalOperator.html#DiagonalOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.DiagonalOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(D\circ x\)</span></p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.DiagonalOperator.adjoint">
<code class="sig-name descname"><span class="pre">adjoint</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/DiagonalOperator.html#DiagonalOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.DiagonalOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(D\circ x\)</span></p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.DiagonalOperator.calculate_norm">
<code class="sig-name descname"><span class="pre">calculate_norm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/DiagonalOperator.html#DiagonalOperator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.DiagonalOperator.calculate_norm" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the operator norm of DiagonalOperator which is the maximum element in the <cite>diagonal</cite>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.operators.ChannelwiseOperator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">ChannelwiseOperator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'prepend'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ChannelwiseOperator.html#ChannelwiseOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ChannelwiseOperator" title="Permalink to this definition">#</a></dt>
<dd><p>ChannelwiseOperator:  takes in a single-channel operator op and the
number of channels to be used, and creates a new multi-channel
ChannelwiseOperator, which will apply the operator op independently on
each channel for the number of channels specified.</p>
<p>ChannelwiseOperator supports simple operators as input but not
BlockOperators. Typically if such behaviour is desired, it can be achieved
by creating instead a BlockOperator of ChannelwiseOperators.</p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">param op</dt>
<dd class="field-odd"><p>Single-channel operator</p>
</dd>
<dt class="field-even">param channels</dt>
<dd class="field-even"><p>Number of channels</p>
</dd>
<dt class="field-odd">param dimension</dt>
<dd class="field-odd"><p>‘prepend’ (default) or ‘append’ channel dimension onto existing dimensions</p>
</dd>
</dl>
</div></blockquote>
<dl class="py method">
<dt id="cil.optimisation.operators.ChannelwiseOperator.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'prepend'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ChannelwiseOperator.html#ChannelwiseOperator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ChannelwiseOperator.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> – domain of the operator</p></li>
<li><p><strong>range_geometry</strong> (<em>optional</em><em>, </em><em>default None</em>) – range of the operator</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.ChannelwiseOperator.direct">
<code class="sig-name descname"><span class="pre">direct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ChannelwiseOperator.html#ChannelwiseOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ChannelwiseOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns D(x)</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.ChannelwiseOperator.adjoint">
<code class="sig-name descname"><span class="pre">adjoint</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ChannelwiseOperator.html#ChannelwiseOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ChannelwiseOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>Returns D^{*}(y)</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.ChannelwiseOperator.calculate_norm">
<code class="sig-name descname"><span class="pre">calculate_norm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ChannelwiseOperator.html#ChannelwiseOperator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ChannelwiseOperator.calculate_norm" title="Permalink to this definition">#</a></dt>
<dd><p>Evaluates operator norm of DiagonalOperator</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="trivial-operators">
<h3>Trivial operators<a class="headerlink" href="#trivial-operators" title="Permalink to this headline">#</a></h3>
<p>Trivial operators are the following.</p>
<dl class="py class">
<dt id="cil.optimisation.operators.IdentityOperator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">IdentityOperator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/IdentityOperator.html#IdentityOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.IdentityOperator" title="Permalink to this definition">#</a></dt>
<dd><p>IdentityOperator:  Id: X -&gt; Y,  Id(x) = xin Y</p>
<p>X : gm_domain
Y : gm_range ( Default: Y = X )</p>
<dl class="py method">
<dt id="cil.optimisation.operators.IdentityOperator.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/IdentityOperator.html#IdentityOperator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.IdentityOperator.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> – domain of the operator</p></li>
<li><p><strong>range_geometry</strong> (<em>optional</em><em>, </em><em>default None</em>) – range of the operator</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.IdentityOperator.direct">
<code class="sig-name descname"><span class="pre">direct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/IdentityOperator.html#IdentityOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.IdentityOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns Id(x)</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.IdentityOperator.adjoint">
<code class="sig-name descname"><span class="pre">adjoint</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/IdentityOperator.html#IdentityOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.IdentityOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>Returns Id(x)</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.IdentityOperator.calculate_norm">
<code class="sig-name descname"><span class="pre">calculate_norm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/IdentityOperator.html#IdentityOperator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.IdentityOperator.calculate_norm" title="Permalink to this definition">#</a></dt>
<dd><p>Evaluates operator norm of IdentityOperator</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.operators.ZeroOperator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">ZeroOperator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ZeroOperator.html#ZeroOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ZeroOperator" title="Permalink to this definition">#</a></dt>
<dd><p>ZeroOperator:  O: X -&gt; Y,  maps any element of <span class="math notranslate nohighlight">\(x\in X\)</span> into the zero element <span class="math notranslate nohighlight">\(\in Y,  O(x) = O_{Y}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gm_domain</strong> – domain of the operator</p></li>
<li><p><strong>gm_range</strong> – range of the operator, default: same as domain</p></li>
</ul>
</dd>
</dl>
<p>Note:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}O^{*}: Y^{*} -&gt; X^{*} \text{(Adjoint)}\\&lt; O(x), y &gt; = &lt; x, O^{*}(y) &gt;\end{aligned}\end{align} \]</div>
<dl class="py method">
<dt id="cil.optimisation.operators.ZeroOperator.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ZeroOperator.html#ZeroOperator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ZeroOperator.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> – domain of the operator</p></li>
<li><p><strong>range_geometry</strong> (<em>optional</em><em>, </em><em>default None</em>) – range of the operator</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.ZeroOperator.direct">
<code class="sig-name descname"><span class="pre">direct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ZeroOperator.html#ZeroOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ZeroOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns O(x)</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.ZeroOperator.adjoint">
<code class="sig-name descname"><span class="pre">adjoint</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ZeroOperator.html#ZeroOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ZeroOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>Returns O^{*}(y)</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.ZeroOperator.calculate_norm">
<code class="sig-name descname"><span class="pre">calculate_norm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ZeroOperator.html#ZeroOperator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ZeroOperator.calculate_norm" title="Permalink to this definition">#</a></dt>
<dd><p>Evaluates operator norm of ZeroOperator</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.operators.MatrixOperator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">MatrixOperator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/MatrixOperator.html#MatrixOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.MatrixOperator" title="Permalink to this definition">#</a></dt>
<dd><p>Matrix wrapped into a LinearOperator</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>a numpy matrix</p>
</dd>
</dl>
<dl class="py method">
<dt id="cil.optimisation.operators.MatrixOperator.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/MatrixOperator.html#MatrixOperator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.MatrixOperator.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>A</strong> – numpy ndarray representing a matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.MatrixOperator.direct">
<code class="sig-name descname"><span class="pre">direct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/MatrixOperator.html#MatrixOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.MatrixOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the application of the Operator on x</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.MatrixOperator.adjoint">
<code class="sig-name descname"><span class="pre">adjoint</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/MatrixOperator.html#MatrixOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.MatrixOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>returns the adjoint/inverse operation</p>
<p>only available to linear operators</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.operators.MaskOperator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">MaskOperator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/MaskOperator.html#MaskOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.MaskOperator" title="Permalink to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mask</strong> (<a class="reference internal" href="framework.html#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – Boolean array with the same dimensions as the data to be operated on.</p></li>
<li><p><strong>domain_geometry</strong> (<a class="reference internal" href="framework.html#cil.framework.ImageGeometry" title="cil.framework.ImageGeometry"><em>ImageGeometry</em></a>) – Specifies the geometry of the operator domain. If ‘None’ will use the mask geometry size and spacing as float32. default = None .</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="cil.optimisation.operators.MaskOperator.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/MaskOperator.html#MaskOperator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.MaskOperator.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> – domain of the operator</p></li>
<li><p><strong>range_geometry</strong> (<em>optional</em><em>, </em><em>default None</em>) – range of the operator</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="gradientoperator">
<h3>GradientOperator<a class="headerlink" href="#gradientoperator" title="Permalink to this headline">#</a></h3>
<p>In the following the required classes for the implementation of the <code class="code docutils literal notranslate"><span class="pre">GradientOperator</span></code> operator.</p>
<dl class="py class">
<dt id="cil.optimisation.operators.GradientOperator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">GradientOperator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'forward'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bnd_cond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Neumann'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/GradientOperator.html#GradientOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.GradientOperator" title="Permalink to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Gradient Operator: Computes first-order forward/backward differences on</dt><dd><p>2D, 3D, 4D ImageData under Neumann/Periodic boundary conditions</p>
</dd>
</dl>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gm_domain</strong> (<cite>ImageGeometry</cite>) – Set up the domain of the function</p></li>
<li><p><strong>bnd_cond</strong> (<em>str</em><em>, </em><em>optional</em>) – Set the boundary conditions to use ‘Neumann’ or ‘Periodic’, defaults to ‘Neumann’</p></li>
<li><p><strong>**kwargs</strong> – See below</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>returns a BlockDataContainer containing images of the derivatives order given by <cite>dimension_labels</cite>i.e. [‘horizontal_y’,’horizontal_x’] will return [d(‘horizontal_y’), d(‘horizontal_x’)]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer">BlockDataContainer</a></p>
</dd>
<dt class="field-even">Keyword Arguments</dt>
<dd class="field-even"><ul class="simple">
<li><p><em>correlation</em> (<code class="docutils literal notranslate"><span class="pre">str</span></code>) –
‘Space’ or ‘SpaceChannels’, defaults to ‘Space’</p></li>
<li><p><em>backend</em> (<code class="docutils literal notranslate"><span class="pre">str</span></code>) –
‘c’ or ‘numpy’, defaults to ‘c’ if correlation is ‘SpaceChannels’ or channels = 1</p></li>
<li><p><em>num_threads</em> (<code class="docutils literal notranslate"><span class="pre">int</span></code>) –
If backend is ‘c’ specify the number of threads to use. Default is number of cpus/2</p></li>
<li><p><em>split</em> (<code class="docutils literal notranslate"><span class="pre">boolean</span></code>) –
If ‘True’, and backend ‘C’ will return a BlockDataContainer with grouped spatial domains. i.e. [Channel, [Z, Y, X]], otherwise [Channel, Z, Y, X]</p></li>
</ul>
<p>Example (2D):
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>\<span class="n">nabla</span> <span class="p">:</span> <span class="n">X</span> <span class="o">-&gt;</span> <span class="n">Y</span> \\
<span class="n">u</span>\<span class="ow">in</span> <span class="n">X</span><span class="p">,</span> \<span class="n">nabla</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span>\<span class="n">partial_</span><span class="p">{</span><span class="n">y</span><span class="p">}</span> <span class="n">u</span><span class="p">,</span> \<span class="n">partial_</span><span class="p">{</span><span class="n">x</span><span class="p">}</span> <span class="n">u</span><span class="p">]</span> \\
<span class="n">u</span><span class="o">^</span><span class="p">{</span><span class="o">*</span><span class="p">}</span>\<span class="ow">in</span> <span class="n">Y</span><span class="p">,</span> \<span class="n">nabla</span><span class="o">^</span><span class="p">{</span><span class="o">*</span><span class="p">}(</span><span class="n">u</span><span class="o">^</span><span class="p">{</span><span class="o">*</span><span class="p">})</span> <span class="o">=</span> \<span class="n">partial_</span><span class="p">{</span><span class="n">y</span><span class="p">}</span> <span class="n">v1</span> <span class="o">+</span> \<span class="n">partial_</span><span class="p">{</span><span class="n">x</span><span class="p">}</span> <span class="n">v2</span>
</pre></div>
</div>
</dd>
</dl>
<dl class="py method">
<dt id="cil.optimisation.operators.GradientOperator.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'forward'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bnd_cond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Neumann'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/GradientOperator.html#GradientOperator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.GradientOperator.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Constructor method</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.GradientOperator.direct">
<code class="sig-name descname"><span class="pre">direct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/GradientOperator.html#GradientOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.GradientOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the first-order forward differences</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<cite>ImageData</cite>) – Image data</p></li>
<li><p><strong>out</strong> (<cite>BlockDataContainer</cite>, optional) – pre-allocated output memory to store result</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>result data if not passed as parameter</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>BlockDataContainer</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.GradientOperator.adjoint">
<code class="sig-name descname"><span class="pre">adjoint</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/GradientOperator.html#GradientOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.GradientOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the first-order backward differences</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<cite>BlockDataContainer</cite>) – Gradient images for each dimension in ImageGeometry domain</p></li>
<li><p><strong>out</strong> (<cite>ImageData</cite>, optional) – pre-allocated output memory to store result</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>result data if not passed as parameter</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><cite>ImageData</cite></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.operators.FiniteDifferenceOperator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">FiniteDifferenceOperator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'forward'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bnd_cond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Neumann'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/FiniteDifferenceOperator.html#FiniteDifferenceOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.FiniteDifferenceOperator" title="Permalink to this definition">#</a></dt>
<dd><p>Computes forward/backward/centered finite differences of a DataContainer
under Neumann/Periodic boundary conditions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> – Domain geometry for the FiniteDifferenceOperator</p></li>
<li><p><strong>direction</strong> (<em>string label from domain geometry</em><em> or </em><em>integer number</em>) – Direction to evaluate finite differences</p></li>
<li><p><strong>method</strong> (<em>'forward'</em><em>, </em><em>'backward'</em><em>, </em><em>'centered'</em>) – Method for finite differences</p></li>
<li><p><strong>bnd_cond</strong> – ‘Neumann’, ‘Periodic’</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="cil.optimisation.operators.FiniteDifferenceOperator.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'forward'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bnd_cond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Neumann'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/FiniteDifferenceOperator.html#FiniteDifferenceOperator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.FiniteDifferenceOperator.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> – domain of the operator</p></li>
<li><p><strong>range_geometry</strong> (<em>optional</em><em>, </em><em>default None</em>) – range of the operator</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.FiniteDifferenceOperator.direct">
<code class="sig-name descname"><span class="pre">direct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/FiniteDifferenceOperator.html#FiniteDifferenceOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.FiniteDifferenceOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the application of the Operator on x</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.FiniteDifferenceOperator.adjoint">
<code class="sig-name descname"><span class="pre">adjoint</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/FiniteDifferenceOperator.html#FiniteDifferenceOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.FiniteDifferenceOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>returns the adjoint/inverse operation</p>
<p>only available to linear operators</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.operators.SparseFiniteDifferenceOperator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">SparseFiniteDifferenceOperator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bnd_cond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Neumann'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/SparseFiniteDifferenceOperator.html#SparseFiniteDifferenceOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SparseFiniteDifferenceOperator" title="Permalink to this definition">#</a></dt>
<dd><p>Create Sparse Matrices for the Finite Difference Operator</p>
<dl class="py method">
<dt id="cil.optimisation.operators.SparseFiniteDifferenceOperator.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bnd_cond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Neumann'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/SparseFiniteDifferenceOperator.html#SparseFiniteDifferenceOperator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SparseFiniteDifferenceOperator.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> – domain of the operator</p></li>
<li><p><strong>range_geometry</strong> (<em>optional</em><em>, </em><em>default None</em>) – range of the operator</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.SparseFiniteDifferenceOperator.direct">
<code class="sig-name descname"><span class="pre">direct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/SparseFiniteDifferenceOperator.html#SparseFiniteDifferenceOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SparseFiniteDifferenceOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the application of the Operator on x</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.operators.SymmetrisedGradientOperator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">SymmetrisedGradientOperator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bnd_cond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Neumann'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/SymmetrisedGradientOperator.html#SymmetrisedGradientOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SymmetrisedGradientOperator" title="Permalink to this definition">#</a></dt>
<dd><p>Symmetrized Gradient Operator:  E: V -&gt; W</p>
<p>V : range of the Gradient Operator
W : range of the Symmetrized Gradient</p>
<p>Example (2D):</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}v = (v1, v2) \\\end{split}\\\begin{split}Ev = 0.5 * ( \nabla\cdot v + (\nabla\cdot c)^{T} ) \\\end{split}\\\begin{split}\begin{matrix}
    \partial_{y} v1 &amp; 0.5 * (\partial_{x} v1 + \partial_{y} v2) \\
    0.5 * (\partial_{x} v1 + \partial_{y} v2) &amp; \partial_{x} v2
\end{matrix}\end{split}\end{aligned}\end{align} \]</div>
<dl class="py method">
<dt id="cil.optimisation.operators.SymmetrisedGradientOperator.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bnd_cond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Neumann'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/SymmetrisedGradientOperator.html#SymmetrisedGradientOperator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SymmetrisedGradientOperator.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> – domain of the operator</p></li>
<li><p><strong>bnd_cond</strong> (str, optional, default <code class="code docutils literal notranslate"><span class="pre">Neumann</span></code>) – boundary condition, either <code class="code docutils literal notranslate"><span class="pre">Neumann</span></code> or <code class="code docutils literal notranslate"><span class="pre">Periodic</span></code>.</p></li>
<li><p><strong>correlation</strong> (str, optional, default <code class="code docutils literal notranslate"><span class="pre">Channel</span></code>) – <code class="code docutils literal notranslate"><span class="pre">SpaceChannel</span></code> or <code class="code docutils literal notranslate"><span class="pre">Channel</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.SymmetrisedGradientOperator.direct">
<code class="sig-name descname"><span class="pre">direct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/SymmetrisedGradientOperator.html#SymmetrisedGradientOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SymmetrisedGradientOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns E(v)</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.SymmetrisedGradientOperator.adjoint">
<code class="sig-name descname"><span class="pre">adjoint</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/SymmetrisedGradientOperator.html#SymmetrisedGradientOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SymmetrisedGradientOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>returns the adjoint/inverse operation</p>
<p>only available to linear operators</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="function">
<h2>Function<a class="headerlink" href="#function" title="Permalink to this headline">#</a></h2>
<p>A <code class="code docutils literal notranslate"><span class="pre">Function</span></code> represents a mathematical function of one or more inputs
and is intended to accept <code class="code docutils literal notranslate"><span class="pre">DataContainers</span></code> as input as well as any
additional parameters.</p>
<p>Fixed parameters can be passed in during the creation of the function object.
The methods of the function reflect the properties of it, for example, if the function
represented is differentiable the function should contain a method <code class="code docutils literal notranslate"><span class="pre">gradient</span></code>
which should return the gradient of the function evaluated at an input point.
If the function is not differentiable but allows a simple proximal operator,
the method <code class="code docutils literal notranslate"><span class="pre">proximal</span></code> should return the proximal operator evaluated at an
input point. The function value is evaluated by calling the function itself,
e.g. <code class="code docutils literal notranslate"><span class="pre">f(x)</span></code> for a <code class="code docutils literal notranslate"><span class="pre">Function</span> <span class="pre">f</span></code> and input point <code class="code docutils literal notranslate"><span class="pre">x</span></code>.</p>
<div class="section" id="base-classes">
<h3>Base classes<a class="headerlink" href="#base-classes" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.functions.Function">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">Function</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">L</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function" title="Permalink to this definition">#</a></dt>
<dd><p>Abstract class representing a function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>L</strong> (<em>number</em><em>, </em><em>positive</em><em>, </em><em>default None</em>) – Lipschitz constant of the gradient of the function F(x), when it is differentiable.</p></li>
<li><p><strong>domain</strong> – The domain of the function.</p></li>
</ul>
</dd>
</dl>
<p>Lipschitz of the gradient of the function; it is a positive real number, such that <a href="#id22"><span class="problematic" id="id23">|f'(x) - f'(y)|</span></a> &lt;= L ||x-y||, assuming f: IG –&gt; R</p>
<dl class="py method">
<dt id="cil.optimisation.functions.Function.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">L</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.Function.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the function F at x: <span class="math notranslate nohighlight">\(F(x)\)</span></p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.Function.gradient">
<code class="sig-name descname"><span class="pre">gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of function F at x, if it is differentiable</p>
<div class="math notranslate nohighlight">
\[F'(x)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.Function.proximal">
<code class="sig-name descname"><span class="pre">proximal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of function <span class="math notranslate nohighlight">\(\tau F\)</span> at x
.. math:: mathrm{prox}_{tau F}(x) = underset{z}{mathrm{argmin}} frac{1}{2}|z - x|^{2} + tau F(z)</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.Function.convex_conjugate">
<code class="sig-name descname"><span class="pre">convex_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the convex conjugate of function <span class="math notranslate nohighlight">\(F\)</span> at <span class="math notranslate nohighlight">\(x^{*}\)</span>,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x^{*}}{\sup} &lt;x^{*}, x&gt; - F(x)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.Function.proximal_conjugate">
<code class="sig-name descname"><span class="pre">proximal_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.proximal_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.proximal_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\mathrm{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F^{*}}(x) = x - \tau\mathrm{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.Function.__add__">
<code class="sig-name descname"><span class="pre">__add__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.__add__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.__add__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the sum of the functions.</p>
<dl class="simple">
<dt>Cases: a) the sum of two functions <span class="math notranslate nohighlight">\((F_{1}+F_{2})(x) = F_{1}(x) + F_{2}(x)\)</span></dt><dd><ol class="loweralpha simple" start="2">
<li><p>the sum of a function with a scalar <span class="math notranslate nohighlight">\((F_{1}+scalar)(x) = F_{1}(x) + scalar\)</span></p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.Function.__radd__">
<code class="sig-name descname"><span class="pre">__radd__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.__radd__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.__radd__" title="Permalink to this definition">#</a></dt>
<dd><p>Making addition commutative.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.Function.__sub__">
<code class="sig-name descname"><span class="pre">__sub__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.__sub__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.__sub__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the subtraction of the functions.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.Function.__rmul__">
<code class="sig-name descname"><span class="pre">__rmul__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scalar</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.__rmul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.__rmul__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a function multiplied by a scalar.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.Function.centered_at">
<code class="sig-name descname"><span class="pre">centered_at</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.centered_at"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.centered_at" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.
TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.Function.L">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">L</span></code><a class="headerlink" href="#cil.optimisation.functions.Function.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <a href="#id24"><span class="problematic" id="id25">|f'(x) - f'(y)|</span></a> &lt;= L ||x-y||, assuming f: IG –&gt; R</p>
</dd></dl>

<dl class="py attribute">
<dt id="cil.optimisation.functions.Function.__weakref__">
<code class="sig-name descname"><span class="pre">__weakref__</span></code><a class="headerlink" href="#cil.optimisation.functions.Function.__weakref__" title="Permalink to this definition">#</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.functions.SumFunction">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">SumFunction</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">functions</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#SumFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SumFunction" title="Permalink to this definition">#</a></dt>
<dd><p>SumFunction represents the sum of <span class="math notranslate nohighlight">\(n\geq2\)</span> functions</p>
<div class="math notranslate nohighlight">
\[(F_{1} + F_{2} + ... + F_{n})(\cdot)  = F_{1}(\cdot) + F_{2}(\cdot) + ... + F_{n}(\cdot)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>*functions</strong> (<em>Functions</em>) – Functions to set up a <a class="reference internal" href="#cil.optimisation.functions.SumFunction" title="cil.optimisation.functions.SumFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">SumFunction</span></code></a></p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the number of function is strictly less than 2.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="math notranslate nohighlight">
\[F(x) = \|x\|^{2} + \frac{1}{2}\|x - 1\|^{2}\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cil.optimisation.functions</span> <span class="kn">import</span> <span class="n">L2NormSquared</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cil.framework</span> <span class="kn">import</span> <span class="n">ImageGeometry</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">L2NormSquared</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">L2NormSquared</span><span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">SumFunction</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">)</span>
</pre></div>
</div>
<div class="math notranslate nohighlight">
\[F(x) = \sum_{i=1}^{50} \|x - i\|^{2}\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">SumFunction</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">L2NormSquared</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">)])</span>
</pre></div>
</div>
<dl class="py method">
<dt id="cil.optimisation.functions.SumFunction.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">functions</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#SumFunction.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SumFunction.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.SumFunction.L">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">L</span></code><a class="headerlink" href="#cil.optimisation.functions.SumFunction.L" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the Lipschitz constant for the SumFunction</p>
<div class="math notranslate nohighlight">
\[L = \sum_{i} L_{i}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{i}\)</span> is the Lipschitz constant of the smooth function <span class="math notranslate nohighlight">\(F_{i}\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.SumFunction.Lmax">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">Lmax</span></code><a class="headerlink" href="#cil.optimisation.functions.SumFunction.Lmax" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the maximum Lipschitz constant for the SumFunction</p>
<div class="math notranslate nohighlight">
\[L = \max_{i}\{L_{i}\}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{i}\)</span> is the Lipschitz constant of the smooth function <span class="math notranslate nohighlight">\(F_{i}\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.SumFunction.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#SumFunction.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SumFunction.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the sum of functions at <span class="math notranslate nohighlight">\(x\)</span>.</p>
<div class="math notranslate nohighlight">
\[(F_{1} + F_{2} + ... + F_{n})(x) = F_{1}(x) + F_{2}(x) + ... + F_{n}(x)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.SumFunction.gradient">
<code class="sig-name descname"><span class="pre">gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#SumFunction.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SumFunction.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the sum of the gradient of functions at <span class="math notranslate nohighlight">\(x\)</span>, if all of them are differentiable.</p>
<div class="math notranslate nohighlight">
\[(F'_{1} + F'_{2} + ... + F'_{n})(x) = F'_{1}(x) + F'_{2}(x) + ... + F'_{n}(x)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.SumFunction.__add__">
<code class="sig-name descname"><span class="pre">__add__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#SumFunction.__add__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SumFunction.__add__" title="Permalink to this definition">#</a></dt>
<dd><p>Addition for the SumFunction.</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">SumFunction</span></code> + <code class="code docutils literal notranslate"><span class="pre">SumFunction</span></code> is a <code class="code docutils literal notranslate"><span class="pre">SumFunction</span></code>.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">SumFunction</span></code> + <code class="code docutils literal notranslate"><span class="pre">Function</span></code> is a <code class="code docutils literal notranslate"><span class="pre">SumFunction</span></code>.</p></li>
</ul>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.functions.ScaledFunction">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">ScaledFunction</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalar</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ScaledFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction" title="Permalink to this definition">#</a></dt>
<dd><p>ScaledFunction represents the scalar multiplication with a Function.</p>
<p>Let a function F then and a scalar <span class="math notranslate nohighlight">\(\alpha\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(G(x) = \alpha F(x)\)</span> then:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(G(x) = \alpha  F(x)\)</span> ( __call__ method )</p></li>
<li><p><span class="math notranslate nohighlight">\(G'(x) = \alpha  F'(x)\)</span> ( gradient method )</p></li>
<li><p><span class="math notranslate nohighlight">\(G^{*}(x^{*}) = \alpha  F^{*}(\frac{x^{*}}{\alpha})\)</span> ( convex_conjugate method )</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathrm{prox}_{\tau G}(x) = \mathrm{prox}_{(\tau\alpha) F}(x)\)</span> ( proximal method )</p></li>
</ol>
<dl class="py method">
<dt id="cil.optimisation.functions.ScaledFunction.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalar</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ScaledFunction.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.ScaledFunction.L">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">L</span></code><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <a href="#id26"><span class="problematic" id="id27">|f'(x) - f'(y)|</span></a> &lt;= L ||x-y||, assuming f: IG –&gt; R</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.ScaledFunction.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ScaledFunction.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the scaled function.</p>
<div class="math notranslate nohighlight">
\[G(x) = \alpha F(x)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.ScaledFunction.convex_conjugate">
<code class="sig-name descname"><span class="pre">convex_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ScaledFunction.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the convex conjugate of the scaled function.</p>
<div class="math notranslate nohighlight">
\[G^{*}(x^{*}) = \alpha  F^{*}(\frac{x^{*}}{\alpha})\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.ScaledFunction.gradient">
<code class="sig-name descname"><span class="pre">gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ScaledFunction.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the gradient of the scaled function.</p>
<div class="math notranslate nohighlight">
\[G'(x) = \alpha  F'(x)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.ScaledFunction.proximal">
<code class="sig-name descname"><span class="pre">proximal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ScaledFunction.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the scaled function.</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau G}(x) = \mathrm{prox}_{(\tau\alpha) F}(x)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.ScaledFunction.proximal_conjugate">
<code class="sig-name descname"><span class="pre">proximal_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ScaledFunction.proximal_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.proximal_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>This returns the proximal operator for the function at x, tau</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.functions.SumScalarFunction">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">SumScalarFunction</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#SumScalarFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction" title="Permalink to this definition">#</a></dt>
<dd><p>SumScalarFunction represents the sum a function with a scalar.</p>
<div class="math notranslate nohighlight">
\[(F + scalar)(x)  = F(x) + scalar\]</div>
<p>Although SumFunction has no general expressions for</p>
<ol class="lowerroman simple">
<li><p>convex_conjugate</p></li>
<li><p>proximal</p></li>
<li><p>proximal_conjugate</p></li>
</ol>
<p>if the second argument is a ConstantFunction then we can derive the above analytically.</p>
<dl class="py method">
<dt id="cil.optimisation.functions.SumScalarFunction.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#SumScalarFunction.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.SumScalarFunction.convex_conjugate">
<code class="sig-name descname"><span class="pre">convex_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#SumScalarFunction.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the convex conjugate of a <span class="math notranslate nohighlight">\((F+scalar)\)</span></p>
<div class="math notranslate nohighlight">
\[(F+scalar)^{*}(x^{*}) = F^{*}(x^{*}) - scalar\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.SumScalarFunction.proximal">
<code class="sig-name descname"><span class="pre">proximal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#SumScalarFunction.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of <span class="math notranslate nohighlight">\(F+scalar\)</span></p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{       au (F+scalar)}(x) = \mathrm{prox}_{     au F}\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.SumScalarFunction.L">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">L</span></code><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction.L" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the Lipschitz constant for the SumFunction</p>
<div class="math notranslate nohighlight">
\[L = \sum_{i} L_{i}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{i}\)</span> is the Lipschitz constant of the smooth function <span class="math notranslate nohighlight">\(F_{i}\)</span>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.functions.TranslateFunction">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">TranslateFunction</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#TranslateFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction" title="Permalink to this definition">#</a></dt>
<dd><p>TranslateFunction represents the translation of function F with respect to the center b.</p>
<p>Let a function F and consider <span class="math notranslate nohighlight">\(G(x) = F(x - center)\)</span>.</p>
<p>Function F is centered at 0, whereas G is centered at point b.</p>
<p>If <span class="math notranslate nohighlight">\(G(x) = F(x - b)\)</span> then:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(G(x) = F(x - b)\)</span> ( __call__ method )</p></li>
<li><p><span class="math notranslate nohighlight">\(G'(x) = F'(x - b)\)</span> ( gradient method )</p></li>
<li><p><span class="math notranslate nohighlight">\(G^{*}(x^{*}) = F^{*}(x^{*}) + &lt;x^{*}, b &gt;\)</span> ( convex_conjugate method )</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathrm{prox}_{\tau G}(x) = \mathrm{prox}_{\tau F}(x - b)  + b\)</span> ( proximal method )</p></li>
</ol>
<dl class="py method">
<dt id="cil.optimisation.functions.TranslateFunction.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#TranslateFunction.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.TranslateFunction.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#TranslateFunction.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the translated function.</p>
<div class="math notranslate nohighlight">
\[G(x) = F(x - b)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.TranslateFunction.gradient">
<code class="sig-name descname"><span class="pre">gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#TranslateFunction.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the gradient of the translated function.</p>
<div class="math notranslate nohighlight">
\[G'(x) =  F'(x - b)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.TranslateFunction.proximal">
<code class="sig-name descname"><span class="pre">proximal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#TranslateFunction.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the translated function.</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau G}(x) = \mathrm{prox}_{\tau F}(x-b) + b\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.TranslateFunction.convex_conjugate">
<code class="sig-name descname"><span class="pre">convex_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#TranslateFunction.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the convex conjugate of the translated function.</p>
<div class="math notranslate nohighlight">
\[G^{*}(x^{*}) = F^{*}(x^{*}) + &lt;x^{*}, b &gt;\]</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="simple-functions">
<h3>Simple functions<a class="headerlink" href="#simple-functions" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.functions.ConstantFunction">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">ConstantFunction</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ConstantFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction" title="Permalink to this definition">#</a></dt>
<dd><p>ConstantFunction: <span class="math notranslate nohighlight">\(F(x) = constant, constant\in\mathbb{R}\)</span></p>
<dl class="py method">
<dt id="cil.optimisation.functions.ConstantFunction.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ConstantFunction.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.ConstantFunction.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ConstantFunction.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the function, <span class="math notranslate nohighlight">\(F(x) = constant\)</span></p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.ConstantFunction.gradient">
<code class="sig-name descname"><span class="pre">gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ConstantFunction.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of the function, <span class="math notranslate nohighlight">\(F'(x)=0\)</span></p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.ConstantFunction.convex_conjugate">
<code class="sig-name descname"><span class="pre">convex_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ConstantFunction.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>The convex conjugate of constant function <span class="math notranslate nohighlight">\(F(x) = c\in\mathbb{R}\)</span> is</p>
<div class="math notranslate nohighlight">
\[\begin{split}F(x^{*})
=
\begin{cases}
    -c, &amp; if x^{*} = 0\\
    \infty, &amp; \mbox{otherwise}
\end{cases}\end{split}\]</div>
<p>However, <span class="math notranslate nohighlight">\(x^{*} = 0\)</span> only in the limit of iterations, so in fact this can be infinity.
We do not want to have inf values in the convex conjugate, so we have to penalise this value accordingly.
The following penalisation is useful in the PDHG algorithm, when we compute primal &amp; dual objectives
for convergence purposes.</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \sum \max\{x^{*}, 0\}\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.ConstantFunction.proximal">
<code class="sig-name descname"><span class="pre">proximal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ConstantFunction.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the constant function, which is the same element, i.e.,</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{       au F}(x) = x\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.ConstantFunction.L">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">L</span></code><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <a href="#id28"><span class="problematic" id="id29">|f'(x) - f'(y)|</span></a> &lt;= L ||x-y||, assuming f: IG –&gt; R</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.ConstantFunction.__rmul__">
<code class="sig-name descname"><span class="pre">__rmul__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ConstantFunction.__rmul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.__rmul__" title="Permalink to this definition">#</a></dt>
<dd><p>defines the right multiplication with a number</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.functions.ZeroFunction">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">ZeroFunction</span></code><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ZeroFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ZeroFunction" title="Permalink to this definition">#</a></dt>
<dd><p>ZeroFunction represents the zero function, <span class="math notranslate nohighlight">\(F(x) = 0\)</span></p>
<dl class="py method">
<dt id="cil.optimisation.functions.ZeroFunction.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ZeroFunction.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ZeroFunction.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.functions.Rosenbrock">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">Rosenbrock</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Rosenbrock.html#Rosenbrock"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Rosenbrock" title="Permalink to this definition">#</a></dt>
<dd><p>Rosenbrock function</p>
<div class="math notranslate nohighlight">
\[\]</div>
<p>F(x,y) = (alpha - x)^2 + beta(y-x^2)^2</p>
<p>The function has a global minimum at .. math:: (x,y)=(alpha, alpha^2)</p>
<dl class="py method">
<dt id="cil.optimisation.functions.Rosenbrock.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Rosenbrock.html#Rosenbrock.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Rosenbrock.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.Rosenbrock.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Rosenbrock.html#Rosenbrock.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Rosenbrock.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the function F at x: <span class="math notranslate nohighlight">\(F(x)\)</span></p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.Rosenbrock.gradient">
<code class="sig-name descname"><span class="pre">gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Rosenbrock.html#Rosenbrock.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Rosenbrock.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Gradient of the Rosenbrock function</p>
<div class="math notranslate nohighlight">
\[\]</div>
<p>nabla f(x,y) = left[ 2*((x-alpha) - 2beta x(y-x^2)) ; 2beta (y - x^2)  right]</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="composition-of-operator-and-a-function">
<h3>Composition of operator and a function<a class="headerlink" href="#composition-of-operator-and-a-function" title="Permalink to this headline">#</a></h3>
<p>This class allows the user to write a function which does the following:</p>
<div class="math notranslate nohighlight">
\[F ( x ) = G ( Ax )\]</div>
<p>where <span class="math notranslate nohighlight">\(A\)</span> is an operator. For instance the least squares function <a href="#id40"><span class="problematic" id="id41">l2norm_</span></a> <code class="code docutils literal notranslate"><span class="pre">Norm2Sq</span></code> can
be expressed as</p>
<div class="math notranslate nohighlight">
\[F(x) = || Ax - b ||^2_2\]</div>
<dl class="py class">
<dt id="cil.optimisation.functions.OperatorCompositionFunction">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">OperatorCompositionFunction</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/OperatorCompositionFunction.html#OperatorCompositionFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction" title="Permalink to this definition">#</a></dt>
<dd><p>Composition of a function with an operator as : <span class="math notranslate nohighlight">\((F \otimes A)(x) = F(Ax)\)</span></p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">parameter function</dt>
<dd class="field-odd"><p><code class="code docutils literal notranslate"><span class="pre">Function</span></code> F</p>
</dd>
<dt class="field-even">parameter operator</dt>
<dd class="field-even"><p><code class="code docutils literal notranslate"><span class="pre">Operator</span></code> A</p>
</dd>
</dl>
</div></blockquote>
<p>For general operator, we have no explicit formulas for convex_conjugate,
proximal and proximal_conjugate</p>
<dl class="py method">
<dt id="cil.optimisation.functions.OperatorCompositionFunction.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/OperatorCompositionFunction.html#OperatorCompositionFunction.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<code class="code docutils literal notranslate"><span class="pre">Operator</span></code>) – operator</p></li>
<li><p><strong>f</strong> (<code class="code docutils literal notranslate"><span class="pre">Function</span></code>) – function</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.OperatorCompositionFunction.L">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">L</span></code><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <a href="#id30"><span class="problematic" id="id31">|f'(x) - f'(y)|</span></a> &lt;= L ||x-y||, assuming f: IG –&gt; R</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.OperatorCompositionFunction.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/OperatorCompositionFunction.html#OperatorCompositionFunction.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(F(Ax)\)</span></p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.OperatorCompositionFunction.gradient">
<code class="sig-name descname"><span class="pre">gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/OperatorCompositionFunction.html#OperatorCompositionFunction.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Return the gradient of F(Ax),</p>
<p>..math ::  (F(Ax))’ = A^{T}F’(Ax)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="indicator-box">
<h3>Indicator box<a class="headerlink" href="#indicator-box" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.functions.IndicatorBox">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">IndicatorBox</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/IndicatorBox.html#IndicatorBox"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox" title="Permalink to this definition">#</a></dt>
<dd><p>Indicator function for box constraint</p>
<div class="math notranslate nohighlight">
\[\begin{split}f(x) = \mathbb{I}_{[a, b]} = \begin{cases}
                                   0, \text{ if } x \in [a, b] \\
                                   \infty, \text{otherwise}
                            \end{cases}\end{split}\]</div>
<dl class="py method">
<dt id="cil.optimisation.functions.IndicatorBox.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/IndicatorBox.html#IndicatorBox.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lower</strong> (float, default = <code class="code docutils literal notranslate"><span class="pre">-numpy.inf</span></code>) – lower bound</p></li>
<li><p><strong>upper</strong> (float, optional, default = <code class="code docutils literal notranslate"><span class="pre">numpy.inf</span></code>) – upper bound</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.IndicatorBox.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/IndicatorBox.html#IndicatorBox.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Evaluates IndicatorBox at x</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.IndicatorBox.gradient">
<code class="sig-name descname"><span class="pre">gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/IndicatorBox.html#IndicatorBox.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of function F at x, if it is differentiable</p>
<div class="math notranslate nohighlight">
\[F'(x)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.IndicatorBox.convex_conjugate">
<code class="sig-name descname"><span class="pre">convex_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/IndicatorBox.html#IndicatorBox.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Convex conjugate of IndicatorBox at x</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.IndicatorBox.proximal">
<code class="sig-name descname"><span class="pre">proximal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/IndicatorBox.html#IndicatorBox.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Proximal operator of IndicatorBox at x</p>
<div class="math notranslate nohighlight">
\[prox_{\tau * f}(x)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.IndicatorBox.proximal_conjugate">
<code class="sig-name descname"><span class="pre">proximal_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/IndicatorBox.html#IndicatorBox.proximal_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.proximal_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Proximal operator of the convex conjugate of IndicatorBox at x:</p>
<p>..math:: prox_{tau * f^{*}}(x)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="kullbackleibler">
<h3>KullbackLeibler<a class="headerlink" href="#kullbackleibler" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.functions.KullbackLeibler">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">KullbackLeibler</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/KullbackLeibler.html#KullbackLeibler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler" title="Permalink to this definition">#</a></dt>
<dd><p>Kullback Leibler divergence function is defined as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}F(u, v)
= \begin{cases}
u \log(\frac{u}{v}) - u + v &amp; \mbox{ if } u &gt; 0, v &gt; 0\\
v &amp; \mbox{ if } u = 0, v \ge 0 \\
\infty, &amp; \mbox{otherwise}
\end{cases}\end{split}\]</div>
<p>where we use the <span class="math notranslate nohighlight">\(0\log0 := 0\)</span> convention.</p>
<p>At the moment, we use build-in implemention of scipy, see
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.kl_div.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.kl_div.html</a></p>
<p>The Kullback-Leibler function is used as a fidelity term in minimisation problems where the
acquired data follow Poisson distribution. If we denote the acquired data with <span class="math notranslate nohighlight">\(b\)</span>
then, we write</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\underset{i}{\sum} F(b_{i}, (v + \eta)_{i})\]</div>
<p>where, <span class="math notranslate nohighlight">\(\eta\)</span> is an additional noise.</p>
<p>Example: In the case of Positron Emission Tomography reconstruction <span class="math notranslate nohighlight">\(\eta\)</span> represents
scatter and random events contribution during the PET acquisition. Hence, in that case the KullbackLeibler
fidelity measures the distance between <span class="math notranslate nohighlight">\(\mathcal{A}v + \eta\)</span> and acquisition data <span class="math notranslate nohighlight">\(b\)</span>, where
<span class="math notranslate nohighlight">\(\mathcal{A}\)</span> is the projection operator.</p>
<p>This is related to PoissonLogLikelihoodWithLinearModelForMean definition that is used in PET reconstruction
in the PET-MR software , see <a class="reference external" href="https://github.com/CCPPETMR">https://github.com/CCPPETMR</a> and for more details in</p>
</div></blockquote>
<p><a class="reference external" href="http://stir.sourceforge.net/documentation/doxy/html/classstir_1_1PoissonLogLikelihoodWithLinearModelForMean.html">http://stir.sourceforge.net/documentation/doxy/html/classstir_1_1PoissonLogLikelihoodWithLinearModelForMean.html</a></p>
<dl class="py method">
<dt id="cil.optimisation.functions.KullbackLeibler.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/KullbackLeibler.html#KullbackLeibler.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.KullbackLeibler.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/KullbackLeibler.html#KullbackLeibler.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the KullbackLeibler function at <span class="math notranslate nohighlight">\((b, x + \eta)\)</span>.
To avoid infinity values, we consider only pixels/voxels for <span class="math notranslate nohighlight">\(x+\eta\geq0\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.KullbackLeibler.log">
<code class="sig-name descname"><span class="pre">log</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">datacontainer</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/KullbackLeibler.html#KullbackLeibler.log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler.log" title="Permalink to this definition">#</a></dt>
<dd><p>calculates the in-place log of the datacontainer</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.KullbackLeibler.gradient">
<code class="sig-name descname"><span class="pre">gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/KullbackLeibler.html#KullbackLeibler.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of the KullbackLeibler function at <span class="math notranslate nohighlight">\((b, x + \eta)\)</span>.</p>
<div class="math notranslate nohighlight">
\[F'(b, x + \eta) = 1 - \frac{b}{x+\eta}\]</div>
<p>We require the <span class="math notranslate nohighlight">\(x+\eta&gt;0\)</span> otherwise we have inf values.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.KullbackLeibler.convex_conjugate">
<code class="sig-name descname"><span class="pre">convex_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/KullbackLeibler.html#KullbackLeibler.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the convex conjugate of the KullbackLeibler function at <span class="math notranslate nohighlight">\((b, x + \eta)\)</span>.</p>
<div class="math notranslate nohighlight">
\[F^{*}(b, x + \eta) = - b \log(1-x^{*}) - &lt;x^{*}, \eta&gt;\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.KullbackLeibler.proximal">
<code class="sig-name descname"><span class="pre">proximal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/KullbackLeibler.html#KullbackLeibler.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the proximal operator of the KullbackLeibler function at <span class="math notranslate nohighlight">\((b, x + \eta)\)</span>.</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \frac{1}{2}\bigg( (x - \eta - \tau) + \sqrt{ (x + \eta - \tau)^2 + 4\tau b} \bigg)\]</div>
<p>The proximal for the convex conjugate of <span class="math notranslate nohighlight">\(F\)</span> is</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F^{*}}(x) = 0.5*((z + 1) - \sqrt{(z-1)^2 + 4 * \tau b})\]</div>
<p>where <span class="math notranslate nohighlight">\(z = x + \tau \eta\)</span></p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.KullbackLeibler.proximal_conjugate">
<code class="sig-name descname"><span class="pre">proximal_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/KullbackLeibler.html#KullbackLeibler.proximal_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler.proximal_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Proximal operator of the convex conjugate of KullbackLeibler at x:</p>
<div class="math notranslate nohighlight">
\[prox_{\tau * f^{*}}(x)\]</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="l1-norm">
<h3>L1 Norm<a class="headerlink" href="#l1-norm" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.functions.L1Norm">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">L1Norm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L1Norm.html#L1Norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L1Norm" title="Permalink to this definition">#</a></dt>
<dd><p>L1Norm function</p>
<dl>
<dt>Consider the following cases:</dt><dd><ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[F(x) = ||x||_{1}\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[F(x) = ||x - b||_{1}\]</div>
</li>
</ol>
</dd>
</dl>
<dl class="py method">
<dt id="cil.optimisation.functions.L1Norm.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L1Norm.html#L1Norm.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L1Norm.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>creator</p>
<p>Cases considered (with/without data):
a) <span class="math notranslate nohighlight">\(f(x) = ||x||_{1}\)</span>
b) <span class="math notranslate nohighlight">\(f(x) = ||x - b||_{1}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>b</strong> (<code class="code docutils literal notranslate"><span class="pre">DataContainer</span></code>, optional) – translation of the function</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.L1Norm.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L1Norm.html#L1Norm.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L1Norm.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the L1Norm function at x.</p>
<dl>
<dt>Consider the following cases:</dt><dd><ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[F(x) = ||x||_{1}\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[F(x) = ||x - b||_{1}\]</div>
</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.L1Norm.convex_conjugate">
<code class="sig-name descname"><span class="pre">convex_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L1Norm.html#L1Norm.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L1Norm.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the convex conjugate of the L1Norm function at x.
Here, we need to use the convex conjugate of L1Norm, which is the Indicator of the unit
<span class="math notranslate nohighlight">\(L^{\infty}\)</span> norm</p>
<p>Consider the following cases:</p>
<blockquote>
<div><ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \mathbb{I}_{\{\|\cdot\|_{\infty}\leq1\}}(x^{*})\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \mathbb{I}_{\{\|\cdot\|_{\infty}\leq1\}}(x^{*}) + &lt;x^{*},b&gt;\]</div>
</li>
</ol>
</div></blockquote>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbb{I}_{\{\|\cdot\|_{\infty}\leq1\}}(x^{*})
= \begin{cases}
0, \mbox{if } \|x^{*}\|_{\infty}\leq1\\
\infty, \mbox{otherwise}
\end{cases}\end{split}\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.L1Norm.proximal">
<code class="sig-name descname"><span class="pre">proximal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L1Norm.html#L1Norm.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L1Norm.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the proximal operator of the L1Norm function at x.</p>
<p>Consider the following cases:</p>
<blockquote>
<div><ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \mathrm{ShinkOperator}(x)\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \mathrm{ShinkOperator}(x) + b\]</div>
</li>
</ol>
</div></blockquote>
<p>where,</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \mathrm{ShinkOperator}(x) = sgn(x) * \max\{ |x| - \tau, 0 \}\]</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="squared-l2-norm-squared">
<h3>Squared L2 norm squared<a class="headerlink" href="#squared-l2-norm-squared" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.functions.L2NormSquared">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">L2NormSquared</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#L2NormSquared"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared" title="Permalink to this definition">#</a></dt>
<dd><p>L2NormSquared function: <span class="math notranslate nohighlight">\(F(x) = \| x\|^{2}_{2} = \underset{i}{\sum}x_{i}^{2}\)</span></p>
<p>Following cases are considered:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p><span class="math notranslate nohighlight">\(F(x) = \|x\|^{2}_{2}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(F(x) = \|x - b\|^{2}_{2}\)</span></p></li>
</ol>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For case b) case we can use <code class="code docutils literal notranslate"><span class="pre">F</span> <span class="pre">=</span> <span class="pre">L2NormSquared().centered_at(b)</span></code>,
see <em>TranslateFunction</em>.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">L2NormSquared</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">L2NormSquared</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">L2NormSquared</span><span class="p">()</span><span class="o">.</span><span class="n">centered_at</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
<dl class="py method">
<dt id="cil.optimisation.functions.L2NormSquared.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#L2NormSquared.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>creator</p>
<dl>
<dt>Cases considered (with/without data):</dt><dd><ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[f(x) = \|x\|^{2}_{2}\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[f(x) = \|\|x - b\|\|^{2}_{2}\]</div>
</li>
</ol>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>b</strong> (<code class="code docutils literal notranslate"><span class="pre">DataContainer</span></code>, optional) – translation of the function</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.L2NormSquared.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#L2NormSquared.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the L2NormSquared function at x.</p>
<p>Following cases are considered:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p><span class="math notranslate nohighlight">\(F(x) = \|x\|^{2}_{2}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(F(x) = \|x - b\|^{2}_{2}\)</span></p></li>
</ol>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p><span class="math notranslate nohighlight">\(x\)</span></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(\underset{i}{\sum}x_{i}^{2}\)</span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.L2NormSquared.gradient">
<code class="sig-name descname"><span class="pre">gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#L2NormSquared.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of the L2NormSquared function at x.</p>
<p>Following cases are considered:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p><span class="math notranslate nohighlight">\(F'(x) = 2x\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(F'(x) = 2(x-b)\)</span></p></li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.L2NormSquared.convex_conjugate">
<code class="sig-name descname"><span class="pre">convex_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#L2NormSquared.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the convex conjugate of the L2NormSquared function at x.</p>
<p>Consider the following cases:</p>
<blockquote>
<div><ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \frac{1}{4}\|x^{*}\|^{2}_{2}\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \frac{1}{4}\|x^{*}\|^{2}_{2} + &lt;x^{*}, b&gt;\]</div>
</li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.L2NormSquared.proximal">
<code class="sig-name descname"><span class="pre">proximal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#L2NormSquared.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the proximal operator of the L2NormSquared function at x.</p>
<p>Consider the following cases:</p>
<blockquote>
<div><ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \frac{x}{1+2\tau}\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \frac{x-b}{1+2\tau} + b\]</div>
</li>
</ol>
</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.functions.WeightedL2NormSquared">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">WeightedL2NormSquared</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#WeightedL2NormSquared"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared" title="Permalink to this definition">#</a></dt>
<dd><p>WeightedL2NormSquared function: <span class="math notranslate nohighlight">\(F(x) = \| x\|_{w}^{2}_{2} = \underset{i}{\sum}w_{i}*x_{i}^{2} = &lt;x, w*x&gt; = x^{T}*w*x\)</span></p>
<dl class="py method">
<dt id="cil.optimisation.functions.WeightedL2NormSquared.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#WeightedL2NormSquared.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.WeightedL2NormSquared.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#WeightedL2NormSquared.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the function F at x: <span class="math notranslate nohighlight">\(F(x)\)</span></p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.WeightedL2NormSquared.gradient">
<code class="sig-name descname"><span class="pre">gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#WeightedL2NormSquared.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of function F at x, if it is differentiable</p>
<div class="math notranslate nohighlight">
\[F'(x)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.WeightedL2NormSquared.convex_conjugate">
<code class="sig-name descname"><span class="pre">convex_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#WeightedL2NormSquared.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the convex conjugate of function <span class="math notranslate nohighlight">\(F\)</span> at <span class="math notranslate nohighlight">\(x^{*}\)</span>,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x^{*}}{\sup} &lt;x^{*}, x&gt; - F(x)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.WeightedL2NormSquared.proximal">
<code class="sig-name descname"><span class="pre">proximal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#WeightedL2NormSquared.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of function <span class="math notranslate nohighlight">\(\tau F\)</span> at x
.. math:: mathrm{prox}_{tau F}(x) = underset{z}{mathrm{argmin}} frac{1}{2}|z - x|^{2} + tau F(z)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="least-squares">
<h3>Least Squares<a class="headerlink" href="#least-squares" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.functions.LeastSquares">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">LeastSquares</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/LeastSquares.html#LeastSquares"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.LeastSquares" title="Permalink to this definition">#</a></dt>
<dd><p>(Weighted) Least Squares function</p>
<div class="math notranslate nohighlight">
\[F(x) = c\|Ax-b\|_2^2\]</div>
<p>or</p>
<div class="math notranslate nohighlight">
\[F(x) = c\|Ax-b\|_{2,W}^{2}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> – Operator</p></li>
<li><p><strong>c</strong> – Scaling Constant</p></li>
<li><p><strong>b</strong> – Data</p></li>
<li><p><strong>weight</strong> – 1.0 (Default) or DataContainer</p></li>
</ul>
</dd>
</dl>
<p>Members:</p>
<blockquote>
<div><p>L : Lipshitz Constant of the gradient of <span class="math notranslate nohighlight">\(F\)</span> which is <span class="math notranslate nohighlight">\(2 c ||A||_2^2 = 2 c s1(A)^2\)</span>, or</p>
<p>L : Lipshitz Constant of the gradient of <span class="math notranslate nohighlight">\(F\)</span> which is <span class="math notranslate nohighlight">\(2 c ||weight|| ||A||_2^2 = 2s1(A)^2\)</span>,</p>
</div></blockquote>
<p>where s1(A) is the largest singular value of A.</p>
<dl class="py method">
<dt id="cil.optimisation.functions.LeastSquares.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/LeastSquares.html#LeastSquares.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.LeastSquares.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.LeastSquares.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/LeastSquares.html#LeastSquares.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.LeastSquares.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of <span class="math notranslate nohighlight">\(F(x) = c\|Ax-b\|_2^2\)</span> or c|Ax-b|_{2,weight}^2</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.LeastSquares.gradient">
<code class="sig-name descname"><span class="pre">gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/LeastSquares.html#LeastSquares.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.LeastSquares.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of <span class="math notranslate nohighlight">\(F(x) = c*\|A*x-b\|_2^2\)</span></p>
<div class="math notranslate nohighlight">
\[F'(x) = 2cA^T(Ax-b)\]</div>
<div class="math notranslate nohighlight">
\[F'(x) = 2cA^T(weight(Ax-b))\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.LeastSquares.L">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">L</span></code><a class="headerlink" href="#cil.optimisation.functions.LeastSquares.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <a href="#id32"><span class="problematic" id="id33">|f'(x) - f'(y)|</span></a> &lt;= L ||x-y||, assuming f: IG –&gt; R</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.LeastSquares.__rmul__">
<code class="sig-name descname"><span class="pre">__rmul__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/LeastSquares.html#LeastSquares.__rmul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.LeastSquares.__rmul__" title="Permalink to this definition">#</a></dt>
<dd><p>defines the right multiplication with a number</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="mixed-l21-norm">
<h3>Mixed L21 norm<a class="headerlink" href="#mixed-l21-norm" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.functions.MixedL21Norm">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">MixedL21Norm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/MixedL21Norm.html#MixedL21Norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm" title="Permalink to this definition">#</a></dt>
<dd><p>MixedL21Norm function: <span class="math notranslate nohighlight">\(F(x) = ||x||_{2,1} = \sum |x|_{2} = \sum \sqrt{ (x^{1})^{2} + (x^{2})^{2} + \dots}\)</span></p>
<p>where x is a BlockDataContainer, i.e., <span class="math notranslate nohighlight">\(x=(x^{1}, x^{2}, \dots)\)</span></p>
<dl class="py method">
<dt id="cil.optimisation.functions.MixedL21Norm.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/MixedL21Norm.html#MixedL21Norm.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.MixedL21Norm.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/MixedL21Norm.html#MixedL21Norm.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the MixedL21Norm function at x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> – <code class="code docutils literal notranslate"><span class="pre">BlockDataContainer</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.MixedL21Norm.convex_conjugate">
<code class="sig-name descname"><span class="pre">convex_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/MixedL21Norm.html#MixedL21Norm.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the convex conjugate of the MixedL21Norm function at x.</p>
<p>This is the Indicator function of <span class="math notranslate nohighlight">\(\mathbb{I}_{\{\|\cdot\|_{2,\infty}\leq1\}}(x^{*})\)</span>,</p>
<p>i.e.,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbb{I}_{\{\|\cdot\|_{2, \infty}\leq1\}}(x^{*})
= \begin{cases}
0, \mbox{if } \|x\|_{2, \infty}\leq1\\
\infty, \mbox{otherwise}
\end{cases}\end{split}\]</div>
<p>where,</p>
<div class="math notranslate nohighlight">
\[\|x\|_{2,\infty} = \max\{ \|x\|_{2} \} = \max\{ \sqrt{ (x^{1})^{2} + (x^{2})^{2} + \dots}\}\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.MixedL21Norm.proximal">
<code class="sig-name descname"><span class="pre">proximal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/MixedL21Norm.html#MixedL21Norm.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the proximal operator of the MixedL21Norm function at x.</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \frac{x}{\|x\|_{2}}\max\{ \|x\|_{2} - \tau, 0 \}\]</div>
<p>where the convention 0 · (0/0) = 0 is used.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="smooth-mixed-l21-norm">
<h3>Smooth Mixed L21 norm<a class="headerlink" href="#smooth-mixed-l21-norm" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.functions.SmoothMixedL21Norm">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">SmoothMixedL21Norm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">epsilon</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/MixedL21Norm.html#SmoothMixedL21Norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SmoothMixedL21Norm" title="Permalink to this definition">#</a></dt>
<dd><p>SmoothMixedL21Norm function: <span class="math notranslate nohighlight">\(F(x) = ||x||_{2,1} = \sum |x|_{2} = \sum \sqrt{ (x^{1})^{2} + (x^{2})^{2} + \epsilon^2 + \dots}\)</span></p>
<p>where x is a BlockDataContainer, i.e., <span class="math notranslate nohighlight">\(x=(x^{1}, x^{2}, \dots)\)</span></p>
<p>Conjugate, proximal and proximal conjugate methods no closed-form solution</p>
<dl class="py method">
<dt id="cil.optimisation.functions.SmoothMixedL21Norm.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">epsilon</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/MixedL21Norm.html#SmoothMixedL21Norm.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SmoothMixedL21Norm.__init__" title="Permalink to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>epsilon</strong> – smoothing parameter making MixedL21Norm differentiable</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.SmoothMixedL21Norm.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/MixedL21Norm.html#SmoothMixedL21Norm.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SmoothMixedL21Norm.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the SmoothMixedL21Norm function at x.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.SmoothMixedL21Norm.gradient">
<code class="sig-name descname"><span class="pre">gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/MixedL21Norm.html#SmoothMixedL21Norm.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SmoothMixedL21Norm.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of the SmoothMixedL21Norm function at x.</p>
<p>frac{x}{<a href="#id34"><span class="problematic" id="id35">|x|</span></a>}</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="total-variation">
<h3>Total variation<a class="headerlink" href="#total-variation" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.functions.TotalVariation">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">TotalVariation</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_iteration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">correlation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Space'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'c'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isotropic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">info</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/TotalVariation.html#TotalVariation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation" title="Permalink to this definition">#</a></dt>
<dd><p>Fast Gradient Projection algorithm for Total Variation(TV) regularisation</p>
<div class="math notranslate nohighlight">
\[\min_{x} \frac{1}{2}||x-b||^{2}_{2} + \tau\alpha TV(x)\]</div>
<p>:param : param max_iteration: max iterations of FGP algorithm
:param : type max_iteration: int, default 100
:param : param tolerance: Stopping criterion
:param : type tolerance: float, default <cite>None</cite>
:param : param correlation: Correlation between <cite>Space</cite> and/or <cite>SpaceChannels</cite> for the GradientOperator
:param : type correlation: str, default ‘Space’
:param : param backend: Backend to compute finite differences for the GradientOperator
:param : type backend: str, default ‘c’
:param : param lower: lower bound for the orthogonal projection onto the convex set C
:param : type lower: Number, default <cite>-np.inf</cite>
:param : param upper: upper bound for the orthogonal projection onto the convex set C
:param : type upper: Number, default <cite>+np.inf</cite>
:param : param isotropic: L2 norm is used for Gradient Operator (isotropic)
:param : type isotropic: bool, default <cite>True</cite></p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\sum \sqrt{(\partial_y u)^{2} + (\partial_x u)^2} \mbox{ (isotropic) }\]</div>
<div class="math notranslate nohighlight">
\[\sum |\partial_y u| + |\partial_x u| \mbox{ (anisotropic) }\]</div>
</div></blockquote>
<p>:param : param split: splits the Gradient into spatial Gradient and spectral Gradient for multichannel data
:param : type split: bool, default <cite>False</cite>
:param : param info: force a print to screen stating the stop
:param : type info: bool, default <cite>False</cite>
:param : Example:
:param TV = alpha * TotalVariation():
:param sol = TV.proximal:
:type sol = TV.proximal: data, tau = 1.0
:param .. note:: <cite>tau</cite> can be a number or an array. The latter case implies that step-size preconditioning is applied.:</p>
<p>Reference:</p>
<blockquote>
<div><p>A. Beck and M. Teboulle, “Fast Gradient-Based Algorithms for Constrained Total Variation
Image Denoising and Deblurring Problems,” in IEEE Transactions on Image Processing,
vol. 18, no. 11, pp. 2419-2434, Nov. 2009,
doi: 10.1109/TIP.2009.2028250.</p>
</div></blockquote>
<dl class="py method">
<dt id="cil.optimisation.functions.TotalVariation.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_iteration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">correlation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Space'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'c'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isotropic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">info</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/TotalVariation.html#TotalVariation.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.TotalVariation.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/TotalVariation.html#TotalVariation.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the alpha * TV(x)</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.TotalVariation.projection_C">
<code class="sig-name descname"><span class="pre">projection_C</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/TotalVariation.html#TotalVariation.projection_C"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.projection_C" title="Permalink to this definition">#</a></dt>
<dd><p>Returns orthogonal projection onto the convex set C</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.TotalVariation.projection_P">
<code class="sig-name descname"><span class="pre">projection_P</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/TotalVariation.html#TotalVariation.projection_P"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.projection_P" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the projection P onto |cdot|_{infty}</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.TotalVariation.proximal">
<code class="sig-name descname"><span class="pre">proximal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/TotalVariation.html#TotalVariation.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the solution of the FGP_TV algorithm</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.TotalVariation.convex_conjugate">
<code class="sig-name descname"><span class="pre">convex_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/TotalVariation.html#TotalVariation.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the convex conjugate of function <span class="math notranslate nohighlight">\(F\)</span> at <span class="math notranslate nohighlight">\(x^{*}\)</span>,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x^{*}}{\sup} &lt;x^{*}, x&gt; - F(x)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.TotalVariation.L">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">L</span></code><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <a href="#id36"><span class="problematic" id="id37">|f'(x) - f'(y)|</span></a> &lt;= L ||x-y||, assuming f: IG –&gt; R</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.TotalVariation.gradient">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">gradient</span></code><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>creates a gradient operator if not instantiated yet</p>
<p>There is no check that the variable _domain is changed after instantiation (should not be the case)</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.TotalVariation.__rmul__">
<code class="sig-name descname"><span class="pre">__rmul__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scalar</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/TotalVariation.html#TotalVariation.__rmul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.__rmul__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a function multiplied by a scalar.</p>
</dd></dl>

</dd></dl>

</div>
</div>
</div>
<div class="section" id="block-framework">
<h1>Block Framework<a class="headerlink" href="#block-framework" title="Permalink to this headline">#</a></h1>
<p>To be able to express more advanced optimisation problems we developed the
<a class="reference internal" href="#block-framework">Block Framework</a>, which provides a generic strategy to treat variational
problems in the following form:</p>
<div class="math notranslate nohighlight">
\[\min \text{Regulariser} + \text{Fidelity}\]</div>
<p>The block framework consists of:</p>
<ul class="simple">
<li><p><a class="reference external" href="framework.html#cil.framework.BlockDataContainer">BlockDataContainer</a></p></li>
<li><p><a class="reference external" href="optimisation.html#cil.optimisation.functions.BlockFunction">BlockFunction</a></p></li>
<li><p><a class="reference external" href="optimisation.html#cil.optimisation.operators.BlockOperators">BlockOperator</a></p></li>
</ul>
<div class="section" id="blockdatacontainer">
<h2>BlockDataContainer<a class="headerlink" href="#blockdatacontainer" title="Permalink to this headline">#</a></h2>
<p><a class="reference external" href="framework.html#cil.framework.BlockDataContainer">BlockDataContainer</a> holds <a href="#id42"><span class="problematic" id="id43">`DataContainer`_</span></a> as column vector. It is possible to
do basic algebra between <a class="reference external" href="framework.html#cil.framework.BlockDataContainer">BlockDataContainer</a> s and with numbers, list or numpy arrays.</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}x = [x_{1}, x_{2} ]\in (X_{1}\times X_{2})\\y = [y_{1}, y_{2}, y_{3} ]\in(Y_{1}\times Y_{2} \times Y_{3})\end{aligned}\end{align} \]</div>
<dl class="py class">
<dt id="cil.framework.BlockDataContainer">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.framework.</span></code><code class="sig-name descname"><span class="pre">BlockDataContainer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer" title="Permalink to this definition">#</a></dt>
<dd><p>Class to hold DataContainers as column vector</p>
<p>Provides basic algebra between BlockDataContainer’s, DataContainer’s and
subclasses and Numbers</p>
<ol class="arabic simple">
<li><p>algebra between <a href="#id11"><span class="problematic" id="id12">`</span></a>BlockDataContainer`s will be element-wise, only if
the shape of the 2 <a href="#id13"><span class="problematic" id="id14">`</span></a>BlockDataContainer`s is the same, otherwise it
will fail</p></li>
<li><p>algebra between <cite>BlockDataContainer`s and `list</cite> or <cite>numpy array</cite> will
work as long as the number of <cite>rows</cite> and element of the arrays match,
indipendently on the fact that the <cite>BlockDataContainer</cite> could be nested</p></li>
<li><p>algebra between <cite>BlockDataContainer</cite> and one <cite>DataContainer</cite> is possible.
It will require that all the <cite>DataContainers</cite> in the block to be
compatible with the <cite>DataContainer</cite> we want to algebra with. Should we
require that the <cite>DataContainer</cite> is the same type? Like <cite>ImageData</cite> or <cite>AcquisitionData</cite>?</p></li>
<li><p>algebra between <cite>BlockDataContainer</cite> and a <cite>Number</cite> is possible and it
will be done with each element of the <cite>BlockDataContainer</cite> even if nested</p></li>
</ol>
<p>A = [ [B,C] , D]
A * 3 = [ 3 * [B,C] , 3* D] = [ [ 3*B, 3*C]  , 3*D ]</p>
<dl class="py method">
<dt id="cil.framework.BlockDataContainer.__iter__">
<code class="sig-name descname"><span class="pre">__iter__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__iter__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__iter__" title="Permalink to this definition">#</a></dt>
<dd><p>BlockDataContainer is Iterable</p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.next">
<code class="sig-name descname"><span class="pre">next</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.next"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.next" title="Permalink to this definition">#</a></dt>
<dd><p>python2 backwards compatibility</p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.is_compatible">
<code class="sig-name descname"><span class="pre">is_compatible</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.is_compatible"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.is_compatible" title="Permalink to this definition">#</a></dt>
<dd><p>basic check if the size of the 2 objects fit</p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.add">
<code class="sig-name descname"><span class="pre">add</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.add"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.add" title="Permalink to this definition">#</a></dt>
<dd><p>Algebra: add method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>other (number, DataContainer or subclasses or BlockDataContainer</p>
</dd>
<dt class="field-even">Param</dt>
<dd class="field-even"><p>out (optional): provides a placehold for the resul.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.subtract">
<code class="sig-name descname"><span class="pre">subtract</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.subtract"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.subtract" title="Permalink to this definition">#</a></dt>
<dd><p>Algebra: subtract method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>other (number, DataContainer or subclasses or BlockDataContainer</p>
</dd>
<dt class="field-even">Param</dt>
<dd class="field-even"><p>out (optional): provides a placehold for the resul.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.multiply">
<code class="sig-name descname"><span class="pre">multiply</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.multiply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.multiply" title="Permalink to this definition">#</a></dt>
<dd><p>Algebra: multiply method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>other (number, DataContainer or subclasses or BlockDataContainer</p>
</dd>
<dt class="field-even">Param</dt>
<dd class="field-even"><p>out (optional): provides a placehold for the resul.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.divide">
<code class="sig-name descname"><span class="pre">divide</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.divide"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.divide" title="Permalink to this definition">#</a></dt>
<dd><p>Algebra: divide method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>other (number, DataContainer or subclasses or BlockDataContainer</p>
</dd>
<dt class="field-even">Param</dt>
<dd class="field-even"><p>out (optional): provides a placehold for the resul.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.power">
<code class="sig-name descname"><span class="pre">power</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.power"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.power" title="Permalink to this definition">#</a></dt>
<dd><p>Algebra: power method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>other (number, DataContainer or subclasses or BlockDataContainer</p>
</dd>
<dt class="field-even">Param</dt>
<dd class="field-even"><p>out (optional): provides a placehold for the resul.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.maximum">
<code class="sig-name descname"><span class="pre">maximum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.maximum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.maximum" title="Permalink to this definition">#</a></dt>
<dd><p>Algebra: power method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>other (number, DataContainer or subclasses or BlockDataContainer</p>
</dd>
<dt class="field-even">Param</dt>
<dd class="field-even"><p>out (optional): provides a placehold for the resul.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.minimum">
<code class="sig-name descname"><span class="pre">minimum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.minimum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.minimum" title="Permalink to this definition">#</a></dt>
<dd><p>Algebra: power method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>other (number, DataContainer or subclasses or BlockDataContainer</p>
</dd>
<dt class="field-even">Param</dt>
<dd class="field-even"><p>out (optional): provides a placehold for the resul.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.sapyb">
<code class="sig-name descname"><span class="pre">sapyb</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.sapyb"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.sapyb" title="Permalink to this definition">#</a></dt>
<dd><p>performs axpby element-wise on the BlockDataContainer containers</p>
<p>Does the operation .. math:: a*x+b*y and stores the result in out, where x is self</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – scalar</p></li>
<li><p><strong>b</strong> – scalar</p></li>
<li><p><strong>y</strong> – compatible (Block)DataContainer</p></li>
<li><p><strong>out</strong> – (Block)DataContainer to store the result</p></li>
</ul>
</dd>
</dl>
<p>a = 2
b = 3
ig = ImageGeometry(10,11)
x = ig.allocate(1)
y = ig.allocate(2)
bdc1 = BlockDataContainer(2*x, y)
bdc2 = BlockDataContainer(x, 2*y)
out = bdc1.sapyb(a,bdc2,b)</p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.axpby">
<code class="sig-name descname"><span class="pre">axpby</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">b</span></em>, <em class="sig-param"><span class="pre">y</span></em>, <em class="sig-param"><span class="pre">out</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></em>, <em class="sig-param"><span class="pre">num_threads=1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.axpby"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.axpby" title="Permalink to this definition">#</a></dt>
<dd><p>Deprecated method. Alias of sapyb</p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.binary_operations">
<code class="sig-name descname"><span class="pre">binary_operations</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.binary_operations"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.binary_operations" title="Permalink to this definition">#</a></dt>
<dd><p>Algebra: generic method of algebric operation with BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<p>Provides commutativity with DataContainer and subclasses, i.e. this
class’s reverse algebric methods take precedence w.r.t. direct algebric
methods of DataContainer and subclasses.</p>
<p>This method is not to be used directly</p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.unary_operations">
<code class="sig-name descname"><span class="pre">unary_operations</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operation</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.unary_operations"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.unary_operations" title="Permalink to this definition">#</a></dt>
<dd><p>Unary operation on BlockDataContainer:</p>
<p>generic method of unary operation with BlockDataContainer: abs, sign, sqrt and conjugate</p>
<p>This method is not to be used directly</p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.copy">
<code class="sig-name descname"><span class="pre">copy</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.copy" title="Permalink to this definition">#</a></dt>
<dd><p>alias of clone</p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.__radd__">
<code class="sig-name descname"><span class="pre">__radd__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__radd__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__radd__" title="Permalink to this definition">#</a></dt>
<dd><p>Reverse addition</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.__rsub__">
<code class="sig-name descname"><span class="pre">__rsub__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__rsub__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__rsub__" title="Permalink to this definition">#</a></dt>
<dd><p>Reverse subtraction</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.__rmul__">
<code class="sig-name descname"><span class="pre">__rmul__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__rmul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__rmul__" title="Permalink to this definition">#</a></dt>
<dd><p>Reverse multiplication</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.__rdiv__">
<code class="sig-name descname"><span class="pre">__rdiv__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__rdiv__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__rdiv__" title="Permalink to this definition">#</a></dt>
<dd><p>Reverse division</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.__rtruediv__">
<code class="sig-name descname"><span class="pre">__rtruediv__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__rtruediv__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__rtruediv__" title="Permalink to this definition">#</a></dt>
<dd><p>Reverse truedivision</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.__rpow__">
<code class="sig-name descname"><span class="pre">__rpow__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__rpow__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__rpow__" title="Permalink to this definition">#</a></dt>
<dd><p>Reverse power</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.__iadd__">
<code class="sig-name descname"><span class="pre">__iadd__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__iadd__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__iadd__" title="Permalink to this definition">#</a></dt>
<dd><p>Inline addition</p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.__isub__">
<code class="sig-name descname"><span class="pre">__isub__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__isub__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__isub__" title="Permalink to this definition">#</a></dt>
<dd><p>Inline subtraction</p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.__imul__">
<code class="sig-name descname"><span class="pre">__imul__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__imul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__imul__" title="Permalink to this definition">#</a></dt>
<dd><p>Inline multiplication</p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.__idiv__">
<code class="sig-name descname"><span class="pre">__idiv__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__idiv__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__idiv__" title="Permalink to this definition">#</a></dt>
<dd><p>Inline division</p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.__itruediv__">
<code class="sig-name descname"><span class="pre">__itruediv__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__itruediv__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__itruediv__" title="Permalink to this definition">#</a></dt>
<dd><p>Inline truedivision</p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.__neg__">
<code class="sig-name descname"><span class="pre">__neg__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__neg__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__neg__" title="Permalink to this definition">#</a></dt>
<dd><p>Return - self</p>
</dd></dl>

<dl class="py attribute">
<dt id="cil.framework.BlockDataContainer.__weakref__">
<code class="sig-name descname"><span class="pre">__weakref__</span></code><a class="headerlink" href="#cil.framework.BlockDataContainer.__weakref__" title="Permalink to this definition">#</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="block-function">
<h2>Block Function<a class="headerlink" href="#block-function" title="Permalink to this headline">#</a></h2>
<p><a class="reference external" href="optimisation.html#cil.optimisation.functions.BlockFunction">BlockFunction</a> acts on <a class="reference external" href="framework.html#cil.framework.BlockDataContainer">BlockDataContainer</a> as a separable sum function:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}f = [f_1,...,f_n] \newline\\f([x_1,...,x_n]) = f_1(x_1) +  .... + f_n(x_n)\end{aligned}\end{align} \]</div>
</div></blockquote>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}Y = \begin{bmatrix}
y_{1}\\
y_{2}\\
y_{3}\\
\end{bmatrix}, \quad  F  = [ f_{1}, f_{2}, f_{3} ]\end{split}\\F(Y) : = f_{1}(y_{1}) + f_{2}(y_{2}) + f_{3}(y_{3})\end{aligned}\end{align} \]</div>
<dl class="py class">
<dt id="cil.optimisation.functions.BlockFunction">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">BlockFunction</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">functions</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/BlockFunction.html#BlockFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction" title="Permalink to this definition">#</a></dt>
<dd><p>BlockFunction represents a <em>separable sum</em> function <span class="math notranslate nohighlight">\(F\)</span> defined as</p>
<div class="math notranslate nohighlight">
\[F:X_{1}\times X_{2}\cdots\times X_{m} \rightarrow (-\infty, \infty]\]</div>
<p>where <span class="math notranslate nohighlight">\(F\)</span> is the separable sum of functions <span class="math notranslate nohighlight">\((f_{i})_{i=1}^{m}\)</span>,</p>
<div class="math notranslate nohighlight">
\[F(x_{1}, x_{2}, \cdots, x_{m}) = \overset{m}{\underset{i=1}{\sum}}f_{i}(x_{i}), \mbox{ with } f_{i}: X_{i} \rightarrow (-\infty, \infty].\]</div>
<p>A nice property (due to it’s separability structure) is that the proximal operator
can be decomposed along the proximal operators of each function <span class="math notranslate nohighlight">\(f_{i}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = ( \mathrm{prox}_{\tau f_{i}}(x_{i}) )_{i=1}^{m}\]</div>
<p>In addition, if <span class="math notranslate nohighlight">\(\tau := (\tau_{1},\dots,\tau_{m})\)</span>, then</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = ( \mathrm{prox}_{\tau_{i} f_{i}}(x_{i}) )_{i=1}^{m}\]</div>
<dl class="py method">
<dt id="cil.optimisation.functions.BlockFunction.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">functions</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/BlockFunction.html#BlockFunction.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.BlockFunction.L">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">L</span></code><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <a href="#id38"><span class="problematic" id="id39">|f'(x) - f'(y)|</span></a> &lt;= L ||x-y||, assuming f: IG –&gt; R</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.BlockFunction.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/BlockFunction.html#BlockFunction.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the BlockFunction <span class="math notranslate nohighlight">\(F\)</span></p>
<div class="math notranslate nohighlight">
\[F(x) = \overset{m}{\underset{i=1}{\sum}}f_{i}(x_{i}), \mbox{ where } x = (x_{1}, x_{2}, \cdots, x_{m}), \quad i = 1,2,\dots,m\]</div>
<p>Parameter:</p>
<blockquote>
<div><p>x : BlockDataContainer and must have as many rows as self.length</p>
<p>returns ..math:: sum(f_i(x_i))</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.BlockFunction.convex_conjugate">
<code class="sig-name descname"><span class="pre">convex_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/BlockFunction.html#BlockFunction.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the convex conjugate of the BlockFunction at <span class="math notranslate nohighlight">\(x^{*}\)</span>.</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \overset{m}{\underset{i=1}{\sum}}f_{i}^{*}(x^{*}_{i})\]</div>
<p>Parameter:</p>
<blockquote>
<div><p>x : BlockDataContainer and must have as many rows as self.length</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.BlockFunction.proximal">
<code class="sig-name descname"><span class="pre">proximal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/BlockFunction.html#BlockFunction.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Proximal operator of the BlockFunction at x:</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) =  (\mathrm{prox}_{\tau f_{i}}(x_{i}))_{i=1}^{m}\]</div>
<p>Parameter:</p>
<blockquote>
<div><p>x : BlockDataContainer and must have as many rows as self.length</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.BlockFunction.gradient">
<code class="sig-name descname"><span class="pre">gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/BlockFunction.html#BlockFunction.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of the BlockFunction function at x.</p>
<div class="math notranslate nohighlight">
\[F'(x) = [f_{1}'(x_{1}), ... , f_{m}'(x_{m})]\]</div>
<p>Parameter:</p>
<blockquote>
<div><p>x : BlockDataContainer and must have as many rows as self.length</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.BlockFunction.proximal_conjugate">
<code class="sig-name descname"><span class="pre">proximal_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/BlockFunction.html#BlockFunction.proximal_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.proximal_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Proximal operator of the convex conjugate of BlockFunction at x:</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F^{*}}(x) = (\mathrm{prox}_{\tau f^{*}_{i}}(x^{*}_{i}))_{i=1}^{m}\]</div>
<p>Parameter:</p>
<blockquote>
<div><p>x : BlockDataContainer and must have as many rows as self.length</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.BlockFunction.__rmul__">
<code class="sig-name descname"><span class="pre">__rmul__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/BlockFunction.html#BlockFunction.__rmul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.__rmul__" title="Permalink to this definition">#</a></dt>
<dd><p>Define multiplication with a scalar</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> – number</p>
</dd>
</dl>
<p>Returns a new <a class="reference external" href="optimisation.html#cil.optimisation.functions.BlockFunction">BlockFunction</a> containing the product of the scalar with all the functions in the block</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="block-operator">
<h2>Block Operator<a class="headerlink" href="#block-operator" title="Permalink to this headline">#</a></h2>
<p><a class="reference external" href="optimisation.html#cil.optimisation.operators.BlockOperators">BlockOperator</a> represent a block matrix with operators</p>
<div class="math notranslate nohighlight">
\[\begin{split}K = \begin{bmatrix}
     A_{1} &amp; A_{2} \\
     A_{3} &amp; A_{4} \\
     A_{5} &amp; A_{6}
\end{bmatrix}_{(3,2)} *  \quad \underbrace{\begin{bmatrix}
x_{1} \\
x_{2}
\end{bmatrix}_{(2,1)}}_{\textbf{x}} =  \begin{bmatrix}
A_{1}x_{1}  + A_{2}x_{2}\\
A_{3}x_{1}  + A_{4}x_{2}\\
A_{5}x_{1}  + A_{6}x_{2}\\
\end{bmatrix}_{(3,1)} =  \begin{bmatrix}
y_{1}\\
y_{2}\\
y_{3}
\end{bmatrix}_{(3,1)} = \textbf{y}\end{split}\]</div>
<p>Column: Share the same domains <span class="math notranslate nohighlight">\(X_{1}, X_{2}\)</span></p>
<p>Rows: Share the same ranges <span class="math notranslate nohighlight">\(Y_{1}, Y_{2}, Y_{3}\)</span></p>
<div class="math notranslate nohighlight">
\[K : (X_{1}\times X_{2}) \rightarrow (Y_{1}\times Y_{2} \times Y_{3})\]</div>
<p><span class="math notranslate nohighlight">\(A_{1}, A_{3}, A_{5}\)</span>: share the same domain <span class="math notranslate nohighlight">\(X_{1}\)</span> and
<span class="math notranslate nohighlight">\(A_{2}, A_{4}, A_{6}\)</span>: share the same domain <span class="math notranslate nohighlight">\(X_{2}\)</span></p>
<div class="math notranslate nohighlight">
\[\begin{split}A_{1}: X_{1} \rightarrow Y_{1} \\
A_{3}: X_{1} \rightarrow Y_{2} \\
A_{5}: X_{1} \rightarrow Y_{3} \\
A_{2}: X_{2} \rightarrow Y_{1} \\
A_{4}: X_{2} \rightarrow Y_{2} \\
A_{6}: X_{2} \rightarrow Y_{3}\end{split}\]</div>
<p>For instance with these ingredients one may write the following objective
function,</p>
<div class="math notranslate nohighlight">
\[\alpha ||\nabla u||_{2,1} + ||u - g||_2^2\]</div>
<p>where <span class="math notranslate nohighlight">\(g\)</span> represent the measured values, <span class="math notranslate nohighlight">\(u\)</span> the solution
<span class="math notranslate nohighlight">\(\nabla\)</span> is the gradient operator, <span class="math notranslate nohighlight">\(|| ~~ ||_{2,1}\)</span> is a norm for
the output of the gradient operator and <span class="math notranslate nohighlight">\(|| x-g ||^2_2\)</span> is
least squares fidelity function as</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}K = \begin{bmatrix}
          \nabla \\
          \mathbb{1}
        \end{bmatrix}\end{split}\\F(x) = \Big[ \alpha \lVert ~x~ \rVert_{2,1} ~~ , ~~ || x - g||_2^2 \Big]\\w = [ u ]\end{aligned}\end{align} \]</div>
<p>Then we have rewritten the problem as</p>
<div class="math notranslate nohighlight">
\[F(Kw) =   \alpha \left\lVert \nabla u \right\rVert_{2,1} + ||u-g||^2_2\]</div>
<p>Which in Python would be like</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">op1</span> <span class="o">=</span> <span class="n">GradientOperator</span><span class="p">(</span><span class="n">ig</span><span class="p">,</span> <span class="n">correlation</span><span class="o">=</span><span class="n">GradientOperator</span><span class="o">.</span><span class="n">CORRELATION_SPACE</span><span class="p">)</span>
<span class="n">op2</span> <span class="o">=</span> <span class="n">IdentityOperator</span><span class="p">(</span><span class="n">ig</span><span class="p">,</span> <span class="n">ag</span><span class="p">)</span>

<span class="c1"># Create BlockOperator</span>
<span class="n">K</span> <span class="o">=</span> <span class="n">BlockOperator</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>

<span class="c1"># Create functions</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">BlockFunction</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">MixedL21Norm</span><span class="p">(),</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">L2NormSquared</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="n">noisy_data</span><span class="p">))</span>
</pre></div>
</div>
<dl class="py class">
<dt id="cil.optimisation.operators.BlockOperator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">BlockOperator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator" title="Permalink to this definition">#</a></dt>
<dd><p>A Block matrix containing Operators</p>
<p>The Block Framework is a generic strategy to treat variational problems in the
following form:</p>
<div class="math notranslate nohighlight">
\[\min Regulariser + Fidelity\]</div>
<p>BlockOperators have a generic shape M x N, and when applied on an
Nx1 BlockDataContainer, will yield and Mx1 BlockDataContainer.
Notice: BlockDatacontainer are only allowed to have the shape of N x 1, with
N rows and 1 column.</p>
<p>User may specify the shape of the block, by default is a row vector</p>
<p>Operators in a Block are required to have the same domain column-wise and the
same range row-wise.</p>
<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Class creator</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Do not include the <cite>self</cite> parameter in the <code class="docutils literal notranslate"><span class="pre">Args</span></code> section.</p>
</div>
<p>:param : param: vararg (Operator): Operators in the block.
:param : param: shape (<code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code>, optional): If shape is passed the Operators in</p>
<blockquote>
<div><p>vararg are considered input in a row-by-row fashion.
Shape and number of Operators must match.</p>
</div></blockquote>
<p class="rubric">Example</p>
<p>BlockOperator(op0,op1) results in a row block
BlockOperator(op0,op1,shape=(1,2)) results in a column block</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.column_wise_compatible">
<code class="sig-name descname"><span class="pre">column_wise_compatible</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.column_wise_compatible"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.column_wise_compatible" title="Permalink to this definition">#</a></dt>
<dd><p>Operators in a Block should have the same domain per column</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.row_wise_compatible">
<code class="sig-name descname"><span class="pre">row_wise_compatible</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.row_wise_compatible"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.row_wise_compatible" title="Permalink to this definition">#</a></dt>
<dd><p>Operators in a Block should have the same range per row</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.get_item">
<code class="sig-name descname"><span class="pre">get_item</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">row</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.get_item"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.get_item" title="Permalink to this definition">#</a></dt>
<dd><p>returns the Operator at specified row and col</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.norm">
<code class="sig-name descname"><span class="pre">norm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.norm" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the norm of the BlockOperator</p>
<p>if the operator in the block do not have method norm defined, i.e. they are SIRF
AcquisitionModel’s we use PowerMethod if applicable, otherwise we raise an Error</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.direct">
<code class="sig-name descname"><span class="pre">direct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Direct operation for the BlockOperator</p>
<p>BlockOperator work on BlockDataContainer, but they will work on DataContainers
and inherited classes by simple wrapping the input in a BlockDataContainer of shape (1,1)</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.adjoint">
<code class="sig-name descname"><span class="pre">adjoint</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>Adjoint operation for the BlockOperator</p>
<p>BlockOperator may contain both LinearOperator and Operator
This method exists in BlockOperator as it is not known what type of
Operator it will contain.</p>
<p>BlockOperator work on BlockDataContainer, but they will work on DataContainers
and inherited classes by simple wrapping the input in a BlockDataContainer of shape (1,1)</p>
<p>Raises: ValueError if the contained Operators are not linear</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.is_linear">
<code class="sig-name descname"><span class="pre">is_linear</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.is_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.is_linear" title="Permalink to this definition">#</a></dt>
<dd><p>returns whether all the elements of the BlockOperator are linear</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.get_output_shape">
<code class="sig-name descname"><span class="pre">get_output_shape</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xshape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adjoint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.get_output_shape"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.get_output_shape" title="Permalink to this definition">#</a></dt>
<dd><p>returns the shape of the output BlockDataContainer</p>
<p>A(N,M) direct u(M,1) -&gt; N,1
A(N,M)^T adjoint u(N,1) -&gt; M,1</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.__rmul__">
<code class="sig-name descname"><span class="pre">__rmul__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scalar</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.__rmul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.__rmul__" title="Permalink to this definition">#</a></dt>
<dd><p>Defines the left multiplication with a scalar</p>
<dl class="field-list simple">
<dt class="field-odd">Paramer scalar</dt>
<dd class="field-odd"><p>(number or iterable containing numbers):</p>
</dd>
</dl>
<p>Returns: a block operator with Scaled Operators inside</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.T">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">T</span></code><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.T" title="Permalink to this definition">#</a></dt>
<dd><p>Return the transposed of self</p>
<p>input in a row-by-row</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.domain_geometry">
<code class="sig-name descname"><span class="pre">domain_geometry</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.domain_geometry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.domain_geometry" title="Permalink to this definition">#</a></dt>
<dd><p>returns the domain of the BlockOperator</p>
<p>If the shape of the BlockOperator is (N,1) the domain is a ImageGeometry or AcquisitionGeometry.
Otherwise it is a BlockGeometry.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.range_geometry">
<code class="sig-name descname"><span class="pre">range_geometry</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.range_geometry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.range_geometry" title="Permalink to this definition">#</a></dt>
<dd><p>returns the range of the BlockOperator</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.__getitem__">
<code class="sig-name descname"><span class="pre">__getitem__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.__getitem__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.__getitem__" title="Permalink to this definition">#</a></dt>
<dd><p>returns the index-th operator in the block irrespectively of it’s shape</p>
</dd></dl>

</dd></dl>

<p><a class="reference internal" href="index.html#mastertoc"><span class="std std-ref">Return Home</span></a></p>
<div class="section" id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<div class="docutils container" id="id16">
<dl class="citation">
<dt class="label" id="id17"><span class="brackets"><a class="fn-backref" href="#id6">1</a></span></dt>
<dd><p>Antonin Chambolle and Thomas Pock. A first-order primal-dual algorithm for convex problems with applications to imaging. <em>Journal of Mathematical Imaging and Vision</em>, 40(1):120–145, May 2011. URL: <a class="reference external" href="https://doi.org/10.1007/s10851-010-0251-1">https://doi.org/10.1007/s10851-010-0251-1</a>, <a class="reference external" href="https://doi.org/10.1007/s10851-010-0251-1">doi:10.1007/s10851-010-0251-1</a>.</p>
</dd>
<dt class="label" id="id18"><span class="brackets"><a class="fn-backref" href="#id7">2</a></span></dt>
<dd><p>Ernie Esser, Xiaoqun Zhang, and Tony F. Chan. A general framework for a class of first order primal-dual algorithms for convex optimization in imaging science. <em>SIAM Journal on Imaging Sciences</em>, 3(4):1015–1046, 2010. URL: <a class="reference external" href="https://doi.org/10.1137/09076934X">https://doi.org/10.1137/09076934X</a>, <a class="reference external" href="https://arxiv.org/abs/https://doi.org/10.1137/09076934X">arXiv:https://doi.org/10.1137/09076934X</a>, <a class="reference external" href="https://doi.org/10.1137/09076934X">doi:10.1137/09076934X</a>.</p>
</dd>
<dt class="label" id="id20"><span class="brackets"><a class="fn-backref" href="#id8">3</a></span></dt>
<dd><p>J. S. Jörgensen, E. Ametova, G. Burca, G. Fardell, E. Papoutsellis, E. Pasca, K. Thielemans, M. Turner, R. Warr, W. R. B. Lionheart, and P. J. Withers. Core imaging library - part i: a versatile python framework for tomographic imaging. <em>Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences</em>, 379(2204):20200192, 2021. URL: <a class="reference external" href="https://royalsocietypublishing.org/doi/abs/10.1098/rsta.2020.0192">https://royalsocietypublishing.org/doi/abs/10.1098/rsta.2020.0192</a>, <a class="reference external" href="https://arxiv.org/abs/https://royalsocietypublishing.org/doi/pdf/10.1098/rsta.2020.0192">arXiv:https://royalsocietypublishing.org/doi/pdf/10.1098/rsta.2020.0192</a>, <a class="reference external" href="https://doi.org/10.1098/rsta.2020.0192">doi:10.1098/rsta.2020.0192</a>.</p>
</dd>
<dt class="label" id="id21"><span class="brackets"><a class="fn-backref" href="#id5">4</a></span></dt>
<dd><p>Avinash C. Kak and Malcolm Slaney. <em>Principles of Computerized Tomographic Imaging</em>. Society for Industrial and Applied Mathematics, January 2001. URL: <a class="reference external" href="https://doi.org/10.1137/1.9780898719277">https://doi.org/10.1137/1.9780898719277</a>, <a class="reference external" href="https://doi.org/10.1137/1.9780898719277">doi:10.1137/1.9780898719277</a>.</p>
</dd>
<dt class="label" id="id19"><span class="brackets"><a class="fn-backref" href="#id9">5</a></span></dt>
<dd><p>Evangelos Papoutsellis, Evelina Ametova, Claire Delplancke, Gemma Fardell, Jakob S. Jörgensen, Edoardo Pasca, Martin Turner, Ryan Warr, William R. B. Lionheart, and Philip J. Withers. Core imaging library - part ii: multichannel reconstruction for dynamic and spectral tomography. <em>Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences</em>, 379(2204):20200193, 2021. URL: <a class="reference external" href="https://royalsocietypublishing.org/doi/abs/10.1098/rsta.2020.0193">https://royalsocietypublishing.org/doi/abs/10.1098/rsta.2020.0193</a>, <a class="reference external" href="https://arxiv.org/abs/https://royalsocietypublishing.org/doi/pdf/10.1098/rsta.2020.0193">arXiv:https://royalsocietypublishing.org/doi/pdf/10.1098/rsta.2020.0193</a>, <a class="reference external" href="https://doi.org/10.1098/rsta.2020.0193">doi:10.1098/rsta.2020.0193</a>.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>


              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="io.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Read/ write AcquisitionData and ImageData</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="processors.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Processors</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
              
          </main>
          

      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2017-2021 UKRI-STFC, University of Manchester.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.5.4.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>