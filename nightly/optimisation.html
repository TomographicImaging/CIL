
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Optimisation framework &#8212; CIL 23.1.0 documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/styles/pydata-sphinx-theme.css" type="text/css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Processors" href="processors.html" />
    <link rel="prev" title="Read/ write AcquisitionData and ImageData" href="io.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    
<a class="navbar-brand" href="index.html">
<p class="title">CIL</p>
</a>

    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="introduction.html">
  Introduction
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="framework.html">
  Framework
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="io.html">
  Read/ write AcquisitionData and ImageData
 </a>
</li>

<li class="toctree-l1 current active nav-item">
 <a class="current reference internal nav-link" href="#">
  Optimisation framework
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="processors.html">
  Processors
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="recon.html">
  Recon
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="utilities.html">
  Utilities
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="plugins.html">
  CIL Plugins
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="developer_guide.html">
  Developers’ Guide
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
              <div class="sidebar-start-items">
<h3><a href="index.html">Table of Contents</a></h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="framework.html">Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="io.html">Read/ write AcquisitionData and ImageData</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Optimisation framework</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#algorithms">Algorithms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#base-class">Base class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#gd">GD</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cgls">CGLS</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sirt">SIRT</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ista">ISTA</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fista">FISTA</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pdhg">PDHG</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ladmm">LADMM</a></li>
<li class="toctree-l3"><a class="reference internal" href="#spdhg">SPDHG</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#operators">Operators</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#operator-base-classes">Operator base classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#trivial-operators">Trivial operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#gradientoperator">GradientOperator</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#functions">Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#base-classes">Base classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simple-functions">Simple functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#composition-of-operator-and-a-function">Composition of operator and a function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#indicator-box">Indicator box</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kullbackleibler">KullbackLeibler</a></li>
<li class="toctree-l3"><a class="reference internal" href="#l1-norm">L1 Norm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#squared-l2-norm-squared">Squared L2 norm squared</a></li>
<li class="toctree-l3"><a class="reference internal" href="#least-squares">Least Squares</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mixed-l21-norm">Mixed L21 norm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#smooth-mixed-l21-norm">Smooth Mixed L21 norm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mixed-l11-norm">Mixed L11 norm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#total-variation">Total variation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#block-framework">Block Framework</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#blockdatacontainer">BlockDataContainer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#block-function">Block Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="#block-operator">Block Operator</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="processors.html">Processors</a></li>
<li class="toctree-l1"><a class="reference internal" href="recon.html">Recon</a></li>
<li class="toctree-l1"><a class="reference internal" href="utilities.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="plugins.html">CIL Plugins</a></li>
<li class="toctree-l1"><a class="reference internal" href="developer_guide.html">Developers’ Guide</a></li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/optimisation.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
              </div>
              <div class="sidebar-end-items">
              </div>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage mt-5 pt-1 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#">
   Optimisation framework
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#algorithms">
     Algorithms
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#base-class">
       Base class
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#gd">
       GD
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#cgls">
       CGLS
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#sirt">
       SIRT
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#ista">
       ISTA
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#fista">
       FISTA
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#pdhg">
       PDHG
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#ladmm">
       LADMM
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#spdhg">
       SPDHG
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#operators">
     Operators
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#operator-base-classes">
       Operator base classes
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#trivial-operators">
       Trivial operators
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#gradientoperator">
       GradientOperator
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#functions">
     Functions
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#base-classes">
       Base classes
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#simple-functions">
       Simple functions
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#composition-of-operator-and-a-function">
       Composition of operator and a function
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#indicator-box">
       Indicator box
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#kullbackleibler">
       KullbackLeibler
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#l1-norm">
       L1 Norm
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#squared-l2-norm-squared">
       Squared L2 norm squared
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#least-squares">
       Least Squares
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#mixed-l21-norm">
       Mixed L21 norm
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#smooth-mixed-l21-norm">
       Smooth Mixed L21 norm
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#mixed-l11-norm">
       Mixed L11 norm
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#total-variation">
       Total variation
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#block-framework">
   Block Framework
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#blockdatacontainer">
     BlockDataContainer
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#block-function">
     Block Function
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#block-operator">
     Block Operator
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#references">
       References
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <div class="section" id="optimisation-framework">
<h1>Optimisation framework<a class="headerlink" href="#optimisation-framework" title="Permalink to this headline">#</a></h1>
<p>This package allows rapid prototyping of optimisation-based reconstruction problems, i.e. defining and solving different optimization problems to enforce different properties on the reconstructed image.</p>
<p>Firstly, it provides an object-oriented framework for defining mathematical operators and functions as well a collection of useful example operators and functions. Both smooth and non-smooth functions can be used.</p>
<p>Further, it provides a number of high-level generic implementations of optimisation algorithms to solve genericlly formulated optimisation problems constructed from operator and function objects.</p>
<p>The fundamental components are:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">Operator</span></code>: A class specifying a (currently linear) operator.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">Function</span></code>: A class specifying mathematical functions such as a least squares data fidelity.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">Algorithm</span></code>: Implementation of an iterative optimisation algorithm to solve a particular generic optimisation problem. Algorithms are iterable Python object which can be run in a for loop. Can be stopped and warm restarted.</p></li>
</ul>
<div class="section" id="algorithms">
<h2>Algorithms<a class="headerlink" href="#algorithms" title="Permalink to this headline">#</a></h2>
<p>A number of generic algorithm implementations are provided including
Gradient Descent (GD), Conjugate Gradient Least Squares (CGLS),
Simultaneous Iterative Reconstruction Technique (SIRT), Primal Dual Hybrid
Gradient (PDHG), Iterative Shrinkage Thresholding Algorithm (ISTA),
and Fast Iterative Shrinkage Thresholding Algorithm (FISTA).</p>
<p>An algorithm is designed for a particular generic optimisation problem accepts and number of
instances of <code class="code docutils literal notranslate"><span class="pre">Function</span></code> derived classes and/or <code class="code docutils literal notranslate"><span class="pre">Operator</span></code> derived classes as input to
define a specific instance of the generic optimisation problem to be solved.
They are iterable objects which can be run in a for loop.
The user can provide a stopping criterion different than the default max_iteration.</p>
<p>New algorithms can be easily created by extending the <code class="code docutils literal notranslate"><span class="pre">Algorithm</span></code> class.
The user is required to implement only 4 methods: set_up, __init__, update and update_objective.</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">set_up</span></code> and <code class="code docutils literal notranslate"><span class="pre">__init__</span></code> are used to configure the algorithm</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">update</span></code> is the actual iteration updating the solution</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">update_objective</span></code> defines how the objective is calculated.</p></li>
</ul>
<p>For example, the implementation of the update of the Gradient Descent
algorithm to minimise a Function will only be:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective_function</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">update_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objective_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>The <code class="code docutils literal notranslate"><span class="pre">Algorithm</span></code> provides the infrastructure to continue iteration, to access the values of the
objective function in subsequent iterations, the time for each iteration, and to provide a nice
print to screen of the status of the optimisation.</p>
<div class="section" id="base-class">
<h3>Base class<a class="headerlink" href="#base-class" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.algorithms.Algorithm">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></code><code class="sig-name descname"><span class="pre">Algorithm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm" title="Permalink to this definition">#</a></dt>
<dd><p>Base class for iterative algorithms</p>
<p>provides the minimal infrastructure.</p>
<p>Algorithms are iterables so can be easily run in a for loop. They will
stop as soon as the stop criterion is met.
The user is required to implement the <code class="code docutils literal notranslate"><span class="pre">set_up</span></code>, <code class="code docutils literal notranslate"><span class="pre">__init__</span></code>, <code class="code docutils literal notranslate"><span class="pre">update</span></code> and
and <code class="code docutils literal notranslate"><span class="pre">update_objective</span></code> methods</p>
<p>A courtesy method <code class="code docutils literal notranslate"><span class="pre">run</span></code> is available to run <code class="code docutils literal notranslate"><span class="pre">n</span></code> iterations. The method accepts
a <code class="code docutils literal notranslate"><span class="pre">callback</span></code> function that receives the current iteration number and the actual objective
value and can be used to trigger print to screens and other user interactions. The <code class="code docutils literal notranslate"><span class="pre">run</span></code>
method will stop when the stopping criterion is met.</p>
<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Constructor</p>
<p>Set the minimal number of parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>max_iteration</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default 0</em>) – maximum number of iterations</p></li>
<li><p><strong>update_objective_interval</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default 1</em>) – the interval every which we would save the current                                       objective. 1 means every iteration, 2 every 2 iteration                                       and so forth. This is by default 1 and should be increased                                       when evaluating the objective is computationally expensive.</p></li>
<li><p><strong>log_file</strong> (<em>str</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – log verbose output to file</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.set_up">
<code class="sig-name descname"><span class="pre">set_up</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.set_up" title="Permalink to this definition">#</a></dt>
<dd><p>Set up the algorithm</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.update">
<code class="sig-name descname"><span class="pre">update</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.update" title="Permalink to this definition">#</a></dt>
<dd><p>A single iteration of the algorithm</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.should_stop">
<code class="sig-name descname"><span class="pre">should_stop</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.should_stop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.should_stop" title="Permalink to this definition">#</a></dt>
<dd><p>default stopping criterion: number of iterations</p>
<p>The user can change this in concrete implementation of iterative algorithms.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.__set_up_logger">
<code class="sig-name descname"><span class="pre">__set_up_logger</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.__set_up_logger" title="Permalink to this definition">#</a></dt>
<dd><p>Set up the logger if desired</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.max_iteration_stop_criterion">
<code class="sig-name descname"><span class="pre">max_iteration_stop_criterion</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.max_iteration_stop_criterion"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.max_iteration_stop_criterion" title="Permalink to this definition">#</a></dt>
<dd><p>default stop criterion for iterative algorithm: max_iteration reached</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.__iter__">
<code class="sig-name descname"><span class="pre">__iter__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.__iter__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.__iter__" title="Permalink to this definition">#</a></dt>
<dd><p>Algorithm is an iterable</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.next">
<code class="sig-name descname"><span class="pre">next</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.next"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.next" title="Permalink to this definition">#</a></dt>
<dd><p>Algorithm is an iterable</p>
<p>python2 backwards compatibility</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.__next__">
<code class="sig-name descname"><span class="pre">__next__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.__next__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.__next__" title="Permalink to this definition">#</a></dt>
<dd><p>Algorithm is an iterable</p>
<p>calling this method triggers update and update_objective</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm._update_previous_solution">
<code class="sig-name descname"><span class="pre">_update_previous_solution</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm._update_previous_solution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm._update_previous_solution" title="Permalink to this definition">#</a></dt>
<dd><p>Update the previous solution with the current one</p>
<p>The concrete algorithm calls update_previous_solution. Normally this would
entail the swapping of pointers:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_old</span>
<span class="bp">self</span><span class="o">.</span><span class="n">x_old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
<span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">tmp</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.get_output">
<code class="sig-name descname"><span class="pre">get_output</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.get_output"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.get_output" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.is_provably_convergent">
<code class="sig-name descname"><span class="pre">is_provably_convergent</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.is_provably_convergent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.is_provably_convergent" title="Permalink to this definition">#</a></dt>
<dd><p>Check if the algorithm is convergent based on the provable convergence criterion.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.get_last_loss">
<code class="sig-name descname"><span class="pre">get_last_loss</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.get_last_loss"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.get_last_loss" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.get_last_objective">
<code class="sig-name descname"><span class="pre">get_last_objective</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.get_last_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.get_last_objective" title="Permalink to this definition">#</a></dt>
<dd><p>alias to get_last_loss</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.update_objective">
<code class="sig-name descname"><span class="pre">update_objective</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.update_objective" title="Permalink to this definition">#</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.iterations">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">iterations</span></code><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.iterations" title="Permalink to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.loss">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">loss</span></code><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.loss" title="Permalink to this definition">#</a></dt>
<dd><p>returns the list of the values of the objective during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when
the update_objective_interval &gt; 1</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.objective">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">objective</span></code><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.objective" title="Permalink to this definition">#</a></dt>
<dd><p>alias of loss</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.max_iteration">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">max_iteration</span></code><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.max_iteration" title="Permalink to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.run">
<code class="sig-name descname"><span class="pre">run</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.run"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.run" title="Permalink to this definition">#</a></dt>
<dd><p>run n iterations and update the user with the callback if specified</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> – number of iterations to run. If not set the algorithm will
run until max_iteration or until stop criterion is reached</p></li>
<li><p><strong>verbose</strong> – sets the verbosity output to screen, 0 no verbose, 1 medium, 2 highly verbose</p></li>
<li><p><strong>callback</strong> – is a function that receives: current iteration number,
last objective function value and the current solution and gets executed at each update_objective_interval</p></li>
<li><p><strong>print_interval</strong> – integer, controls every how many iteration there’s a print to
screen. Notice that printing will not evaluate the objective function
and so the print might be out of sync wrt the calculation of the objective.
In such cases nan will be printed.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="cil.optimisation.algorithms.Algorithm.__weakref__">
<code class="sig-name descname"><span class="pre">__weakref__</span></code><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.__weakref__" title="Permalink to this definition">#</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.Algorithm.verbose_output">
<code class="sig-name descname"><span class="pre">verbose_output</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/Algorithm.html#Algorithm.verbose_output"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.verbose_output" title="Permalink to this definition">#</a></dt>
<dd><p>Creates a nice tabulated output</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="gd">
<h3>GD<a class="headerlink" href="#gd" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.algorithms.GD">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></code><code class="sig-name descname"><span class="pre">GD</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">objective_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/GD.html#GD"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD" title="Permalink to this definition">#</a></dt>
<dd><p>Gradient Descent algorithm</p>
<dl class="py method">
<dt id="cil.optimisation.algorithms.GD.set_up">
<code class="sig-name descname"><span class="pre">set_up</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">objective_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/GD.html#GD.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD.set_up" title="Permalink to this definition">#</a></dt>
<dd><p>initialisation of the algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial</strong> – initial guess</p></li>
<li><p><strong>objective_function</strong> – objective function to be minimised</p></li>
<li><p><strong>step_size</strong> – step size</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.GD.update">
<code class="sig-name descname"><span class="pre">update</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/GD.html#GD.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD.update" title="Permalink to this definition">#</a></dt>
<dd><p>Single iteration</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.GD.update_objective">
<code class="sig-name descname"><span class="pre">update_objective</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/GD.html#GD.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD.update_objective" title="Permalink to this definition">#</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.GD.armijo_rule">
<code class="sig-name descname"><span class="pre">armijo_rule</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/GD.html#GD.armijo_rule"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD.armijo_rule" title="Permalink to this definition">#</a></dt>
<dd><p>Applies the Armijo rule to calculate the step size (step_size)</p>
<p><a class="reference external" href="https://projecteuclid.org/download/pdf_1/euclid.pjm/1102995080">https://projecteuclid.org/download/pdf_1/euclid.pjm/1102995080</a></p>
<p>The Armijo rule runs a while loop to find the appropriate step_size by starting
from a very large number (alpha). The step_size is found by dividing alpha by 2
in an iterative way until a certain criterion is met. To avoid infinite loops, we
add a maximum number of times the while loop is run.</p>
<p>This rule would allow to reach a minimum step_size of 10^-alpha.</p>
<p>if
alpha = numpy.power(10,gamma)
delta = 3
step_size = numpy.power(10, -delta)
with armijo rule we can get to step_size from initial alpha by repeating the while loop k times
where
alpha / 2^k = step_size
10^gamma / 2^k = 10^-delta
2^k = 10^(gamma+delta)
k = gamma+delta / log10(2) approx 3.3 * (gamma+delta)</p>
<p>if we would take by default delta = gamma
kmax = numpy.ceil ( 2 * gamma / numpy.log10(2) )
kmax = numpy.ceil (2 * numpy.log10(alpha) / numpy.log10(2))</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.GD.get_last_loss">
<code class="sig-name descname"><span class="pre">get_last_loss</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.GD.get_last_loss" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.GD.get_last_objective">
<code class="sig-name descname"><span class="pre">get_last_objective</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.GD.get_last_objective" title="Permalink to this definition">#</a></dt>
<dd><p>alias to get_last_loss</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.GD.get_output">
<code class="sig-name descname"><span class="pre">get_output</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.GD.get_output" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.GD.is_provably_convergent">
<code class="sig-name descname"><span class="pre">is_provably_convergent</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.GD.is_provably_convergent" title="Permalink to this definition">#</a></dt>
<dd><p>Check if the algorithm is convergent based on the provable convergence criterion.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.GD.iterations">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">iterations</span></code><a class="headerlink" href="#cil.optimisation.algorithms.GD.iterations" title="Permalink to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.GD.loss">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">loss</span></code><a class="headerlink" href="#cil.optimisation.algorithms.GD.loss" title="Permalink to this definition">#</a></dt>
<dd><p>returns the list of the values of the objective during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when
the update_objective_interval &gt; 1</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.GD.max_iteration">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">max_iteration</span></code><a class="headerlink" href="#cil.optimisation.algorithms.GD.max_iteration" title="Permalink to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.GD.max_iteration_stop_criterion">
<code class="sig-name descname"><span class="pre">max_iteration_stop_criterion</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.GD.max_iteration_stop_criterion" title="Permalink to this definition">#</a></dt>
<dd><p>default stop criterion for iterative algorithm: max_iteration reached</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.GD.next">
<code class="sig-name descname"><span class="pre">next</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.GD.next" title="Permalink to this definition">#</a></dt>
<dd><p>Algorithm is an iterable</p>
<p>python2 backwards compatibility</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.GD.objective">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">objective</span></code><a class="headerlink" href="#cil.optimisation.algorithms.GD.objective" title="Permalink to this definition">#</a></dt>
<dd><p>alias of loss</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.GD.run">
<code class="sig-name descname"><span class="pre">run</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.GD.run" title="Permalink to this definition">#</a></dt>
<dd><p>run n iterations and update the user with the callback if specified</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> – number of iterations to run. If not set the algorithm will
run until max_iteration or until stop criterion is reached</p></li>
<li><p><strong>verbose</strong> – sets the verbosity output to screen, 0 no verbose, 1 medium, 2 highly verbose</p></li>
<li><p><strong>callback</strong> – is a function that receives: current iteration number,
last objective function value and the current solution and gets executed at each update_objective_interval</p></li>
<li><p><strong>print_interval</strong> – integer, controls every how many iteration there’s a print to
screen. Notice that printing will not evaluate the objective function
and so the print might be out of sync wrt the calculation of the objective.
In such cases nan will be printed.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.GD.verbose_output">
<code class="sig-name descname"><span class="pre">verbose_output</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.GD.verbose_output" title="Permalink to this definition">#</a></dt>
<dd><p>Creates a nice tabulated output</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.GD.should_stop">
<code class="sig-name descname"><span class="pre">should_stop</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/GD.html#GD.should_stop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD.should_stop" title="Permalink to this definition">#</a></dt>
<dd><p>default stopping criterion: number of iterations</p>
<p>The user can change this in concrete implementation of iterative algorithms.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="cgls">
<h3>CGLS<a class="headerlink" href="#cgls" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.algorithms.CGLS">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></code><code class="sig-name descname"><span class="pre">CGLS</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/CGLS.html#CGLS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS" title="Permalink to this definition">#</a></dt>
<dd><p>Conjugate Gradient Least Squares algorithm</p>
<p>Problem:</p>
<div class="math notranslate nohighlight">
\[\min || A x - b ||^2_2\]</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>Parameters :</p>
<blockquote>
<div><p>:parameter operator : Linear operator for the inverse problem
:parameter initial : Initial guess ( Default initial = 0)
:parameter data : Acquired data to reconstruct
:parameter tolerance: Tolerance/ Stopping Criterion to end CGLS algorithm</p>
</div></blockquote>
<dl class="simple">
<dt>Reference:</dt><dd><p><a class="reference external" href="https://web.stanford.edu/group/SOL/software/cgls/">https://web.stanford.edu/group/SOL/software/cgls/</a></p>
</dd>
</dl>
<dl class="py method">
<dt id="cil.optimisation.algorithms.CGLS.set_up">
<code class="sig-name descname"><span class="pre">set_up</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/CGLS.html#CGLS.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.set_up" title="Permalink to this definition">#</a></dt>
<dd><p>initialisation of the algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> – Linear operator for the inverse problem</p></li>
<li><p><strong>initial</strong> – Initial guess ( Default initial = 0)</p></li>
<li><p><strong>data</strong> – Acquired data to reconstruct</p></li>
<li><p><strong>tolerance</strong> – Tolerance/ Stopping Criterion to end CGLS algorithm</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.CGLS.update">
<code class="sig-name descname"><span class="pre">update</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/CGLS.html#CGLS.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.update" title="Permalink to this definition">#</a></dt>
<dd><p>single iteration</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.CGLS.update_objective">
<code class="sig-name descname"><span class="pre">update_objective</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/CGLS.html#CGLS.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.update_objective" title="Permalink to this definition">#</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.CGLS.should_stop">
<code class="sig-name descname"><span class="pre">should_stop</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/CGLS.html#CGLS.should_stop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.should_stop" title="Permalink to this definition">#</a></dt>
<dd><p>stopping criterion</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.CGLS.flag">
<code class="sig-name descname"><span class="pre">flag</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/CGLS.html#CGLS.flag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.flag" title="Permalink to this definition">#</a></dt>
<dd><p>returns whether the tolerance has been reached</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.CGLS.get_last_loss">
<code class="sig-name descname"><span class="pre">get_last_loss</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.get_last_loss" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.CGLS.get_last_objective">
<code class="sig-name descname"><span class="pre">get_last_objective</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.get_last_objective" title="Permalink to this definition">#</a></dt>
<dd><p>alias to get_last_loss</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.CGLS.get_output">
<code class="sig-name descname"><span class="pre">get_output</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.get_output" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.CGLS.is_provably_convergent">
<code class="sig-name descname"><span class="pre">is_provably_convergent</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.is_provably_convergent" title="Permalink to this definition">#</a></dt>
<dd><p>Check if the algorithm is convergent based on the provable convergence criterion.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.CGLS.iterations">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">iterations</span></code><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.iterations" title="Permalink to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.CGLS.loss">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">loss</span></code><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.loss" title="Permalink to this definition">#</a></dt>
<dd><p>returns the list of the values of the objective during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when
the update_objective_interval &gt; 1</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.CGLS.max_iteration">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">max_iteration</span></code><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.max_iteration" title="Permalink to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.CGLS.max_iteration_stop_criterion">
<code class="sig-name descname"><span class="pre">max_iteration_stop_criterion</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.max_iteration_stop_criterion" title="Permalink to this definition">#</a></dt>
<dd><p>default stop criterion for iterative algorithm: max_iteration reached</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.CGLS.next">
<code class="sig-name descname"><span class="pre">next</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.next" title="Permalink to this definition">#</a></dt>
<dd><p>Algorithm is an iterable</p>
<p>python2 backwards compatibility</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.CGLS.objective">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">objective</span></code><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.objective" title="Permalink to this definition">#</a></dt>
<dd><p>alias of loss</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.CGLS.run">
<code class="sig-name descname"><span class="pre">run</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.run" title="Permalink to this definition">#</a></dt>
<dd><p>run n iterations and update the user with the callback if specified</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> – number of iterations to run. If not set the algorithm will
run until max_iteration or until stop criterion is reached</p></li>
<li><p><strong>verbose</strong> – sets the verbosity output to screen, 0 no verbose, 1 medium, 2 highly verbose</p></li>
<li><p><strong>callback</strong> – is a function that receives: current iteration number,
last objective function value and the current solution and gets executed at each update_objective_interval</p></li>
<li><p><strong>print_interval</strong> – integer, controls every how many iteration there’s a print to
screen. Notice that printing will not evaluate the objective function
and so the print might be out of sync wrt the calculation of the objective.
In such cases nan will be printed.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.CGLS.verbose_output">
<code class="sig-name descname"><span class="pre">verbose_output</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.verbose_output" title="Permalink to this definition">#</a></dt>
<dd><p>Creates a nice tabulated output</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="sirt">
<h3>SIRT<a class="headerlink" href="#sirt" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.algorithms.SIRT">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></code><code class="sig-name descname"><span class="pre">SIRT</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/SIRT.html#SIRT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SIRT" title="Permalink to this definition">#</a></dt>
<dd><p>Simultaneous Iterative Reconstruction Technique, see <span id="id1">[<a class="reference internal" href="#id30" title="Avinash C. Kak and Malcolm Slaney. Principles of Computerized Tomographic Imaging. Society for Industrial and Applied Mathematics, January 2001. URL: https://doi.org/10.1137/1.9780898719277, doi:10.1137/1.9780898719277.">6</a>]</span>.</p>
<p>Simultaneous Iterative Reconstruction Technique (SIRT) solves
the following problem</p>
<div class="math notranslate nohighlight">
\[A x = b\]</div>
<p>The SIRT algorithm is</p>
<div class="math notranslate nohighlight">
\[x^{k+1} =  \mathrm{proj}_{C}( x^{k} + \omega * D ( A^{T} ( M * (b - Ax) ) ) ),\]</div>
<p>where,
<span class="math notranslate nohighlight">\(M = \frac{1}{A*\mathbb{1}}\)</span>,
<span class="math notranslate nohighlight">\(D = \frac{1}{A^{T}\mathbb{1}}\)</span>,
<span class="math notranslate nohighlight">\(\mathbb{1}\)</span> is a <code class="code docutils literal notranslate"><span class="pre">DataContainer</span></code> of ones,
<span class="math notranslate nohighlight">\(\mathrm{prox}_{C}\)</span> is the projection over a set <span class="math notranslate nohighlight">\(C\)</span>,
and <span class="math notranslate nohighlight">\(\omega\)</span> is the relaxation parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial</strong> (<a class="reference internal" href="framework.html#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>default = None</em>) – Starting point of the algorithm, default value = Zero DataContainer</p></li>
<li><p><strong>operator</strong> (<a class="reference internal" href="#cil.optimisation.operators.LinearOperator" title="cil.optimisation.operators.LinearOperator"><em>LinearOperator</em></a>) – The operator A.</p></li>
<li><p><strong>data</strong> (<a class="reference internal" href="framework.html#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The data b.</p></li>
<li><p><strong>lower</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, default = None) – Lower bound constraint</p></li>
<li><p><strong>upper</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, default = None) – Upper bound constraint</p></li>
<li><p><strong>constraint</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a><em>, </em><em>default = None</em>) – A function with <code class="code docutils literal notranslate"><span class="pre">proximal</span></code> method, e.g., <a class="reference internal" href="#cil.optimisation.functions.IndicatorBox" title="cil.optimisation.functions.IndicatorBox"><code class="xref py py-class docutils literal notranslate"><span class="pre">IndicatorBox</span></code></a> function and <a class="reference internal" href="#cil.optimisation.functions.IndicatorBox.proximal" title="cil.optimisation.functions.IndicatorBox.proximal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">IndicatorBox.proximal()</span></code></a>,
or <a class="reference internal" href="#cil.optimisation.functions.TotalVariation" title="cil.optimisation.functions.TotalVariation"><code class="xref py py-class docutils literal notranslate"><span class="pre">TotalVariation</span></code></a> function and <a class="reference internal" href="#cil.optimisation.functions.TotalVariation.proximal" title="cil.optimisation.functions.TotalVariation.proximal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TotalVariation.proximal()</span></code></a>.</p></li>
<li><p><strong>kwargs</strong> – Keyword arguments used from the base class <a class="reference internal" href="#cil.optimisation.algorithms.Algorithm" title="cil.optimisation.algorithms.Algorithm"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algorithm</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="code docutils literal notranslate"><span class="pre">constraint</span></code> is not passed, <code class="code docutils literal notranslate"><span class="pre">lower</span></code> and <code class="code docutils literal notranslate"><span class="pre">upper</span></code> are used to create an <a class="reference internal" href="#cil.optimisation.functions.IndicatorBox" title="cil.optimisation.functions.IndicatorBox"><code class="xref py py-class docutils literal notranslate"><span class="pre">IndicatorBox</span></code></a> and apply its <code class="code docutils literal notranslate"><span class="pre">proximal</span></code>.</p>
<p>If <code class="code docutils literal notranslate"><span class="pre">constraint</span></code> is passed, <code class="code docutils literal notranslate"><span class="pre">proximal</span></code> method is required to be implemented.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The preconditioning arrays (weights) <code class="code docutils literal notranslate"><span class="pre">M</span></code> and <code class="code docutils literal notranslate"><span class="pre">D</span></code> used in SIRT are defined as</p>
<div class="math notranslate nohighlight">
\[M = \frac{1}{A*\mathbb{1}} = \frac{1}{\sum_{j}a_{i,j}}\]</div>
<div class="math notranslate nohighlight">
\[D = \frac{1}{A*\mathbb{1}} = \frac{1}{\sum_{i}a_{i,j}}\]</div>
</div>
<p class="rubric">Examples</p>
<div class="math notranslate nohighlight">
\[\underset{x}{\mathrm{argmin}} \| x - d\|^{2}\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sirt</span> <span class="o">=</span> <span class="n">SIRT</span><span class="p">(</span><span class="n">initial</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">operator</span> <span class="o">=</span> <span class="n">A</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="p">,</span> <span class="n">max_iteration</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt id="cil.optimisation.algorithms.SIRT.set_up">
<code class="sig-name descname"><span class="pre">set_up</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/SIRT.html#SIRT.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.set_up" title="Permalink to this definition">#</a></dt>
<dd><p>Initialisation of the algorithm</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SIRT.set_relaxation_parameter">
<code class="sig-name descname"><span class="pre">set_relaxation_parameter</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/SIRT.html#SIRT.set_relaxation_parameter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.set_relaxation_parameter" title="Permalink to this definition">#</a></dt>
<dd><p>Set the relaxation parameter <span class="math notranslate nohighlight">\(\omega\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>value</strong> (<em>float</em>) – The relaxation parameter to be applied to the update. Must be between 0 and 2 to guarantee asymptotic convergence.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SIRT.update">
<code class="sig-name descname"><span class="pre">update</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/SIRT.html#SIRT.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.update" title="Permalink to this definition">#</a></dt>
<dd><p>Performs a single iteration of the SIRT algorithm</p>
<div class="math notranslate nohighlight">
\[x^{k+1} =  \mathrm{proj}_{C}( x^{k} + \omega * D ( A^{T} ( M * (b - Ax) ) ) )\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SIRT.update_objective">
<code class="sig-name descname"><span class="pre">update_objective</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/SIRT.html#SIRT.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.update_objective" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the objective</p>
<div class="math notranslate nohighlight">
\[\|A x - b\|^{2}\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SIRT.get_last_loss">
<code class="sig-name descname"><span class="pre">get_last_loss</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.get_last_loss" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SIRT.get_last_objective">
<code class="sig-name descname"><span class="pre">get_last_objective</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.get_last_objective" title="Permalink to this definition">#</a></dt>
<dd><p>alias to get_last_loss</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SIRT.get_output">
<code class="sig-name descname"><span class="pre">get_output</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.get_output" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SIRT.is_provably_convergent">
<code class="sig-name descname"><span class="pre">is_provably_convergent</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.is_provably_convergent" title="Permalink to this definition">#</a></dt>
<dd><p>Check if the algorithm is convergent based on the provable convergence criterion.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SIRT.iterations">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">iterations</span></code><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.iterations" title="Permalink to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SIRT.loss">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">loss</span></code><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.loss" title="Permalink to this definition">#</a></dt>
<dd><p>returns the list of the values of the objective during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when
the update_objective_interval &gt; 1</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SIRT.max_iteration">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">max_iteration</span></code><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.max_iteration" title="Permalink to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SIRT.max_iteration_stop_criterion">
<code class="sig-name descname"><span class="pre">max_iteration_stop_criterion</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.max_iteration_stop_criterion" title="Permalink to this definition">#</a></dt>
<dd><p>default stop criterion for iterative algorithm: max_iteration reached</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SIRT.next">
<code class="sig-name descname"><span class="pre">next</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.next" title="Permalink to this definition">#</a></dt>
<dd><p>Algorithm is an iterable</p>
<p>python2 backwards compatibility</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SIRT.objective">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">objective</span></code><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.objective" title="Permalink to this definition">#</a></dt>
<dd><p>alias of loss</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SIRT.run">
<code class="sig-name descname"><span class="pre">run</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.run" title="Permalink to this definition">#</a></dt>
<dd><p>run n iterations and update the user with the callback if specified</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> – number of iterations to run. If not set the algorithm will
run until max_iteration or until stop criterion is reached</p></li>
<li><p><strong>verbose</strong> – sets the verbosity output to screen, 0 no verbose, 1 medium, 2 highly verbose</p></li>
<li><p><strong>callback</strong> – is a function that receives: current iteration number,
last objective function value and the current solution and gets executed at each update_objective_interval</p></li>
<li><p><strong>print_interval</strong> – integer, controls every how many iteration there’s a print to
screen. Notice that printing will not evaluate the objective function
and so the print might be out of sync wrt the calculation of the objective.
In such cases nan will be printed.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SIRT.should_stop">
<code class="sig-name descname"><span class="pre">should_stop</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.should_stop" title="Permalink to this definition">#</a></dt>
<dd><p>default stopping criterion: number of iterations</p>
<p>The user can change this in concrete implementation of iterative algorithms.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SIRT.verbose_output">
<code class="sig-name descname"><span class="pre">verbose_output</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.verbose_output" title="Permalink to this definition">#</a></dt>
<dd><p>Creates a nice tabulated output</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="ista">
<h3>ISTA<a class="headerlink" href="#ista" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.algorithms.ISTA">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></code><code class="sig-name descname"><span class="pre">ISTA</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/FISTA.html#ISTA"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.ISTA" title="Permalink to this definition">#</a></dt>
<dd><p>Iterative Shrinkage-Thresholding Algorithm, see <span id="id2">[<a class="reference internal" href="#id28" title="Amir Beck and Marc Teboulle. A fast iterative shrinkage-thresholding algorithm for linear inverse problems. SIAM Journal on Imaging Sciences, 2(1):183-202, 2009. URL: https://doi.org/10.1137/080716542, arXiv:https://doi.org/10.1137/080716542, doi:10.1137/080716542.">1</a>]</span>, <span id="id3">[<a class="reference internal" href="#id27" title="Amir Beck and Marc Teboulle. Fast gradient-based algorithms for constrained total variation image denoising and deblurring problems. IEEE Transactions on Image Processing, 18(11):2419-2434, 2009. doi:10.1109/TIP.2009.2028250.">2</a>]</span>.</p>
<p>Iterative Shrinkage-Thresholding Algorithm (ISTA)</p>
<div class="math notranslate nohighlight">
\[x^{k+1} = \mathrm{prox}_{\alpha^{k} g}(x^{k} - \alpha^{k}\nabla f(x^{k}))\]</div>
<p>is used to solve</p>
<div class="math notranslate nohighlight">
\[\min_{x} f(x) + g(x)\]</div>
<p>where <span class="math notranslate nohighlight">\(f\)</span> is differentiable, <span class="math notranslate nohighlight">\(g\)</span> has a <em>simple</em> proximal operator and <span class="math notranslate nohighlight">\(\alpha^{k}\)</span>
is the <code class="code docutils literal notranslate"><span class="pre">step_size</span></code> per iteration.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For a constant step size, i.e., <span class="math notranslate nohighlight">\(a^{k}=a\)</span> for <span class="math notranslate nohighlight">\(k\geq1\)</span>, convergence of ISTA
is guaranteed if</p>
<div class="math notranslate nohighlight">
\[\alpha\in(0, \frac{2}{L}),\]</div>
<p>where <span class="math notranslate nohighlight">\(L\)</span> is the Lipschitz constant of <span class="math notranslate nohighlight">\(f\)</span>, see <span id="id4">[]</span>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial</strong> (<a class="reference internal" href="framework.html#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – Initial guess of ISTA.</p></li>
<li><p><strong>f</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – Differentiable function</p></li>
<li><p><strong>g</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – Convex function with <em>simple</em> proximal operator</p></li>
<li><p><strong>step_size</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, default = None) – Step size for the gradient step of ISTA.
The default <code class="code docutils literal notranslate"><span class="pre">step_size</span></code> is <span class="math notranslate nohighlight">\(\frac{0.99 * 2}{L}.\)</span></p></li>
<li><p><strong>kwargs</strong> (<em>Keyword arguments</em>) – Arguments from the base class <a class="reference internal" href="#cil.optimisation.algorithms.Algorithm" title="cil.optimisation.algorithms.Algorithm"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algorithm</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="math notranslate nohighlight">
\[\underset{x}{\mathrm{argmin}}\|A x - b\|^{2}_{2}\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">LeastSquares</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">ZeroFunction</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ig</span> <span class="o">=</span> <span class="n">Aop</span><span class="o">.</span><span class="n">domain</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ista</span> <span class="o">=</span> <span class="n">ISTA</span><span class="p">(</span><span class="n">initial</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">allocate</span><span class="p">(),</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="p">,</span> <span class="n">max_iteration</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ista</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#cil.optimisation.algorithms.FISTA" title="cil.optimisation.algorithms.FISTA"><code class="xref py py-class docutils literal notranslate"><span class="pre">FISTA</span></code></a>, <a class="reference internal" href="#cil.optimisation.algorithms.GD" title="cil.optimisation.algorithms.GD"><code class="xref py py-class docutils literal notranslate"><span class="pre">GD</span></code></a></p>
</div>
<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.set_step_size">
<code class="sig-name descname"><span class="pre">set_step_size</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">step_size</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/FISTA.html#ISTA.set_step_size"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.set_step_size" title="Permalink to this definition">#</a></dt>
<dd><p>Set default step size.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/FISTA.html#ISTA.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Constructor</p>
<p>Set the minimal number of parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>max_iteration</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default 0</em>) – maximum number of iterations</p></li>
<li><p><strong>update_objective_interval</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default 1</em>) – the interval every which we would save the current                                       objective. 1 means every iteration, 2 every 2 iteration                                       and so forth. This is by default 1 and should be increased                                       when evaluating the objective is computationally expensive.</p></li>
<li><p><strong>log_file</strong> (<em>str</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – log verbose output to file</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.set_up">
<code class="sig-name descname"><span class="pre">set_up</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/FISTA.html#ISTA.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.set_up" title="Permalink to this definition">#</a></dt>
<dd><p>Set up of the algorithm</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.update">
<code class="sig-name descname"><span class="pre">update</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/FISTA.html#ISTA.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.update" title="Permalink to this definition">#</a></dt>
<dd><p>Performs a single iteration of ISTA</p>
<div class="math notranslate nohighlight">
\[x_{k+1} = \mathrm{prox}_{\alpha g}(x_{k} - \alpha\nabla f(x_{k}))\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.get_output">
<code class="sig-name descname"><span class="pre">get_output</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/FISTA.html#ISTA.get_output"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.get_output" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.update_objective">
<code class="sig-name descname"><span class="pre">update_objective</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/FISTA.html#ISTA.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.update_objective" title="Permalink to this definition">#</a></dt>
<dd><p>Updates the objective</p>
<div class="math notranslate nohighlight">
\[f(x) + g(x)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.__delattr__">
<code class="sig-name descname"><span class="pre">__delattr__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__delattr__" title="Permalink to this definition">#</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.__dir__">
<code class="sig-name descname"><span class="pre">__dir__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__dir__" title="Permalink to this definition">#</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.__eq__">
<code class="sig-name descname"><span class="pre">__eq__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__eq__" title="Permalink to this definition">#</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.__format__">
<code class="sig-name descname"><span class="pre">__format__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">format_spec</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__format__" title="Permalink to this definition">#</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.__ge__">
<code class="sig-name descname"><span class="pre">__ge__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__ge__" title="Permalink to this definition">#</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.__getattribute__">
<code class="sig-name descname"><span class="pre">__getattribute__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__getattribute__" title="Permalink to this definition">#</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.__gt__">
<code class="sig-name descname"><span class="pre">__gt__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__gt__" title="Permalink to this definition">#</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.__hash__">
<code class="sig-name descname"><span class="pre">__hash__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__hash__" title="Permalink to this definition">#</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.__init_subclass__">
<code class="sig-name descname"><span class="pre">__init_subclass__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__init_subclass__" title="Permalink to this definition">#</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.__iter__">
<code class="sig-name descname"><span class="pre">__iter__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__iter__" title="Permalink to this definition">#</a></dt>
<dd><p>Algorithm is an iterable</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.__le__">
<code class="sig-name descname"><span class="pre">__le__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__le__" title="Permalink to this definition">#</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.__lt__">
<code class="sig-name descname"><span class="pre">__lt__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__lt__" title="Permalink to this definition">#</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.__ne__">
<code class="sig-name descname"><span class="pre">__ne__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__ne__" title="Permalink to this definition">#</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.__new__">
<code class="sig-name descname"><span class="pre">__new__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__new__" title="Permalink to this definition">#</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.__next__">
<code class="sig-name descname"><span class="pre">__next__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__next__" title="Permalink to this definition">#</a></dt>
<dd><p>Algorithm is an iterable</p>
<p>calling this method triggers update and update_objective</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.__reduce__">
<code class="sig-name descname"><span class="pre">__reduce__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__reduce__" title="Permalink to this definition">#</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.__reduce_ex__">
<code class="sig-name descname"><span class="pre">__reduce_ex__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__reduce_ex__" title="Permalink to this definition">#</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.__repr__">
<code class="sig-name descname"><span class="pre">__repr__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__repr__" title="Permalink to this definition">#</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.__setattr__">
<code class="sig-name descname"><span class="pre">__setattr__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__setattr__" title="Permalink to this definition">#</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.__sizeof__">
<code class="sig-name descname"><span class="pre">__sizeof__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__sizeof__" title="Permalink to this definition">#</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.__str__">
<code class="sig-name descname"><span class="pre">__str__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__str__" title="Permalink to this definition">#</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.__subclasshook__">
<code class="sig-name descname"><span class="pre">__subclasshook__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__subclasshook__" title="Permalink to this definition">#</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="py attribute">
<dt id="cil.optimisation.algorithms.ISTA.__weakref__">
<code class="sig-name descname"><span class="pre">__weakref__</span></code><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.__weakref__" title="Permalink to this definition">#</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.get_last_loss">
<code class="sig-name descname"><span class="pre">get_last_loss</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.get_last_loss" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.get_last_objective">
<code class="sig-name descname"><span class="pre">get_last_objective</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.get_last_objective" title="Permalink to this definition">#</a></dt>
<dd><p>alias to get_last_loss</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.is_provably_convergent">
<code class="sig-name descname"><span class="pre">is_provably_convergent</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.is_provably_convergent" title="Permalink to this definition">#</a></dt>
<dd><p>Check if the algorithm is convergent based on the provable convergence criterion.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.iterations">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">iterations</span></code><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.iterations" title="Permalink to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.loss">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">loss</span></code><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.loss" title="Permalink to this definition">#</a></dt>
<dd><p>returns the list of the values of the objective during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when
the update_objective_interval &gt; 1</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.max_iteration">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">max_iteration</span></code><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.max_iteration" title="Permalink to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.max_iteration_stop_criterion">
<code class="sig-name descname"><span class="pre">max_iteration_stop_criterion</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.max_iteration_stop_criterion" title="Permalink to this definition">#</a></dt>
<dd><p>default stop criterion for iterative algorithm: max_iteration reached</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.next">
<code class="sig-name descname"><span class="pre">next</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.next" title="Permalink to this definition">#</a></dt>
<dd><p>Algorithm is an iterable</p>
<p>python2 backwards compatibility</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.objective">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">objective</span></code><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.objective" title="Permalink to this definition">#</a></dt>
<dd><p>alias of loss</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.run">
<code class="sig-name descname"><span class="pre">run</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.run" title="Permalink to this definition">#</a></dt>
<dd><p>run n iterations and update the user with the callback if specified</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> – number of iterations to run. If not set the algorithm will
run until max_iteration or until stop criterion is reached</p></li>
<li><p><strong>verbose</strong> – sets the verbosity output to screen, 0 no verbose, 1 medium, 2 highly verbose</p></li>
<li><p><strong>callback</strong> – is a function that receives: current iteration number,
last objective function value and the current solution and gets executed at each update_objective_interval</p></li>
<li><p><strong>print_interval</strong> – integer, controls every how many iteration there’s a print to
screen. Notice that printing will not evaluate the objective function
and so the print might be out of sync wrt the calculation of the objective.
In such cases nan will be printed.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.should_stop">
<code class="sig-name descname"><span class="pre">should_stop</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.should_stop" title="Permalink to this definition">#</a></dt>
<dd><p>default stopping criterion: number of iterations</p>
<p>The user can change this in concrete implementation of iterative algorithms.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.ISTA.verbose_output">
<code class="sig-name descname"><span class="pre">verbose_output</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.verbose_output" title="Permalink to this definition">#</a></dt>
<dd><p>Creates a nice tabulated output</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="fista">
<h3>FISTA<a class="headerlink" href="#fista" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.algorithms.FISTA">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></code><code class="sig-name descname"><span class="pre">FISTA</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/FISTA.html#FISTA"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.FISTA" title="Permalink to this definition">#</a></dt>
<dd><p>Fast Iterative Shrinkage-Thresholding Algorithm, see <span id="id5">[<a class="reference internal" href="#id28" title="Amir Beck and Marc Teboulle. A fast iterative shrinkage-thresholding algorithm for linear inverse problems. SIAM Journal on Imaging Sciences, 2(1):183-202, 2009. URL: https://doi.org/10.1137/080716542, arXiv:https://doi.org/10.1137/080716542, doi:10.1137/080716542.">1</a>]</span>, <span id="id6">[<a class="reference internal" href="#id27" title="Amir Beck and Marc Teboulle. Fast gradient-based algorithms for constrained total variation image denoising and deblurring problems. IEEE Transactions on Image Processing, 18(11):2419-2434, 2009. doi:10.1109/TIP.2009.2028250.">2</a>]</span>.</p>
<p>Fast Iterative Shrinkage-Thresholding Algorithm (FISTA)</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
    y_{k} = x_{k} - \alpha\nabla f(x_{k})  \\
    x_{k+1} = \mathrm{prox}_{\alpha g}(y_{k})\\
    t_{k+1} = \frac{1+\sqrt{1+ 4t_{k}^{2}}}{2}\\
    y_{k+1} = x_{k} + \frac{t_{k}-1}{t_{k-1}}(x_{k} - x_{k-1})
\end{cases}\end{split}\]</div>
<p>is used to solve</p>
<div class="math notranslate nohighlight">
\[\min_{x} f(x) + g(x)\]</div>
<p>where <span class="math notranslate nohighlight">\(f\)</span> is differentiable, <span class="math notranslate nohighlight">\(g\)</span> has a <em>simple</em> proximal operator and <span class="math notranslate nohighlight">\(\alpha^{k}\)</span>
is the <code class="code docutils literal notranslate"><span class="pre">step_size</span></code> per iteration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial</strong> (<a class="reference internal" href="framework.html#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – Starting point of the algorithm</p></li>
<li><p><strong>f</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – Differentiable function</p></li>
<li><p><strong>g</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – Convex function with <em>simple</em> proximal operator</p></li>
<li><p><strong>step_size</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, default = None) – Step size for the gradient step of FISTA.
The default <code class="code docutils literal notranslate"><span class="pre">step_size</span></code> is <span class="math notranslate nohighlight">\(\frac{1}{L}\)</span>.</p></li>
<li><p><strong>kwargs</strong> (<em>Keyword arguments</em>) – Arguments from the base class <a class="reference internal" href="#cil.optimisation.algorithms.Algorithm" title="cil.optimisation.algorithms.Algorithm"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algorithm</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="math notranslate nohighlight">
\[\underset{x}{\mathrm{argmin}}\|A x - b\|^{2}_{2}\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">LeastSquares</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">ZeroFunction</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ig</span> <span class="o">=</span> <span class="n">Aop</span><span class="o">.</span><span class="n">domain</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fista</span> <span class="o">=</span> <span class="n">FISTA</span><span class="p">(</span><span class="n">initial</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">allocate</span><span class="p">(),</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="p">,</span> <span class="n">max_iteration</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fista</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#cil.optimisation.algorithms.FISTA" title="cil.optimisation.algorithms.FISTA"><code class="xref py py-class docutils literal notranslate"><span class="pre">FISTA</span></code></a>, <a class="reference internal" href="#cil.optimisation.algorithms.GD" title="cil.optimisation.algorithms.GD"><code class="xref py py-class docutils literal notranslate"><span class="pre">GD</span></code></a></p>
</div>
<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.set_step_size">
<code class="sig-name descname"><span class="pre">set_step_size</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">step_size</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/FISTA.html#FISTA.set_step_size"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.set_step_size" title="Permalink to this definition">#</a></dt>
<dd><p>Set the default step size</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/FISTA.html#FISTA.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Constructor</p>
<p>Set the minimal number of parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>max_iteration</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default 0</em>) – maximum number of iterations</p></li>
<li><p><strong>update_objective_interval</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default 1</em>) – the interval every which we would save the current                                       objective. 1 means every iteration, 2 every 2 iteration                                       and so forth. This is by default 1 and should be increased                                       when evaluating the objective is computationally expensive.</p></li>
<li><p><strong>log_file</strong> (<em>str</em><em>, </em><em>optional</em><em>, </em><em>default None</em>) – log verbose output to file</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.update">
<code class="sig-name descname"><span class="pre">update</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/FISTA.html#FISTA.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.update" title="Permalink to this definition">#</a></dt>
<dd><p>Performs a single iteration of FISTA</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
    x_{k+1} = \mathrm{prox}_{\alpha g}(y_{k} - \alpha\nabla f(y_{k}))\\
    t_{k+1} = \frac{1+\sqrt{1+ 4t_{k}^{2}}}{2}\\
    y_{k+1} = x_{k} + \frac{t_{k}-1}{t_{k-1}}(x_{k} - x_{k-1})
\end{cases}\end{split}\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.__delattr__">
<code class="sig-name descname"><span class="pre">__delattr__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__delattr__" title="Permalink to this definition">#</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.__dir__">
<code class="sig-name descname"><span class="pre">__dir__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__dir__" title="Permalink to this definition">#</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.__eq__">
<code class="sig-name descname"><span class="pre">__eq__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__eq__" title="Permalink to this definition">#</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.__format__">
<code class="sig-name descname"><span class="pre">__format__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">format_spec</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__format__" title="Permalink to this definition">#</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.__ge__">
<code class="sig-name descname"><span class="pre">__ge__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__ge__" title="Permalink to this definition">#</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.__getattribute__">
<code class="sig-name descname"><span class="pre">__getattribute__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__getattribute__" title="Permalink to this definition">#</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.__gt__">
<code class="sig-name descname"><span class="pre">__gt__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__gt__" title="Permalink to this definition">#</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.__hash__">
<code class="sig-name descname"><span class="pre">__hash__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__hash__" title="Permalink to this definition">#</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.__init_subclass__">
<code class="sig-name descname"><span class="pre">__init_subclass__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__init_subclass__" title="Permalink to this definition">#</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.__iter__">
<code class="sig-name descname"><span class="pre">__iter__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__iter__" title="Permalink to this definition">#</a></dt>
<dd><p>Algorithm is an iterable</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.__le__">
<code class="sig-name descname"><span class="pre">__le__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__le__" title="Permalink to this definition">#</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.__lt__">
<code class="sig-name descname"><span class="pre">__lt__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__lt__" title="Permalink to this definition">#</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.__ne__">
<code class="sig-name descname"><span class="pre">__ne__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__ne__" title="Permalink to this definition">#</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.__new__">
<code class="sig-name descname"><span class="pre">__new__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__new__" title="Permalink to this definition">#</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.__next__">
<code class="sig-name descname"><span class="pre">__next__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__next__" title="Permalink to this definition">#</a></dt>
<dd><p>Algorithm is an iterable</p>
<p>calling this method triggers update and update_objective</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.__reduce__">
<code class="sig-name descname"><span class="pre">__reduce__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__reduce__" title="Permalink to this definition">#</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.__reduce_ex__">
<code class="sig-name descname"><span class="pre">__reduce_ex__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__reduce_ex__" title="Permalink to this definition">#</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.__repr__">
<code class="sig-name descname"><span class="pre">__repr__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__repr__" title="Permalink to this definition">#</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.__setattr__">
<code class="sig-name descname"><span class="pre">__setattr__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__setattr__" title="Permalink to this definition">#</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.__sizeof__">
<code class="sig-name descname"><span class="pre">__sizeof__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__sizeof__" title="Permalink to this definition">#</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.__str__">
<code class="sig-name descname"><span class="pre">__str__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__str__" title="Permalink to this definition">#</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.__subclasshook__">
<code class="sig-name descname"><span class="pre">__subclasshook__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__subclasshook__" title="Permalink to this definition">#</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="py attribute">
<dt id="cil.optimisation.algorithms.FISTA.__weakref__">
<code class="sig-name descname"><span class="pre">__weakref__</span></code><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.__weakref__" title="Permalink to this definition">#</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.get_last_loss">
<code class="sig-name descname"><span class="pre">get_last_loss</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.get_last_loss" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.get_last_objective">
<code class="sig-name descname"><span class="pre">get_last_objective</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.get_last_objective" title="Permalink to this definition">#</a></dt>
<dd><p>alias to get_last_loss</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.get_output">
<code class="sig-name descname"><span class="pre">get_output</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.get_output" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.is_provably_convergent">
<code class="sig-name descname"><span class="pre">is_provably_convergent</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.is_provably_convergent" title="Permalink to this definition">#</a></dt>
<dd><p>Check if the algorithm is convergent based on the provable convergence criterion.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.iterations">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">iterations</span></code><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.iterations" title="Permalink to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.loss">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">loss</span></code><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.loss" title="Permalink to this definition">#</a></dt>
<dd><p>returns the list of the values of the objective during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when
the update_objective_interval &gt; 1</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.max_iteration">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">max_iteration</span></code><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.max_iteration" title="Permalink to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.max_iteration_stop_criterion">
<code class="sig-name descname"><span class="pre">max_iteration_stop_criterion</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.max_iteration_stop_criterion" title="Permalink to this definition">#</a></dt>
<dd><p>default stop criterion for iterative algorithm: max_iteration reached</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.next">
<code class="sig-name descname"><span class="pre">next</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.next" title="Permalink to this definition">#</a></dt>
<dd><p>Algorithm is an iterable</p>
<p>python2 backwards compatibility</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.objective">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">objective</span></code><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.objective" title="Permalink to this definition">#</a></dt>
<dd><p>alias of loss</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.run">
<code class="sig-name descname"><span class="pre">run</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.run" title="Permalink to this definition">#</a></dt>
<dd><p>run n iterations and update the user with the callback if specified</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> – number of iterations to run. If not set the algorithm will
run until max_iteration or until stop criterion is reached</p></li>
<li><p><strong>verbose</strong> – sets the verbosity output to screen, 0 no verbose, 1 medium, 2 highly verbose</p></li>
<li><p><strong>callback</strong> – is a function that receives: current iteration number,
last objective function value and the current solution and gets executed at each update_objective_interval</p></li>
<li><p><strong>print_interval</strong> – integer, controls every how many iteration there’s a print to
screen. Notice that printing will not evaluate the objective function
and so the print might be out of sync wrt the calculation of the objective.
In such cases nan will be printed.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.set_up">
<code class="sig-name descname"><span class="pre">set_up</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.set_up" title="Permalink to this definition">#</a></dt>
<dd><p>Set up of the algorithm</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.should_stop">
<code class="sig-name descname"><span class="pre">should_stop</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.should_stop" title="Permalink to this definition">#</a></dt>
<dd><p>default stopping criterion: number of iterations</p>
<p>The user can change this in concrete implementation of iterative algorithms.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.update_objective">
<code class="sig-name descname"><span class="pre">update_objective</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.update_objective" title="Permalink to this definition">#</a></dt>
<dd><p>Updates the objective</p>
<div class="math notranslate nohighlight">
\[f(x) + g(x)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.FISTA.verbose_output">
<code class="sig-name descname"><span class="pre">verbose_output</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.verbose_output" title="Permalink to this definition">#</a></dt>
<dd><p>Creates a nice tabulated output</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="pdhg">
<h3>PDHG<a class="headerlink" href="#pdhg" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.algorithms.PDHG">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></code><code class="sig-name descname"><span class="pre">PDHG</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/PDHG.html#PDHG"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG" title="Permalink to this definition">#</a></dt>
<dd><p>Primal Dual Hybrid Gradient (PDHG) algorithm, see <span id="id7">[<a class="reference internal" href="#id23" title="Antonin Chambolle and Thomas Pock. A first-order primal-dual algorithm for convex problems with applications to imaging. Journal of Mathematical Imaging and Vision, 40(1):120-145, May 2011. URL: https://doi.org/10.1007/s10851-010-0251-1, doi:10.1007/s10851-010-0251-1.">3</a>]</span>, <span id="id8">[<a class="reference internal" href="#id24" title="Ernie Esser, Xiaoqun Zhang, and Tony F. Chan. A general framework for a class of first order primal-dual algorithms for convex optimization in imaging science. SIAM Journal on Imaging Sciences, 3(4):1015-1046, 2010. URL: https://doi.org/10.1137/09076934X, arXiv:https://doi.org/10.1137/09076934X, doi:10.1137/09076934X.">4</a>]</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – A convex function with a “simple” proximal method of its conjugate.</p></li>
<li><p><strong>g</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – A convex function with a “simple” proximal.</p></li>
<li><p><strong>operator</strong> (<a class="reference internal" href="#cil.optimisation.operators.LinearOperator" title="cil.optimisation.operators.LinearOperator"><em>LinearOperator</em></a>) – A Linear Operator.</p></li>
<li><p><strong>sigma</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, or <cite>np.ndarray</cite>, <cite>DataContainer</cite>, <cite>BlockDataContainer</cite>, optional, default=None) – Step size for the dual problem.</p></li>
<li><p><strong>tau</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, or <cite>np.ndarray</cite>, <cite>DataContainer</cite>, <cite>BlockDataContainer</cite>, optional, default=None) – Step size for the primal problem.</p></li>
<li><p><strong>initial</strong> (<a class="reference internal" href="framework.html#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Initial point for the PDHG algorithm.</p></li>
<li><p><strong>gamma_g</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, optional, default=None) – Strongly convex constant if the function g is strongly convex. Allows primal acceleration of the PDHG algorithm.</p></li>
<li><p><strong>gamma_fconj</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, optional, default=None) – Strongly convex constant if the convex conjugate of f is strongly convex. Allows dual acceleration of the PDHG algorithm.</p></li>
<li><p><strong>**kwargs</strong> – <p>Keyward arguments used from the base class <a class="reference internal" href="#cil.optimisation.algorithms.Algorithm" title="cil.optimisation.algorithms.Algorithm"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algorithm</span></code></a>.</p>
<dl>
<dt>max_iteration<span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional, default=0</span></dt><dd><p>Maximum number of iterations of the PDHG.</p>
</dd>
<dt>update_objective_interval<span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional, default=1</span></dt><dd><p>Evaluates objectives, e.g., primal/dual/primal-dual gap every <code class="docutils literal notranslate"><span class="pre">update_objective_interval</span></code>.</p>
</dd>
<dt>check_convergence<span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">boolean</span></code>, default=True</span></dt><dd><p>Checks scalar sigma and tau values satisfy convergence criterion</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<p>In our <a class="reference external" href="https://github.com/TomographicImaging/CIL-Demos/blob/main/binder/TomographyReconstruction.ipynb">CIL-Demos</a> repositoryyou can find examples using the PDHG algorithm for different imaging problems, such as Total Variation denoising, Total Generalised Variation inpaintingand Total Variation Tomography reconstruction. More examples can also be found in <span id="id9">[<a class="reference internal" href="#id26" title="J. S. Jörgensen, E. Ametova, G. Burca, G. Fardell, E. Papoutsellis, E. Pasca, K. Thielemans, M. Turner, R. Warr, W. R. B. Lionheart, and P. J. Withers. Core imaging library - part i: a versatile python framework for tomographic imaging. Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences, 379(2204):20200192, 2021. URL: https://royalsocietypublishing.org/doi/abs/10.1098/rsta.2020.0192, arXiv:https://royalsocietypublishing.org/doi/pdf/10.1098/rsta.2020.0192, doi:10.1098/rsta.2020.0192.">5</a>]</span>, <span id="id10">[<a class="reference internal" href="#id25" title="Evangelos Papoutsellis, Evelina Ametova, Claire Delplancke, Gemma Fardell, Jakob S. Jörgensen, Edoardo Pasca, Martin Turner, Ryan Warr, William R. B. Lionheart, and Philip J. Withers. Core imaging library - part ii: multichannel reconstruction for dynamic and spectral tomography. Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences, 379(2204):20200193, 2021. URL: https://royalsocietypublishing.org/doi/abs/10.1098/rsta.2020.0193, arXiv:https://royalsocietypublishing.org/doi/pdf/10.1098/rsta.2020.0193, doi:10.1098/rsta.2020.0193.">7</a>]</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, the strongly convex constants are passed as parameters of PDHG.
In the future, these parameters will be properties of the corresponding functions.</p>
</div>
<p class="rubric">Notes</p>
<p>A first-order primal-dual algorithm for convex optimization problems with known saddle-point structure with applications in imaging.</p>
<p>The general problem considered in the PDHG algorithm is the generic saddle-point problem</p>
<div class="math notranslate nohighlight">
\[\min_{x\in X}\max_{y\in Y} \langle Kx, y \rangle + g(x) - f^{*}(x)\]</div>
<p>where <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> are convex functions with “simple” proximal operators.</p>
<p><span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> are two two finite-dimensional vector spaces with an inner product and representing the domain of <span class="math notranslate nohighlight">\(g\)</span> and <span class="math notranslate nohighlight">\(f^{*}\)</span>, the convex conjugate of <span class="math notranslate nohighlight">\(f\)</span>, respectively.</p>
<p>The operator <span class="math notranslate nohighlight">\(K\)</span> is a continuous linear operator with operator norm defined as</p>
<div class="math notranslate nohighlight">
\[\|K\| = \max\{ \|Kx\| : x\in X, \|x\|\leq1\}\]</div>
<p>The saddle point problem is decomposed into the primal problem:</p>
<div class="math notranslate nohighlight">
\[\min_{x\in X} f(Kx) + g(x),\]</div>
<p>and its corresponding dual problem</p>
<div class="math notranslate nohighlight">
\[\max_{y\in Y} - g^{*}(-K^{*}y) - f^{*}(y).\]</div>
<p>The PDHG algorithm consists of three steps:</p>
<ul class="simple">
<li><p>gradient ascent step for the dual problem,</p></li>
<li><p>gradient descent step for the primal problem and</p></li>
<li><p>an over-relaxation of the primal variable.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[y^{n+1} = \mathrm{prox}_{\sigma f^{*}}(y^{n} + \sigma K \bar{x}^{n})\]</div>
<div class="math notranslate nohighlight">
\[x^{n+1} = \mathrm{prox}_{\tau g}(x^{n} - \tau K^{*}y^{n+1})\]</div>
<div class="math notranslate nohighlight">
\[\bar{x}^{n+1} = x^{n+1} + \theta (x^{n+1} - x^{n})\]</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Convergence is guaranteed if <span class="math notranslate nohighlight">\(\theta\)</span> = 1.0,  the operator norm <span class="math notranslate nohighlight">\(\|K\|\)</span>, the dual step size <span class="math notranslate nohighlight">\(\sigma\)</span> and the primal step size <span class="math notranslate nohighlight">\(\tau\)</span>, satisfy the following inequality:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\tau \sigma \|K\|^2 &lt; 1\]</div>
<ul>
<li><p>By default, the step sizes <span class="math notranslate nohighlight">\(\sigma\)</span> and <span class="math notranslate nohighlight">\(\tau\)</span> are positive scalars and defined as below:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">sigma</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code> and <code class="docutils literal notranslate"><span class="pre">tau</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\sigma = \frac{1}{\|K\|},  \tau = \frac{1}{\|K\|}\]</div>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">tau</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\tau = \frac{1}{\sigma\|K\|^{2}}\]</div>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">sigma</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\sigma = \frac{1}{\tau\|K\|^{2}}\]</div>
</li>
<li><p>To monitor the convergence of the algorithm, we compute the primal/dual objectives and the primal-dual gap in <a class="reference internal" href="#cil.optimisation.algorithms.PDHG.update_objective" title="cil.optimisation.algorithms.PDHG.update_objective"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update_objective()</span></code></a>.</p>
<p>The primal objective is</p>
<div class="math notranslate nohighlight">
\[f(Kx) + g(x)\]</div>
<p>and the dual objective is</p>
<div class="math notranslate nohighlight">
\[- g^{*}(-K^{*}y) - f^{*}(y)\]</div>
<p>The primal-dual gap (or duality gap) is</p>
<div class="math notranslate nohighlight">
\[f(Kx) + g(x) + g^{*}(-K^{*}y) + f^{*}(y)\]</div>
<p>and measures how close is the primal-dual pair (x,y) to the primal-dual solution. It is always non-negative and is used to monitor convergence of the PDHG algorithm. For more information, see <a class="reference external" href="https://en.wikipedia.org/wiki/Duality_gap">Duality Gap</a>.</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>The primal objective is printed if <cite>verbose=1</cite>, <code class="docutils literal notranslate"><span class="pre">pdhg.run(verbose=1)</span></code>.</p></li>
<li><p>All the objectives are printed if <cite>verbose=2</cite>, <code class="docutils literal notranslate"><span class="pre">pdhg.run(verbose=2)</span></code>.</p></li>
</ul>
<p>Computing these objectives can be costly, so it is better to compute every some iterations. To do this, use <code class="docutils literal notranslate"><span class="pre">update_objective_interval</span> <span class="pre">=</span> <span class="pre">#number</span></code>.</p>
</div>
<ul>
<li><p>PDHG algorithm can be accelerated if the functions <span class="math notranslate nohighlight">\(f^{*}\)</span> and/or <span class="math notranslate nohighlight">\(g\)</span> are strongly convex. In these cases, the step-sizes <span class="math notranslate nohighlight">\(\sigma\)</span> and <span class="math notranslate nohighlight">\(\tau\)</span> are updated using the <a class="reference internal" href="#cil.optimisation.algorithms.PDHG.update_step_sizes" title="cil.optimisation.algorithms.PDHG.update_step_sizes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update_step_sizes()</span></code></a> method. A function <span class="math notranslate nohighlight">\(f\)</span> is strongly convex with constant <span class="math notranslate nohighlight">\(\gamma&gt;0\)</span> if</p>
<div class="math notranslate nohighlight">
\[f(x) - \frac{\gamma}{2}\|x\|^{2} \quad\mbox{ is convex. }\]</div>
<ul class="simple">
<li><p>For instance the function <span class="math notranslate nohighlight">\(\frac{1}{2}\|x\|^{2}_{2}\)</span> is <span class="math notranslate nohighlight">\(\gamma\)</span> strongly convex for <span class="math notranslate nohighlight">\(\gamma\in(-\infty,1]\)</span>. We say it is 1-strongly convex because it is the largest constant for which <span class="math notranslate nohighlight">\(f - \frac{1}{2}\|\cdot\|^{2}\)</span> is convex.</p></li>
<li><p>The <span class="math notranslate nohighlight">\(\|\cdot\|_{1}\)</span> norm is not strongly convex. For more information, see <a class="reference external" href="https://en.wikipedia.org/wiki/Convex_function#Strongly_convex_functions">Strongly Convex</a>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(g\)</span> is strongly convex with constant <span class="math notranslate nohighlight">\(\gamma\)</span> then the step-sizes <span class="math notranslate nohighlight">\(\sigma\)</span>, <span class="math notranslate nohighlight">\(\tau\)</span> and <span class="math notranslate nohighlight">\(\theta\)</span> are updated as:</p></li>
</ul>
<div class="math notranslate nohighlight">
   \begin{aligned}

       \theta_{n} &amp; = \frac{1}{\sqrt{1 + 2\gamma\tau_{n}}}\\
       \tau_{n+1} &amp; = \theta_{n}\tau_{n}\\
       \sigma_{n+1} &amp; = \frac{\sigma_{n}}{\theta_{n}}

   \end{aligned}</div><ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(f^{*}\)</span> is strongly convex, we swap <span class="math notranslate nohighlight">\(\sigma\)</span> with <span class="math notranslate nohighlight">\(\tau\)</span>.</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The case where both functions are strongly convex is not available at the moment.</p>
</div>
<div class="admonition-todo admonition" id="id11">
<p class="admonition-title">Todo</p>
<p>Implement acceleration of PDHG when both functions are strongly convex.</p>
</div>
<dl class="py method">
<dt id="cil.optimisation.algorithms.PDHG.set_gamma_g">
<code class="sig-name descname"><span class="pre">set_gamma_g</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/PDHG.html#PDHG.set_gamma_g"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.set_gamma_g" title="Permalink to this definition">#</a></dt>
<dd><p>Set the value of the strongly convex constant for function <cite>g</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>value</strong> (<em>a positive number</em><em> or </em><em>None</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.PDHG.set_gamma_fconj">
<code class="sig-name descname"><span class="pre">set_gamma_fconj</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/PDHG.html#PDHG.set_gamma_fconj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.set_gamma_fconj" title="Permalink to this definition">#</a></dt>
<dd><p>Set the value of the strongly convex constant for the convex conjugate of function <cite>f</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>value</strong> (<em>a positive number</em><em> or </em><em>None</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.PDHG.set_up">
<code class="sig-name descname"><span class="pre">set_up</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/PDHG.html#PDHG.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.set_up" title="Permalink to this definition">#</a></dt>
<dd><p>Initialisation of the algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – A convex function with a “simple” proximal method of its conjugate.</p></li>
<li><p><strong>g</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – A convex function with a “simple” proximal.</p></li>
<li><p><strong>operator</strong> (<a class="reference internal" href="#cil.optimisation.operators.LinearOperator" title="cil.optimisation.operators.LinearOperator"><em>LinearOperator</em></a>) – A Linear Operator.</p></li>
<li><p><strong>sigma</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, or <cite>np.ndarray</cite>, <cite>DataContainer</cite>, <cite>BlockDataContainer</cite>, optional, default=None) – Step size for the dual problem.</p></li>
<li><p><strong>tau</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, or <cite>np.ndarray</cite>, <cite>DataContainer</cite>, <cite>BlockDataContainer</cite>, optional, default=None) – Step size for the primal problem.</p></li>
<li><p><strong>initial</strong> (<a class="reference internal" href="framework.html#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Initial point for the PDHG algorithm.</p></li>
<li><p><strong>theta</strong> (<em>Relaxation parameter</em><em>, </em><em>Number</em><em>, </em><em>default 1.0</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.PDHG.get_output">
<code class="sig-name descname"><span class="pre">get_output</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/PDHG.html#PDHG.get_output"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.get_output" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.PDHG.update">
<code class="sig-name descname"><span class="pre">update</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/PDHG.html#PDHG.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.update" title="Permalink to this definition">#</a></dt>
<dd><p>Performs a single iteration of the PDHG algorithm</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.PDHG.check_convergence">
<code class="sig-name descname"><span class="pre">check_convergence</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/PDHG.html#PDHG.check_convergence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.check_convergence" title="Permalink to this definition">#</a></dt>
<dd><p>Check whether convergence criterion for PDHG is satisfied with scalar values of tau and sigma</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>True if convergence criterion is satisfied. False if not satisfied or convergence is unknown.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.PDHG.set_step_sizes">
<code class="sig-name descname"><span class="pre">set_step_sizes</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/PDHG.html#PDHG.set_step_sizes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.set_step_sizes" title="Permalink to this definition">#</a></dt>
<dd><p>Sets sigma and tau step-sizes for the PDHG algorithm. The step sizes can be either scalar or array-objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sigma</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, or <cite>np.ndarray</cite>, <cite>DataContainer</cite>, <cite>BlockDataContainer</cite>, optional, default=None) – Step size for the dual problem.</p></li>
<li><p><strong>tau</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, or <cite>np.ndarray</cite>, <cite>DataContainer</cite>, <cite>BlockDataContainer</cite>, optional, default=None) – Step size for the primal problem.</p></li>
</ul>
</dd>
</dl>
<p>The user can set either, both or none. Values passed by the user will be accepted as long as they are positive numbers,
or correct shape array like objects.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.PDHG.update_step_sizes">
<code class="sig-name descname"><span class="pre">update_step_sizes</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/PDHG.html#PDHG.update_step_sizes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.update_step_sizes" title="Permalink to this definition">#</a></dt>
<dd><p>Updates step sizes in the cases of primal or dual acceleration using the strongly convexity property. The case where both functions are strongly convex is not available at the moment.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.PDHG.update_objective">
<code class="sig-name descname"><span class="pre">update_objective</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/PDHG.html#PDHG.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.update_objective" title="Permalink to this definition">#</a></dt>
<dd><p>Evaluates the primal objective, the dual objective and the primal-dual gap.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.PDHG.objective">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">objective</span></code><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.objective" title="Permalink to this definition">#</a></dt>
<dd><p>alias of loss</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.PDHG.get_last_loss">
<code class="sig-name descname"><span class="pre">get_last_loss</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.get_last_loss" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.PDHG.get_last_objective">
<code class="sig-name descname"><span class="pre">get_last_objective</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.get_last_objective" title="Permalink to this definition">#</a></dt>
<dd><p>alias to get_last_loss</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.PDHG.is_provably_convergent">
<code class="sig-name descname"><span class="pre">is_provably_convergent</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.is_provably_convergent" title="Permalink to this definition">#</a></dt>
<dd><p>Check if the algorithm is convergent based on the provable convergence criterion.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.PDHG.iterations">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">iterations</span></code><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.iterations" title="Permalink to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.PDHG.loss">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">loss</span></code><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.loss" title="Permalink to this definition">#</a></dt>
<dd><p>returns the list of the values of the objective during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when
the update_objective_interval &gt; 1</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.PDHG.max_iteration">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">max_iteration</span></code><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.max_iteration" title="Permalink to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.PDHG.max_iteration_stop_criterion">
<code class="sig-name descname"><span class="pre">max_iteration_stop_criterion</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.max_iteration_stop_criterion" title="Permalink to this definition">#</a></dt>
<dd><p>default stop criterion for iterative algorithm: max_iteration reached</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.PDHG.next">
<code class="sig-name descname"><span class="pre">next</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.next" title="Permalink to this definition">#</a></dt>
<dd><p>Algorithm is an iterable</p>
<p>python2 backwards compatibility</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.PDHG.run">
<code class="sig-name descname"><span class="pre">run</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.run" title="Permalink to this definition">#</a></dt>
<dd><p>run n iterations and update the user with the callback if specified</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> – number of iterations to run. If not set the algorithm will
run until max_iteration or until stop criterion is reached</p></li>
<li><p><strong>verbose</strong> – sets the verbosity output to screen, 0 no verbose, 1 medium, 2 highly verbose</p></li>
<li><p><strong>callback</strong> – is a function that receives: current iteration number,
last objective function value and the current solution and gets executed at each update_objective_interval</p></li>
<li><p><strong>print_interval</strong> – integer, controls every how many iteration there’s a print to
screen. Notice that printing will not evaluate the objective function
and so the print might be out of sync wrt the calculation of the objective.
In such cases nan will be printed.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.PDHG.should_stop">
<code class="sig-name descname"><span class="pre">should_stop</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.should_stop" title="Permalink to this definition">#</a></dt>
<dd><p>default stopping criterion: number of iterations</p>
<p>The user can change this in concrete implementation of iterative algorithms.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.PDHG.verbose_output">
<code class="sig-name descname"><span class="pre">verbose_output</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.verbose_output" title="Permalink to this definition">#</a></dt>
<dd><p>Creates a nice tabulated output</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="ladmm">
<h3>LADMM<a class="headerlink" href="#ladmm" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.algorithms.LADMM">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></code><code class="sig-name descname"><span class="pre">LADMM</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/ADMM.html#LADMM"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.LADMM" title="Permalink to this definition">#</a></dt>
<dd><p>LADMM is the Linearized Alternating Direction Method of Multipliers (LADMM)</p>
<p>General form of ADMM : min_{x} f(x) + g(y), subject to Ax + By = b</p>
<p>Case: A = Id, B = -K, b = 0   ==&gt; min_x f(Kx) + g(x)</p>
<p>The quadratic term in the augmented Lagrangian is linearized for the x-update.</p>
<p>Main algorithmic difference is that in ADMM we compute two proximal subproblems,
where in the PDHG a proximal and proximal conjugate.</p>
<p>Reference (Section 8) : <a class="reference external" href="https://link.springer.com/content/pdf/10.1007/s10107-018-1321-1.pdf">https://link.springer.com/content/pdf/10.1007/s10107-018-1321-1.pdf</a></p>
<blockquote>
<div><p>x^{k} = prox_{      au f } (x^{k-1} - tau/sigma A^{T}(Ax^{k-1} - z^{k-1} + u^{k-1} )</p>
<p>z^{k} = prox_{sigma g} (Ax^{k} + u^{k-1})</p>
<p>u^{k} = u^{k-1} + Ax^{k} - z^{k}</p>
</div></blockquote>
<dl class="py method">
<dt id="cil.optimisation.algorithms.LADMM.set_up">
<code class="sig-name descname"><span class="pre">set_up</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/ADMM.html#LADMM.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.set_up" title="Permalink to this definition">#</a></dt>
<dd><p>Set up the algorithm</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.LADMM.update">
<code class="sig-name descname"><span class="pre">update</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/ADMM.html#LADMM.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.update" title="Permalink to this definition">#</a></dt>
<dd><p>A single iteration of the algorithm</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.LADMM.update_objective">
<code class="sig-name descname"><span class="pre">update_objective</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/ADMM.html#LADMM.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.update_objective" title="Permalink to this definition">#</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.LADMM.get_last_loss">
<code class="sig-name descname"><span class="pre">get_last_loss</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.get_last_loss" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.LADMM.get_last_objective">
<code class="sig-name descname"><span class="pre">get_last_objective</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.get_last_objective" title="Permalink to this definition">#</a></dt>
<dd><p>alias to get_last_loss</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.LADMM.get_output">
<code class="sig-name descname"><span class="pre">get_output</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.get_output" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.LADMM.is_provably_convergent">
<code class="sig-name descname"><span class="pre">is_provably_convergent</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.is_provably_convergent" title="Permalink to this definition">#</a></dt>
<dd><p>Check if the algorithm is convergent based on the provable convergence criterion.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.LADMM.iterations">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">iterations</span></code><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.iterations" title="Permalink to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.LADMM.loss">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">loss</span></code><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.loss" title="Permalink to this definition">#</a></dt>
<dd><p>returns the list of the values of the objective during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when
the update_objective_interval &gt; 1</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.LADMM.max_iteration">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">max_iteration</span></code><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.max_iteration" title="Permalink to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.LADMM.max_iteration_stop_criterion">
<code class="sig-name descname"><span class="pre">max_iteration_stop_criterion</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.max_iteration_stop_criterion" title="Permalink to this definition">#</a></dt>
<dd><p>default stop criterion for iterative algorithm: max_iteration reached</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.LADMM.next">
<code class="sig-name descname"><span class="pre">next</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.next" title="Permalink to this definition">#</a></dt>
<dd><p>Algorithm is an iterable</p>
<p>python2 backwards compatibility</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.LADMM.objective">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">objective</span></code><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.objective" title="Permalink to this definition">#</a></dt>
<dd><p>alias of loss</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.LADMM.run">
<code class="sig-name descname"><span class="pre">run</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.run" title="Permalink to this definition">#</a></dt>
<dd><p>run n iterations and update the user with the callback if specified</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> – number of iterations to run. If not set the algorithm will
run until max_iteration or until stop criterion is reached</p></li>
<li><p><strong>verbose</strong> – sets the verbosity output to screen, 0 no verbose, 1 medium, 2 highly verbose</p></li>
<li><p><strong>callback</strong> – is a function that receives: current iteration number,
last objective function value and the current solution and gets executed at each update_objective_interval</p></li>
<li><p><strong>print_interval</strong> – integer, controls every how many iteration there’s a print to
screen. Notice that printing will not evaluate the objective function
and so the print might be out of sync wrt the calculation of the objective.
In such cases nan will be printed.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.LADMM.should_stop">
<code class="sig-name descname"><span class="pre">should_stop</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.should_stop" title="Permalink to this definition">#</a></dt>
<dd><p>default stopping criterion: number of iterations</p>
<p>The user can change this in concrete implementation of iterative algorithms.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.LADMM.verbose_output">
<code class="sig-name descname"><span class="pre">verbose_output</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.verbose_output" title="Permalink to this definition">#</a></dt>
<dd><p>Creates a nice tabulated output</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="spdhg">
<h3>SPDHG<a class="headerlink" href="#spdhg" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.algorithms.SPDHG">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></code><code class="sig-name descname"><span class="pre">SPDHG</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/SPDHG.html#SPDHG"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG" title="Permalink to this definition">#</a></dt>
<dd><p>Stochastic Primal Dual Hybrid Gradient</p>
<p>Problem:</p>
<div class="math notranslate nohighlight">
\[\min_{x} f(Kx) + g(x) = \min_{x} \sum f_i(K_i x) + g(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<a class="reference internal" href="#cil.optimisation.functions.BlockFunction" title="cil.optimisation.functions.BlockFunction"><em>BlockFunction</em></a>) – Each must be a convex function with a “simple” proximal method of its conjugate</p></li>
<li><p><strong>g</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – A convex function with a “simple” proximal</p></li>
<li><p><strong>operator</strong> (<a class="reference internal" href="#cil.optimisation.operators.BlockOperator" title="cil.optimisation.operators.BlockOperator"><em>BlockOperator</em></a>) – BlockOperator must contain Linear Operators</p></li>
<li><p><strong>tau</strong> (<em>positive float</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Step size parameter for Primal problem</p></li>
<li><p><strong>sigma</strong> (<em>list of positive float</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – List of Step size parameters for Dual problem</p></li>
<li><p><strong>initial</strong> (<a class="reference internal" href="framework.html#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – Initial point for the SPDHG algorithm</p></li>
<li><p><strong>prob</strong> (<em>list of floats</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – List of probabilities. If None each subset will have probability = 1/number of subsets</p></li>
<li><p><strong>gamma</strong> (<em>float</em>) – parameter controlling the trade-off between the primal and dual step sizes</p></li>
<li><p><strong>**kwargs</strong> – </p></li>
<li><p><strong>norms</strong> (<em>list of floats</em>) – precalculated list of norms of the operators</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<p>Example of usage: See <a class="reference external" href="https://github.com/vais-ral/CIL-Demos/blob/master/Tomography/Simulated/Single%20Channel/PDHG_vs_SPDHG.py">https://github.com/vais-ral/CIL-Demos/blob/master/Tomography/Simulated/Single%20Channel/PDHG_vs_SPDHG.py</a></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Convergence is guaranteed provided that [2, eq. (12)]:</p>
<div class="math notranslate nohighlight">
\[\]</div>
<p>|sigma[i]^{1/2} * K[i] * tau^{1/2} |^2  &lt; p_i for all i</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<dl class="simple">
<dt>Notation for primal and dual step-sizes are reversed with comparison</dt><dd><p>to PDHG.py</p>
</dd>
</dl>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<dl class="simple">
<dt>this code implements serial sampling only, as presented in [2]</dt><dd><p>(to be extended to more general case of [1] as future work)</p>
</dd>
</dl>
</div>
<p class="rubric">References</p>
<p>[1]”Stochastic primal-dual hybrid gradient algorithm with arbitrary
sampling and imaging applications”,
Chambolle, Antonin, Matthias J. Ehrhardt, Peter Richtárik, and Carola-Bibiane Schonlieb,
SIAM Journal on Optimization 28, no. 4 (2018): 2783-2808.</p>
<p>[2]”Faster PET reconstruction with non-smooth priors by randomization and preconditioning”,
Matthias J Ehrhardt, Pawel Markiewicz and Carola-Bibiane Schönlieb,
Physics in Medicine &amp; Biology, Volume 64, Number 22, 2019.</p>
<dl class="py method">
<dt id="cil.optimisation.algorithms.SPDHG.set_up">
<code class="sig-name descname"><span class="pre">set_up</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/SPDHG.html#SPDHG.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.set_up" title="Permalink to this definition">#</a></dt>
<dd><p>set-up of the algorithm
:param f: Each must be a convex function with a “simple” proximal method of its conjugate
:type f: BlockFunction
:param g: A convex function with a “simple” proximal
:type g: Function
:param operator: BlockOperator must contain Linear Operators
:type operator: BlockOperator
:param tau: Step size parameter for Primal problem
:type tau: positive float, optional, default=None
:param sigma: List of Step size parameters for Dual problem
:type sigma: list of positive float, optional, default=None
:param initial: Initial point for the SPDHG algorithm
:type initial: DataContainer, optional, default=None
:param prob: List of probabilities. If None each subset will have probability = 1/number of subsets
:type prob: list of floats, optional, default=None
:param gamma: parameter controlling the trade-off between the primal and dual step sizes
:type gamma: float
:param **kwargs:
:param norms: precalculated list of norms of the operators
:type norms: list of floats</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SPDHG.update">
<code class="sig-name descname"><span class="pre">update</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/SPDHG.html#SPDHG.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.update" title="Permalink to this definition">#</a></dt>
<dd><p>A single iteration of the algorithm</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SPDHG.update_objective">
<code class="sig-name descname"><span class="pre">update_objective</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/algorithms/SPDHG.html#SPDHG.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.update_objective" title="Permalink to this definition">#</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SPDHG.objective">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">objective</span></code><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.objective" title="Permalink to this definition">#</a></dt>
<dd><p>alias of loss</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SPDHG.get_last_loss">
<code class="sig-name descname"><span class="pre">get_last_loss</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.get_last_loss" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function</p>
<p>if update_objective_interval is 1 it is the value of the objective at the current
iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SPDHG.get_last_objective">
<code class="sig-name descname"><span class="pre">get_last_objective</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.get_last_objective" title="Permalink to this definition">#</a></dt>
<dd><p>alias to get_last_loss</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SPDHG.get_output">
<code class="sig-name descname"><span class="pre">get_output</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.get_output" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SPDHG.is_provably_convergent">
<code class="sig-name descname"><span class="pre">is_provably_convergent</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.is_provably_convergent" title="Permalink to this definition">#</a></dt>
<dd><p>Check if the algorithm is convergent based on the provable convergence criterion.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SPDHG.iterations">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">iterations</span></code><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.iterations" title="Permalink to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SPDHG.loss">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">loss</span></code><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.loss" title="Permalink to this definition">#</a></dt>
<dd><p>returns the list of the values of the objective during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when
the update_objective_interval &gt; 1</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SPDHG.max_iteration">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">max_iteration</span></code><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.max_iteration" title="Permalink to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SPDHG.max_iteration_stop_criterion">
<code class="sig-name descname"><span class="pre">max_iteration_stop_criterion</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.max_iteration_stop_criterion" title="Permalink to this definition">#</a></dt>
<dd><p>default stop criterion for iterative algorithm: max_iteration reached</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SPDHG.next">
<code class="sig-name descname"><span class="pre">next</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.next" title="Permalink to this definition">#</a></dt>
<dd><p>Algorithm is an iterable</p>
<p>python2 backwards compatibility</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SPDHG.run">
<code class="sig-name descname"><span class="pre">run</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.run" title="Permalink to this definition">#</a></dt>
<dd><p>run n iterations and update the user with the callback if specified</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> – number of iterations to run. If not set the algorithm will
run until max_iteration or until stop criterion is reached</p></li>
<li><p><strong>verbose</strong> – sets the verbosity output to screen, 0 no verbose, 1 medium, 2 highly verbose</p></li>
<li><p><strong>callback</strong> – is a function that receives: current iteration number,
last objective function value and the current solution and gets executed at each update_objective_interval</p></li>
<li><p><strong>print_interval</strong> – integer, controls every how many iteration there’s a print to
screen. Notice that printing will not evaluate the objective function
and so the print might be out of sync wrt the calculation of the objective.
In such cases nan will be printed.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SPDHG.should_stop">
<code class="sig-name descname"><span class="pre">should_stop</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.should_stop" title="Permalink to this definition">#</a></dt>
<dd><p>default stopping criterion: number of iterations</p>
<p>The user can change this in concrete implementation of iterative algorithms.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.algorithms.SPDHG.verbose_output">
<code class="sig-name descname"><span class="pre">verbose_output</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.verbose_output" title="Permalink to this definition">#</a></dt>
<dd><p>Creates a nice tabulated output</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="operators">
<h2>Operators<a class="headerlink" href="#operators" title="Permalink to this headline">#</a></h2>
<p>The two most important methods are <code class="code docutils literal notranslate"><span class="pre">direct</span></code> and <code class="code docutils literal notranslate"><span class="pre">adjoint</span></code>
methods that describe the result of applying the operator, and its
adjoint respectively, onto a compatible <code class="code docutils literal notranslate"><span class="pre">DataContainer</span></code> input.
The output is another <code class="code docutils literal notranslate"><span class="pre">DataContainer</span></code> object or subclass
hereof. An important special case is to represent the tomographic
forward and backprojection operations.</p>
<div class="section" id="operator-base-classes">
<h3>Operator base classes<a class="headerlink" href="#operator-base-classes" title="Permalink to this headline">#</a></h3>
<p>All operators extend the <code class="code docutils literal notranslate"><span class="pre">Operator</span></code> class. A special class is the <code class="code docutils literal notranslate"><span class="pre">LinearOperator</span></code>
which represents an operator for which the <code class="code docutils literal notranslate"><span class="pre">adjoint</span></code> operation is defined.
A <code class="code docutils literal notranslate"><span class="pre">ScaledOperator</span></code> represents the multiplication of any operator with a scalar.</p>
<dl class="py class">
<dt id="cil.optimisation.operators.Operator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">Operator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator" title="Permalink to this definition">#</a></dt>
<dd><p>Operator that maps from a space X -&gt; Y</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> (<a class="reference internal" href="framework.html#cil.framework.ImageGeometry" title="cil.framework.ImageGeometry"><em>ImageGeometry</em></a><em> or </em><a class="reference internal" href="framework.html#cil.framework.AcquisitionGeometry" title="cil.framework.AcquisitionGeometry"><em>AcquisitionGeometry</em></a>) – domain of the operator</p></li>
<li><p><strong>range_geometry</strong> (<a class="reference internal" href="framework.html#cil.framework.ImageGeometry" title="cil.framework.ImageGeometry"><em>ImageGeometry</em></a><em> or </em><a class="reference internal" href="framework.html#cil.framework.AcquisitionGeometry" title="cil.framework.AcquisitionGeometry"><em>AcquisitionGeometry</em></a><em>, </em><em>optional</em><em>, </em><em>default None</em>) – range of the operator</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="cil.optimisation.operators.Operator.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.Operator.is_linear">
<code class="sig-name descname"><span class="pre">is_linear</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.is_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.is_linear" title="Permalink to this definition">#</a></dt>
<dd><p>Returns if the operator is linear</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.Operator.direct">
<code class="sig-name descname"><span class="pre">direct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the application of the Operator on x</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.Operator.norm">
<code class="sig-name descname"><span class="pre">norm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.norm" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the norm of the Operator. On first call the norm will be calculated using the operator’s calculate_norm
method. Subsequent calls will return the cached norm.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>norm</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>positive:<cite>float</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.Operator.set_norm">
<code class="sig-name descname"><span class="pre">set_norm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.set_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.set_norm" title="Permalink to this definition">#</a></dt>
<dd><p>Sets the norm of the operator to a custom value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>norm</strong> (<em>float</em><em>, </em><em>optional</em>) – Positive real valued number or <cite>None</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The passed values are cached so that when self.norm() is called, the saved value will be returned and not calculated via the power method.
If <cite>None</cite> is passed, the cache is cleared prompting the function to call the power method to calculate the norm the next time self.norm() is called.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.Operator.calculate_norm">
<code class="sig-name descname"><span class="pre">calculate_norm</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.calculate_norm" title="Permalink to this definition">#</a></dt>
<dd><p>Calculates the norm of the Operator</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.Operator.range_geometry">
<code class="sig-name descname"><span class="pre">range_geometry</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.range_geometry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.range_geometry" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the range of the Operator: Y space</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.Operator.domain_geometry">
<code class="sig-name descname"><span class="pre">domain_geometry</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.domain_geometry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.domain_geometry" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the domain of the Operator: X space</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.Operator.__rmul__">
<code class="sig-name descname"><span class="pre">__rmul__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scalar</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.__rmul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.__rmul__" title="Permalink to this definition">#</a></dt>
<dd><p>Defines the multiplication by a scalar on the left</p>
<p>returns a ScaledOperator</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.Operator.__neg__">
<code class="sig-name descname"><span class="pre">__neg__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.__neg__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.__neg__" title="Permalink to this definition">#</a></dt>
<dd><p>Return -self</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.Operator.__sub__">
<code class="sig-name descname"><span class="pre">__sub__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#Operator.__sub__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.__sub__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the subtraction of the operators.</p>
</dd></dl>

<dl class="py attribute">
<dt id="cil.optimisation.operators.Operator.__weakref__">
<code class="sig-name descname"><span class="pre">__weakref__</span></code><a class="headerlink" href="#cil.optimisation.operators.Operator.__weakref__" title="Permalink to this definition">#</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.operators.LinearOperator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">LinearOperator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#LinearOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator" title="Permalink to this definition">#</a></dt>
<dd><p>Linear operator that maps from a space X &lt;-&gt; Y</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> (<a class="reference internal" href="framework.html#cil.framework.ImageGeometry" title="cil.framework.ImageGeometry"><em>ImageGeometry</em></a><em> or </em><a class="reference internal" href="framework.html#cil.framework.AcquisitionGeometry" title="cil.framework.AcquisitionGeometry"><em>AcquisitionGeometry</em></a>) – domain of the operator</p></li>
<li><p><strong>range_geometry</strong> (<a class="reference internal" href="framework.html#cil.framework.ImageGeometry" title="cil.framework.ImageGeometry"><em>ImageGeometry</em></a><em> or </em><a class="reference internal" href="framework.html#cil.framework.AcquisitionGeometry" title="cil.framework.AcquisitionGeometry"><em>AcquisitionGeometry</em></a><em>, </em><em>optional</em><em>, </em><em>default None</em>) – range of the operator</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="cil.optimisation.operators.LinearOperator.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#LinearOperator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.LinearOperator.is_linear">
<code class="sig-name descname"><span class="pre">is_linear</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#LinearOperator.is_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator.is_linear" title="Permalink to this definition">#</a></dt>
<dd><p>Returns if the operator is linear</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.LinearOperator.adjoint">
<code class="sig-name descname"><span class="pre">adjoint</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#LinearOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>returns the adjoint/inverse operation</p>
<p>only available to linear operators</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.LinearOperator.PowerMethod">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">PowerMethod</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iteration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#LinearOperator.PowerMethod"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator.PowerMethod" title="Permalink to this definition">#</a></dt>
<dd><p>Power method or Power iteration algorithm</p>
<p>The Power method computes the largest (dominant) eigenvalue of a matrix in magnitude, e.g.,
absolute value in the real case and modulus in the complex case.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> (<a class="reference internal" href="#cil.optimisation.operators.LinearOperator" title="cil.optimisation.operators.LinearOperator"><em>LinearOperator</em></a>) – </p></li>
<li><p><strong>max_iteration</strong> (positive:<cite>int</cite>, default=10) – Number of iterations for the Power method algorithm.</p></li>
<li><p><strong>initial</strong> (<a class="reference internal" href="framework.html#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>default = None</em>) – Starting point for the Power method.</p></li>
<li><p><strong>tolerance</strong> (positive:<cite>float</cite>, default = 1e-5) – Stopping criterion for the Power method. Check if two consecutive eigenvalue evaluations are below the tolerance.</p></li>
<li><p><strong>return_all</strong> (<cite>boolean</cite>, default = False) – Toggles the verbosity of the return</p></li>
<li><p><strong>method</strong> (<cite>string</cite> one of <cite>“auto”</cite>, <cite>“composed_with_adjoint”</cite> and <cite>“direct_only”</cite>, default = <cite>“auto”</cite>) – The default <cite>auto</cite> lets the code choose the method, this can be specified with <cite>“direct_only”</cite> or <cite>“composed_with_adjoint”</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>dominant eigenvalue</strong> (positive:<cite>float</cite>)</p></li>
<li><p><strong>number of iterations</strong> (positive:<cite>int</cite>) – Number of iterations run. Only returned if return_all is True.</p></li>
<li><p><strong>eigenvector</strong> (<em>DataContainer</em>) – Corresponding eigenvector of the dominant eigenvalue. Only returned if return_all is True.</p></li>
<li><p><strong>list of eigenvalues</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code>) – List of eigenvalues. Only returned if return_all is True.</p></li>
<li><p><strong>convergence</strong> (<cite>boolean</cite>) – Check on wether the difference between the last two iterations is less than tolerance. Only returned if return_all is True.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The power method contains two different algorithms chosen by the <cite>method</cite> flag.</p>
<p>In the case <cite>method=”direct_only”</cite>, for operator, <span class="math notranslate nohighlight">\(A\)</span>, the power method computes the iterations
<span class="math notranslate nohighlight">\(x_{k+1} = A (x_k/\|x_{k}\|)\)</span> initialised with a random vector <span class="math notranslate nohighlight">\(x_0\)</span> and returning the largest (dominant) eigenvalue in magnitude given by <span class="math notranslate nohighlight">\(\|x_k\|\)</span>.</p>
<p>In the case <cite>method=”composed_with_adjoint”</cite>, the algorithm computes the largest (dominant) eigenvalue of <span class="math notranslate nohighlight">\(A^{T}A\)</span>
returning the square root of this value, i.e. the iterations:
<span class="math notranslate nohighlight">\(x_{k+1} = A^TA (x_k/\|x_{k}\|)\)</span> and returning  <span class="math notranslate nohighlight">\(\sqrt{\|x_k\|}\)</span>.</p>
<p>The default flag is <cite>method=”auto”</cite>, the algorithm checks to see if the <cite>operator.domain_geometry() == operator.range_geometry()</cite> and if so
uses the method “direct_only” and if not the method “composed_with_adjoint”.</p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Mop</span> <span class="o">=</span> <span class="n">MatrixOperator</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Mop_norm</span> <span class="o">=</span> <span class="n">Mop</span><span class="o">.</span><span class="n">PowerMethod</span><span class="p">(</span><span class="n">Mop</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Mop_norm</span>
<span class="go">2.0000654846240296</span>
</pre></div>
</div>
<p><cite>PowerMethod</cite> is called when we compute the norm of a matrix or a <cite>LinearOperator</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Mop_norm</span> <span class="o">=</span> <span class="n">Mop</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
<span class="go">2.0005647295658866</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.LinearOperator.calculate_norm">
<code class="sig-name descname"><span class="pre">calculate_norm</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#LinearOperator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator.calculate_norm" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the norm of the LinearOperator calculated by the PowerMethod with default values.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.LinearOperator.dot_test">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">dot_test</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#LinearOperator.dot_test"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator.dot_test" title="Permalink to this definition">#</a></dt>
<dd><p>Does a dot linearity test on the operator
Evaluates if the following equivalence holds
.. math:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Ax</span>\<span class="n">times</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> \<span class="n">times</span> <span class="n">A</span><span class="o">^</span><span class="n">Tx</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> – operator to test the dot_test</p></li>
<li><p><strong>range_init</strong> – optional initialisation container in the operator range</p></li>
<li><p><strong>domain_init</strong> – optional initialisation container in the operator domain</p></li>
<li><p><strong>seed</strong> – Seed random generator</p></li>
</ul>
</dd>
</dl>
<p>:type : int, default = 1
:param tolerance: Check if the following expression is below the tolerance
.. math:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="o">|</span><span class="n">Ax</span>\<span class="n">times</span> <span class="n">y</span> <span class="o">-</span> <span class="n">y</span> \<span class="n">times</span> <span class="n">A</span><span class="o">^</span><span class="n">Tx</span><span class="o">|/</span><span class="p">(</span>\<span class="o">|</span><span class="n">A</span>\<span class="o">|</span>\<span class="o">|</span><span class="n">x</span>\<span class="o">|</span>\<span class="o">|</span><span class="n">y</span>\<span class="o">|</span> <span class="o">+</span> <span class="mf">1e-12</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tolerance</span>
</pre></div>
</div>
<p>:type : float, default 1e-6
:returns: boolean, True if the test is passed.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.operators.ScaledOperator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">ScaledOperator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalar</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#ScaledOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ScaledOperator" title="Permalink to this definition">#</a></dt>
<dd><p>A class to represent the scalar multiplication of an Operator with a scalar.
It holds an operator and a scalar. Basically it returns the multiplication
of the result of direct and adjoint of the operator with the scalar.
For the rest it behaves like the operator it holds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> (<em>a Operator</em><em> or </em><a class="reference internal" href="#cil.optimisation.operators.LinearOperator" title="cil.optimisation.operators.LinearOperator"><em>LinearOperator</em></a>) – </p></li>
<li><p><strong>scalar</strong> (<em>a scalar multiplier</em>) – </p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<p>The scaled operator behaves like the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sop</span> <span class="o">=</span> <span class="n">ScaledOperator</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">scalar</span><span class="p">)</span>
<span class="n">sop</span><span class="o">.</span><span class="n">direct</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">scalar</span> <span class="o">*</span> <span class="n">operator</span><span class="o">.</span><span class="n">direct</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">sop</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">scalar</span> <span class="o">*</span> <span class="n">operator</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">sop</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
<span class="n">sop</span><span class="o">.</span><span class="n">range_geometry</span><span class="p">()</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">range_geometry</span><span class="p">()</span>
<span class="n">sop</span><span class="o">.</span><span class="n">domain_geometry</span><span class="p">()</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">domain_geometry</span><span class="p">()</span>
</pre></div>
</div>
<dl class="py method">
<dt id="cil.optimisation.operators.ScaledOperator.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalar</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#ScaledOperator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ScaledOperator.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.ScaledOperator.direct">
<code class="sig-name descname"><span class="pre">direct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#ScaledOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ScaledOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>direct method</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.ScaledOperator.adjoint">
<code class="sig-name descname"><span class="pre">adjoint</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#ScaledOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ScaledOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>adjoint method</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.ScaledOperator.norm">
<code class="sig-name descname"><span class="pre">norm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#ScaledOperator.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ScaledOperator.norm" title="Permalink to this definition">#</a></dt>
<dd><p>norm of the operator</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.ScaledOperator.is_linear">
<code class="sig-name descname"><span class="pre">is_linear</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#ScaledOperator.is_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ScaledOperator.is_linear" title="Permalink to this definition">#</a></dt>
<dd><p>returns a <cite>boolean</cite> indicating whether the operator is linear</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.operators.CompositionOperator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">CompositionOperator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">operators</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#CompositionOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.CompositionOperator" title="Permalink to this definition">#</a></dt>
<dd><dl class="py method">
<dt id="cil.optimisation.operators.CompositionOperator.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">operators</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#CompositionOperator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.CompositionOperator.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.CompositionOperator.direct">
<code class="sig-name descname"><span class="pre">direct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#CompositionOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.CompositionOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the application of the Operator on x</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.CompositionOperator.is_linear">
<code class="sig-name descname"><span class="pre">is_linear</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#CompositionOperator.is_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.CompositionOperator.is_linear" title="Permalink to this definition">#</a></dt>
<dd><p>Returns if the operator is linear</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.CompositionOperator.calculate_norm">
<code class="sig-name descname"><span class="pre">calculate_norm</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/Operator.html#CompositionOperator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.CompositionOperator.calculate_norm" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the norm of the CompositionOperator, that is the product of the norms
of its operators.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.operators.DiagonalOperator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">DiagonalOperator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diagonal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/DiagonalOperator.html#DiagonalOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.DiagonalOperator" title="Permalink to this definition">#</a></dt>
<dd><p>Performs an element-wise multiplication, i.e., <a class="reference external" href="https://en.wikipedia.org/wiki/Hadamard_product_(matrices)#:~:text=In%20mathematics%2C%20the%20Hadamard%20product,elements%20i%2C%20j%20of%20the">Hadamard Product</a>
of a <code class="xref py py-class docutils literal notranslate"><span class="pre">DataContainer</span></code> <cite>x</cite> and <code class="xref py py-class docutils literal notranslate"><span class="pre">DataContainer</span></code> <cite>diagonal</cite>, <cite>d</cite> .</p>
<div class="math notranslate nohighlight">
\[(D\circ x) = \sum_{i,j}^{M,N} D_{i,j} x_{i, j}\]</div>
<p>In matrix-vector interpretation, if <cite>D</cite> is a <span class="math notranslate nohighlight">\(M\times N\)</span> dense matrix and is flattened, we have a <span class="math notranslate nohighlight">\(M*N \times M*N\)</span> vector.
A sparse diagonal matrix, i.e., <code class="xref py py-class docutils literal notranslate"><span class="pre">DigaonalOperator</span></code> can be created if we add the vector above to the main diagonal.
If the <code class="xref py py-class docutils literal notranslate"><span class="pre">DataContainer</span></code> <cite>x</cite> is also flattened, we have a <span class="math notranslate nohighlight">\(M*N\)</span> vector.
Now, matrix-vector multiplcation is allowed and results to a <span class="math notranslate nohighlight">\((M*N,1)\)</span> vector. After reshaping we recover a <span class="math notranslate nohighlight">\(M\times N\)</span> <code class="xref py py-class docutils literal notranslate"><span class="pre">DataContainer</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>diagonal</strong> (<a class="reference internal" href="framework.html#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – DataContainer with the same dimensions as the data to be operated on.</p></li>
<li><p><strong>domain_geometry</strong> (<a class="reference internal" href="framework.html#cil.framework.ImageGeometry" title="cil.framework.ImageGeometry"><em>ImageGeometry</em></a>) – Specifies the geometry of the operator domain. If ‘None’ will use the diagonal geometry directly. default=None .</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="cil.optimisation.operators.DiagonalOperator.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diagonal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/DiagonalOperator.html#DiagonalOperator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.DiagonalOperator.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.DiagonalOperator.direct">
<code class="sig-name descname"><span class="pre">direct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/DiagonalOperator.html#DiagonalOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.DiagonalOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(D\circ x\)</span></p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.DiagonalOperator.adjoint">
<code class="sig-name descname"><span class="pre">adjoint</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/DiagonalOperator.html#DiagonalOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.DiagonalOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(D\circ x\)</span></p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.DiagonalOperator.calculate_norm">
<code class="sig-name descname"><span class="pre">calculate_norm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/DiagonalOperator.html#DiagonalOperator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.DiagonalOperator.calculate_norm" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the operator norm of DiagonalOperator which is the <span class="math notranslate nohighlight">\(\infty\)</span> norm of <cite>diagonal</cite></p>
<div class="math notranslate nohighlight">
\[\|D\|_{\infty} = \max_{i}\{|D_{i}|\}\]</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.operators.ChannelwiseOperator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">ChannelwiseOperator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'prepend'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ChannelwiseOperator.html#ChannelwiseOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ChannelwiseOperator" title="Permalink to this definition">#</a></dt>
<dd><p>ChannelwiseOperator:  takes in a single-channel operator op and the
number of channels to be used, and creates a new multi-channel
ChannelwiseOperator, which will apply the operator op independently on
each channel for the number of channels specified.</p>
<p>ChannelwiseOperator supports simple operators as input but not
BlockOperators. Typically if such behaviour is desired, it can be achieved
by creating instead a BlockOperator of ChannelwiseOperators.</p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">param op</dt>
<dd class="field-odd"><p>Single-channel operator</p>
</dd>
<dt class="field-even">param channels</dt>
<dd class="field-even"><p>Number of channels</p>
</dd>
<dt class="field-odd">param dimension</dt>
<dd class="field-odd"><p>‘prepend’ (default) or ‘append’ channel dimension onto existing dimensions</p>
</dd>
</dl>
</div></blockquote>
<dl class="py method">
<dt id="cil.optimisation.operators.ChannelwiseOperator.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'prepend'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ChannelwiseOperator.html#ChannelwiseOperator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ChannelwiseOperator.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.ChannelwiseOperator.direct">
<code class="sig-name descname"><span class="pre">direct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ChannelwiseOperator.html#ChannelwiseOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ChannelwiseOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns D(x)</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.ChannelwiseOperator.adjoint">
<code class="sig-name descname"><span class="pre">adjoint</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ChannelwiseOperator.html#ChannelwiseOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ChannelwiseOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>Returns D^{*}(y)</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.ChannelwiseOperator.calculate_norm">
<code class="sig-name descname"><span class="pre">calculate_norm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ChannelwiseOperator.html#ChannelwiseOperator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ChannelwiseOperator.calculate_norm" title="Permalink to this definition">#</a></dt>
<dd><p>Evaluates operator norm of DiagonalOperator</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="trivial-operators">
<h3>Trivial operators<a class="headerlink" href="#trivial-operators" title="Permalink to this headline">#</a></h3>
<p>Trivial operators are the following.</p>
<dl class="py class">
<dt id="cil.optimisation.operators.IdentityOperator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">IdentityOperator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/IdentityOperator.html#IdentityOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.IdentityOperator" title="Permalink to this definition">#</a></dt>
<dd><p>IdentityOperator:  Id: X -&gt; Y,  Id(x) = xin Y</p>
<p>X : gm_domain
Y : gm_range ( Default: Y = X )</p>
<dl class="py method">
<dt id="cil.optimisation.operators.IdentityOperator.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/IdentityOperator.html#IdentityOperator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.IdentityOperator.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.IdentityOperator.direct">
<code class="sig-name descname"><span class="pre">direct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/IdentityOperator.html#IdentityOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.IdentityOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns Id(x)</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.IdentityOperator.adjoint">
<code class="sig-name descname"><span class="pre">adjoint</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/IdentityOperator.html#IdentityOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.IdentityOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>Returns Id(x)</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.IdentityOperator.calculate_norm">
<code class="sig-name descname"><span class="pre">calculate_norm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/IdentityOperator.html#IdentityOperator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.IdentityOperator.calculate_norm" title="Permalink to this definition">#</a></dt>
<dd><p>Evaluates operator norm of IdentityOperator</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.operators.ZeroOperator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">ZeroOperator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ZeroOperator.html#ZeroOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ZeroOperator" title="Permalink to this definition">#</a></dt>
<dd><p>ZeroOperator:  O: X -&gt; Y,  maps any element of <span class="math notranslate nohighlight">\(x\in X\)</span> into the zero element <span class="math notranslate nohighlight">\(\in Y,  O(x) = O_{Y}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gm_domain</strong> – domain of the operator</p></li>
<li><p><strong>gm_range</strong> – range of the operator, default: same as domain</p></li>
</ul>
</dd>
</dl>
<p>Note:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}O^{*}: Y^{*} -&gt; X^{*} \text{(Adjoint)}\\&lt; O(x), y &gt; = &lt; x, O^{*}(y) &gt;\end{aligned}\end{align} \]</div>
<dl class="py method">
<dt id="cil.optimisation.operators.ZeroOperator.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ZeroOperator.html#ZeroOperator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ZeroOperator.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.ZeroOperator.direct">
<code class="sig-name descname"><span class="pre">direct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ZeroOperator.html#ZeroOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ZeroOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns O(x)</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.ZeroOperator.adjoint">
<code class="sig-name descname"><span class="pre">adjoint</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ZeroOperator.html#ZeroOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ZeroOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>Returns O^{*}(y)</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.ZeroOperator.calculate_norm">
<code class="sig-name descname"><span class="pre">calculate_norm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/ZeroOperator.html#ZeroOperator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ZeroOperator.calculate_norm" title="Permalink to this definition">#</a></dt>
<dd><p>Evaluates operator norm of ZeroOperator</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.operators.MatrixOperator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">MatrixOperator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/MatrixOperator.html#MatrixOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.MatrixOperator" title="Permalink to this definition">#</a></dt>
<dd><p>Matrix wrapped into a LinearOperator</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>a numpy matrix</p>
</dd>
</dl>
<dl class="py method">
<dt id="cil.optimisation.operators.MatrixOperator.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/MatrixOperator.html#MatrixOperator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.MatrixOperator.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>A</strong> – numpy ndarray representing a matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.MatrixOperator.direct">
<code class="sig-name descname"><span class="pre">direct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/MatrixOperator.html#MatrixOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.MatrixOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the application of the Operator on x</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.MatrixOperator.adjoint">
<code class="sig-name descname"><span class="pre">adjoint</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/MatrixOperator.html#MatrixOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.MatrixOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>returns the adjoint/inverse operation</p>
<p>only available to linear operators</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.operators.MaskOperator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">MaskOperator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/MaskOperator.html#MaskOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.MaskOperator" title="Permalink to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mask</strong> (<a class="reference internal" href="framework.html#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – Boolean array with the same dimensions as the data to be operated on.</p></li>
<li><p><strong>domain_geometry</strong> (<a class="reference internal" href="framework.html#cil.framework.ImageGeometry" title="cil.framework.ImageGeometry"><em>ImageGeometry</em></a>) – Specifies the geometry of the operator domain. If ‘None’ will use the mask geometry size and spacing as float32. default = None .</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="cil.optimisation.operators.MaskOperator.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/MaskOperator.html#MaskOperator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.MaskOperator.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="gradientoperator">
<h3>GradientOperator<a class="headerlink" href="#gradientoperator" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.operators.GradientOperator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">GradientOperator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'forward'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bnd_cond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Neumann'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/GradientOperator.html#GradientOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.GradientOperator" title="Permalink to this definition">#</a></dt>
<dd><p>Gradient Operator: Computes first-order forward/backward differences on
2D, 3D, 4D ImageData under Neumann/Periodic boundary conditions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> (<a class="reference internal" href="framework.html#cil.framework.ImageGeometry" title="cil.framework.ImageGeometry"><em>ImageGeometry</em></a>) – Set up the domain of the function</p></li>
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>default 'forward'</em>) – Accepts: ‘forward’, ‘backward’, ‘centered’, note C++ optimised routine only works with ‘forward’</p></li>
<li><p><strong>bnd_cond</strong> (<em>str</em><em>, </em><em>default</em><em>,  </em><em>'Neumann'</em>) – Set the boundary conditions to use ‘Neumann’ or ‘Periodic’</p></li>
<li><p><strong>**kwargs</strong> – <dl class="simple">
<dt>correlation: str, default ‘Space’</dt><dd><p>’Space’ will compute the gradient on only the spatial dimensions, ‘SpaceChannels’ will include the channel dimension direction</p>
</dd>
<dt>backend: str, default ‘c’</dt><dd><p>’c’ or ‘numpy’, defaults to ‘c’ if correlation is ‘SpaceChannels’ or channels = 1</p>
</dd>
<dt>num_threads: int</dt><dd><p>If backend is ‘c’ specify the number of threads to use. Default is number of cpus/2</p>
</dd>
<dt>split: boolean</dt><dd><p>If ‘True’, and backend ‘c’ will return a BlockDataContainer with grouped spatial domains. i.e. [Channel, [Z, Y, X]], otherwise [Channel, Z, Y, X]</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a BlockDataContainer containing images of the derivatives order given by <cite>dimension_labels</cite>
i.e. [‘horizontal_y’,’horizontal_x’] will return [d(‘horizontal_y’), d(‘horizontal_x’)]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer">BlockDataContainer</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>2D example</p>
<div class="math notranslate nohighlight">
 \begin{eqnarray}
 \nabla : X \rightarrow Y\\
 u \in X, \nabla(u) &amp;=&amp; [\partial_{y} u, \partial_{x} u]\\
 u^{*} \in Y, \nabla^{*}(u^{*}) &amp;=&amp; \partial_{y} v1 + \partial_{x} v2
 \end{eqnarray}</div><dl class="py method">
<dt id="cil.optimisation.operators.GradientOperator.direct">
<code class="sig-name descname"><span class="pre">direct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/GradientOperator.html#GradientOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.GradientOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the first-order forward differences</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="framework.html#cil.framework.ImageData" title="cil.framework.ImageData"><em>ImageData</em></a>) – </p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>optional</em>) – pre-allocated output memory to store result</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>result data if <cite>out</cite> not specified</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer">BlockDataContainer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.GradientOperator.adjoint">
<code class="sig-name descname"><span class="pre">adjoint</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/GradientOperator.html#GradientOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.GradientOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the first-order backward differences</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>) – Gradient images for each dimension in ImageGeometry domain</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="framework.html#cil.framework.ImageData" title="cil.framework.ImageData"><em>ImageData</em></a><em>, </em><em>optional</em>) – pre-allocated output memory to store result</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>result data if <cite>out</cite> not specified</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="framework.html#cil.framework.ImageData" title="cil.framework.ImageData">ImageData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.GradientOperator.calculate_norm">
<code class="sig-name descname"><span class="pre">calculate_norm</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/GradientOperator.html#GradientOperator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.GradientOperator.calculate_norm" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the analytical norm of the GradientOperator.</p>
<div class="math notranslate nohighlight">
\[\begin{split}(\partial_{z}, \partial_{y}, \partial_{x}) &amp;= \sqrt{\|\partial_{z}\|^{2} + \|\partial_{y}\|^{2} + \|\partial_{x}\|^{2} } \\
&amp;=  \sqrt{ \frac{4}{h_{z}^{2}} + \frac{4}{h_{y}^{2}} + \frac{4}{h_{x}^{2}}}\end{split}\]</div>
<p>Where the voxel sizes in each dimension are equal to 1 this simplifies to:</p>
<blockquote>
<div><ul class="simple">
<li><p>2D geometries <span class="math notranslate nohighlight">\(norm = \sqrt{8}\)</span></p></li>
<li><p>3D geometries <span class="math notranslate nohighlight">\(norm = \sqrt{12}\)</span></p></li>
</ul>
</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.operators.FiniteDifferenceOperator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">FiniteDifferenceOperator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'forward'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bnd_cond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Neumann'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/FiniteDifferenceOperator.html#FiniteDifferenceOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.FiniteDifferenceOperator" title="Permalink to this definition">#</a></dt>
<dd><p>Computes forward/backward/centered finite differences of a DataContainer
under Neumann/Periodic boundary conditions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> – Domain geometry for the FiniteDifferenceOperator</p></li>
<li><p><strong>direction</strong> (<em>string label from domain geometry</em><em> or </em><em>integer number</em>) – Direction to evaluate finite differences</p></li>
<li><p><strong>method</strong> (<em>'forward'</em><em>, </em><em>'backward'</em><em>, </em><em>'centered'</em>) – Method for finite differences</p></li>
<li><p><strong>bnd_cond</strong> – ‘Neumann’, ‘Periodic’</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="cil.optimisation.operators.FiniteDifferenceOperator.direct">
<code class="sig-name descname"><span class="pre">direct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/FiniteDifferenceOperator.html#FiniteDifferenceOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.FiniteDifferenceOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the application of the Operator on x</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.FiniteDifferenceOperator.adjoint">
<code class="sig-name descname"><span class="pre">adjoint</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/FiniteDifferenceOperator.html#FiniteDifferenceOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.FiniteDifferenceOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>returns the adjoint/inverse operation</p>
<p>only available to linear operators</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.operators.SparseFiniteDifferenceOperator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">SparseFiniteDifferenceOperator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bnd_cond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Neumann'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/SparseFiniteDifferenceOperator.html#SparseFiniteDifferenceOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SparseFiniteDifferenceOperator" title="Permalink to this definition">#</a></dt>
<dd><p>Create Sparse Matrices for the Finite Difference Operator</p>
<dl class="py method">
<dt id="cil.optimisation.operators.SparseFiniteDifferenceOperator.direct">
<code class="sig-name descname"><span class="pre">direct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/SparseFiniteDifferenceOperator.html#SparseFiniteDifferenceOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SparseFiniteDifferenceOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the application of the Operator on x</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.operators.SymmetrisedGradientOperator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">SymmetrisedGradientOperator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bnd_cond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Neumann'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/SymmetrisedGradientOperator.html#SymmetrisedGradientOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SymmetrisedGradientOperator" title="Permalink to this definition">#</a></dt>
<dd><p>Symmetrized Gradient Operator:  E: V -&gt; W</p>
<p>V : range of the Gradient Operator
W : range of the Symmetrized Gradient</p>
<p>Example (2D):</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}v = (v1, v2) \\\end{split}\\\begin{split}Ev = 0.5 * ( \nabla\cdot v + (\nabla\cdot c)^{T} ) \\\end{split}\\\begin{split}\begin{matrix}
    \partial_{y} v1 &amp; 0.5 * (\partial_{x} v1 + \partial_{y} v2) \\
    0.5 * (\partial_{x} v1 + \partial_{y} v2) &amp; \partial_{x} v2
\end{matrix}\end{split}\end{aligned}\end{align} \]</div>
<dl class="py method">
<dt id="cil.optimisation.operators.SymmetrisedGradientOperator.direct">
<code class="sig-name descname"><span class="pre">direct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/SymmetrisedGradientOperator.html#SymmetrisedGradientOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SymmetrisedGradientOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Returns E(v)</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.SymmetrisedGradientOperator.adjoint">
<code class="sig-name descname"><span class="pre">adjoint</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/SymmetrisedGradientOperator.html#SymmetrisedGradientOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SymmetrisedGradientOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>returns the adjoint/inverse operation</p>
<p>only available to linear operators</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">#</a></h2>
<p>A <code class="code docutils literal notranslate"><span class="pre">Function</span></code> represents a mathematical function of one or more inputs
and is intended to accept <code class="code docutils literal notranslate"><span class="pre">DataContainers</span></code> as input as well as any
additional parameters.</p>
<p>Fixed parameters can be passed in during the creation of the function object.
The methods of the function reflect the properties of it, for example, if the function
represented is differentiable the function should contain a method <code class="code docutils literal notranslate"><span class="pre">gradient</span></code>
which should return the gradient of the function evaluated at an input point.
If the function is not differentiable but allows a simple proximal operator,
the method <code class="code docutils literal notranslate"><span class="pre">proximal</span></code> should return the proximal operator evaluated at an
input point. The function value is evaluated by calling the function itself,
e.g. <code class="code docutils literal notranslate"><span class="pre">f(x)</span></code> for a <code class="code docutils literal notranslate"><span class="pre">Function</span> <span class="pre">f</span></code> and input point <code class="code docutils literal notranslate"><span class="pre">x</span></code>.</p>
<div class="section" id="base-classes">
<h3>Base classes<a class="headerlink" href="#base-classes" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.functions.Function">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">Function</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">L</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function" title="Permalink to this definition">#</a></dt>
<dd><p>Abstract class representing a function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>L</strong> (<em>number</em><em>, </em><em>positive</em><em>, </em><em>default None</em>) – Lipschitz constant of the gradient of the function F(x), when it is differentiable.</p></li>
<li><p><strong>domain</strong> – The domain of the function.</p></li>
</ul>
</dd>
</dl>
<p>Lipschitz of the gradient of the function; it is a positive real number, such that <a href="#id32"><span class="problematic" id="id33">|f'(x) - f'(y)|</span></a> &lt;= L ||x-y||, assuming f: IG –&gt; R</p>
<dl class="py method">
<dt id="cil.optimisation.functions.Function.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">L</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.Function.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the function F at x: <span class="math notranslate nohighlight">\(F(x)\)</span></p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.Function.gradient">
<code class="sig-name descname"><span class="pre">gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of function F at x, if it is differentiable</p>
<div class="math notranslate nohighlight">
\[F'(x)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.Function.proximal">
<code class="sig-name descname"><span class="pre">proximal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of function <span class="math notranslate nohighlight">\(\tau F\)</span> at x
.. math:: mathrm{prox}_{tau F}(x) = underset{z}{mathrm{argmin}} frac{1}{2}|z - x|^{2} + tau F(z)</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.Function.convex_conjugate">
<code class="sig-name descname"><span class="pre">convex_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the convex conjugate of function <span class="math notranslate nohighlight">\(F\)</span> at <span class="math notranslate nohighlight">\(x^{*}\)</span>,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x^{*}}{\sup} &lt;x^{*}, x&gt; - F(x)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.Function.proximal_conjugate">
<code class="sig-name descname"><span class="pre">proximal_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.proximal_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.proximal_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\mathrm{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F^{*}}(x) = x - \tau\mathrm{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.Function.__add__">
<code class="sig-name descname"><span class="pre">__add__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.__add__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.__add__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the sum of the functions.</p>
<dl class="simple">
<dt>Cases: a) the sum of two functions <span class="math notranslate nohighlight">\((F_{1}+F_{2})(x) = F_{1}(x) + F_{2}(x)\)</span></dt><dd><ol class="loweralpha simple" start="2">
<li><p>the sum of a function with a scalar <span class="math notranslate nohighlight">\((F_{1}+scalar)(x) = F_{1}(x) + scalar\)</span></p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.Function.__radd__">
<code class="sig-name descname"><span class="pre">__radd__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.__radd__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.__radd__" title="Permalink to this definition">#</a></dt>
<dd><p>Making addition commutative.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.Function.__sub__">
<code class="sig-name descname"><span class="pre">__sub__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.__sub__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.__sub__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the subtraction of the functions.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.Function.__rmul__">
<code class="sig-name descname"><span class="pre">__rmul__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scalar</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.__rmul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.__rmul__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a function multiplied by a scalar.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.Function.centered_at">
<code class="sig-name descname"><span class="pre">centered_at</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#Function.centered_at"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.centered_at" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.
TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.Function.L">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">L</span></code><a class="headerlink" href="#cil.optimisation.functions.Function.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <a href="#id34"><span class="problematic" id="id35">|f'(x) - f'(y)|</span></a> &lt;= L ||x-y||, assuming f: IG –&gt; R</p>
</dd></dl>

<dl class="py attribute">
<dt id="cil.optimisation.functions.Function.__weakref__">
<code class="sig-name descname"><span class="pre">__weakref__</span></code><a class="headerlink" href="#cil.optimisation.functions.Function.__weakref__" title="Permalink to this definition">#</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.functions.SumFunction">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">SumFunction</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">functions</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#SumFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SumFunction" title="Permalink to this definition">#</a></dt>
<dd><p>SumFunction represents the sum of <span class="math notranslate nohighlight">\(n\geq2\)</span> functions</p>
<div class="math notranslate nohighlight">
\[(F_{1} + F_{2} + ... + F_{n})(\cdot)  = F_{1}(\cdot) + F_{2}(\cdot) + ... + F_{n}(\cdot)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>*functions</strong> (<em>Functions</em>) – Functions to set up a <a class="reference internal" href="#cil.optimisation.functions.SumFunction" title="cil.optimisation.functions.SumFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">SumFunction</span></code></a></p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the number of function is strictly less than 2.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="math notranslate nohighlight">
\[F(x) = \|x\|^{2} + \frac{1}{2}\|x - 1\|^{2}\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cil.optimisation.functions</span> <span class="kn">import</span> <span class="n">L2NormSquared</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cil.framework</span> <span class="kn">import</span> <span class="n">ImageGeometry</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">L2NormSquared</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">L2NormSquared</span><span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">SumFunction</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">)</span>
</pre></div>
</div>
<div class="math notranslate nohighlight">
\[F(x) = \sum_{i=1}^{50} \|x - i\|^{2}\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">SumFunction</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">L2NormSquared</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">)])</span>
</pre></div>
</div>
<dl class="py method">
<dt id="cil.optimisation.functions.SumFunction.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">functions</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#SumFunction.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SumFunction.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.SumFunction.L">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">L</span></code><a class="headerlink" href="#cil.optimisation.functions.SumFunction.L" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the Lipschitz constant for the SumFunction</p>
<div class="math notranslate nohighlight">
\[L = \sum_{i} L_{i}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{i}\)</span> is the Lipschitz constant of the smooth function <span class="math notranslate nohighlight">\(F_{i}\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.SumFunction.Lmax">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">Lmax</span></code><a class="headerlink" href="#cil.optimisation.functions.SumFunction.Lmax" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the maximum Lipschitz constant for the SumFunction</p>
<div class="math notranslate nohighlight">
\[L = \max_{i}\{L_{i}\}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{i}\)</span> is the Lipschitz constant of the smooth function <span class="math notranslate nohighlight">\(F_{i}\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.SumFunction.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#SumFunction.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SumFunction.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the sum of functions at <span class="math notranslate nohighlight">\(x\)</span>.</p>
<div class="math notranslate nohighlight">
\[(F_{1} + F_{2} + ... + F_{n})(x) = F_{1}(x) + F_{2}(x) + ... + F_{n}(x)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.SumFunction.gradient">
<code class="sig-name descname"><span class="pre">gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#SumFunction.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SumFunction.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the sum of the gradient of functions at <span class="math notranslate nohighlight">\(x\)</span>, if all of them are differentiable.</p>
<div class="math notranslate nohighlight">
\[(F'_{1} + F'_{2} + ... + F'_{n})(x) = F'_{1}(x) + F'_{2}(x) + ... + F'_{n}(x)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.SumFunction.__add__">
<code class="sig-name descname"><span class="pre">__add__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#SumFunction.__add__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SumFunction.__add__" title="Permalink to this definition">#</a></dt>
<dd><p>Addition for the SumFunction.</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">SumFunction</span></code> + <code class="code docutils literal notranslate"><span class="pre">SumFunction</span></code> is a <code class="code docutils literal notranslate"><span class="pre">SumFunction</span></code>.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">SumFunction</span></code> + <code class="code docutils literal notranslate"><span class="pre">Function</span></code> is a <code class="code docutils literal notranslate"><span class="pre">SumFunction</span></code>.</p></li>
</ul>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.functions.ScaledFunction">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">ScaledFunction</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalar</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ScaledFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction" title="Permalink to this definition">#</a></dt>
<dd><p>ScaledFunction represents the scalar multiplication with a Function.</p>
<p>Let a function F then and a scalar <span class="math notranslate nohighlight">\(\alpha\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(G(x) = \alpha F(x)\)</span> then:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(G(x) = \alpha  F(x)\)</span> ( __call__ method )</p></li>
<li><p><span class="math notranslate nohighlight">\(G'(x) = \alpha  F'(x)\)</span> ( gradient method )</p></li>
<li><p><span class="math notranslate nohighlight">\(G^{*}(x^{*}) = \alpha  F^{*}(\frac{x^{*}}{\alpha})\)</span> ( convex_conjugate method )</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathrm{prox}_{\tau G}(x) = \mathrm{prox}_{(\tau\alpha) F}(x)\)</span> ( proximal method )</p></li>
</ol>
<dl class="py method">
<dt id="cil.optimisation.functions.ScaledFunction.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalar</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ScaledFunction.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.ScaledFunction.L">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">L</span></code><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <a href="#id36"><span class="problematic" id="id37">|f'(x) - f'(y)|</span></a> &lt;= L ||x-y||, assuming f: IG –&gt; R</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.ScaledFunction.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ScaledFunction.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the scaled function.</p>
<div class="math notranslate nohighlight">
\[G(x) = \alpha F(x)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.ScaledFunction.convex_conjugate">
<code class="sig-name descname"><span class="pre">convex_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ScaledFunction.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the convex conjugate of the scaled function.</p>
<div class="math notranslate nohighlight">
\[G^{*}(x^{*}) = \alpha  F^{*}(\frac{x^{*}}{\alpha})\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.ScaledFunction.gradient">
<code class="sig-name descname"><span class="pre">gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ScaledFunction.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the gradient of the scaled function.</p>
<div class="math notranslate nohighlight">
\[G'(x) = \alpha  F'(x)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.ScaledFunction.proximal">
<code class="sig-name descname"><span class="pre">proximal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ScaledFunction.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the scaled function.</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau G}(x) = \mathrm{prox}_{(\tau\alpha) F}(x)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.ScaledFunction.proximal_conjugate">
<code class="sig-name descname"><span class="pre">proximal_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ScaledFunction.proximal_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.proximal_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>This returns the proximal operator for the function at x, tau</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.functions.SumScalarFunction">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">SumScalarFunction</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#SumScalarFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction" title="Permalink to this definition">#</a></dt>
<dd><p>SumScalarFunction represents the sum a function with a scalar.</p>
<div class="math notranslate nohighlight">
\[(F + scalar)(x)  = F(x) + scalar\]</div>
<p>Although SumFunction has no general expressions for</p>
<ol class="lowerroman simple">
<li><p>convex_conjugate</p></li>
<li><p>proximal</p></li>
<li><p>proximal_conjugate</p></li>
</ol>
<p>if the second argument is a ConstantFunction then we can derive the above analytically.</p>
<dl class="py method">
<dt id="cil.optimisation.functions.SumScalarFunction.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#SumScalarFunction.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.SumScalarFunction.convex_conjugate">
<code class="sig-name descname"><span class="pre">convex_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#SumScalarFunction.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the convex conjugate of a <span class="math notranslate nohighlight">\((F+scalar)\)</span></p>
<div class="math notranslate nohighlight">
\[(F+scalar)^{*}(x^{*}) = F^{*}(x^{*}) - scalar\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.SumScalarFunction.proximal">
<code class="sig-name descname"><span class="pre">proximal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#SumScalarFunction.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of <span class="math notranslate nohighlight">\(F+scalar\)</span></p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{       au (F+scalar)}(x) = \mathrm{prox}_{     au F}\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.SumScalarFunction.L">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">L</span></code><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction.L" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the Lipschitz constant for the SumFunction</p>
<div class="math notranslate nohighlight">
\[L = \sum_{i} L_{i}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{i}\)</span> is the Lipschitz constant of the smooth function <span class="math notranslate nohighlight">\(F_{i}\)</span>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.functions.TranslateFunction">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">TranslateFunction</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#TranslateFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction" title="Permalink to this definition">#</a></dt>
<dd><p>TranslateFunction represents the translation of function F with respect to the center b.</p>
<p>Let a function F and consider <span class="math notranslate nohighlight">\(G(x) = F(x - center)\)</span>.</p>
<p>Function F is centered at 0, whereas G is centered at point b.</p>
<p>If <span class="math notranslate nohighlight">\(G(x) = F(x - b)\)</span> then:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(G(x) = F(x - b)\)</span> ( __call__ method )</p></li>
<li><p><span class="math notranslate nohighlight">\(G'(x) = F'(x - b)\)</span> ( gradient method )</p></li>
<li><p><span class="math notranslate nohighlight">\(G^{*}(x^{*}) = F^{*}(x^{*}) + &lt;x^{*}, b &gt;\)</span> ( convex_conjugate method )</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathrm{prox}_{\tau G}(x) = \mathrm{prox}_{\tau F}(x - b)  + b\)</span> ( proximal method )</p></li>
</ol>
<dl class="py method">
<dt id="cil.optimisation.functions.TranslateFunction.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#TranslateFunction.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.TranslateFunction.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#TranslateFunction.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the translated function.</p>
<div class="math notranslate nohighlight">
\[G(x) = F(x - b)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.TranslateFunction.gradient">
<code class="sig-name descname"><span class="pre">gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#TranslateFunction.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the gradient of the translated function.</p>
<div class="math notranslate nohighlight">
\[G'(x) =  F'(x - b)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.TranslateFunction.proximal">
<code class="sig-name descname"><span class="pre">proximal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#TranslateFunction.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the translated function.</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau G}(x) = \mathrm{prox}_{\tau F}(x-b) + b\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.TranslateFunction.convex_conjugate">
<code class="sig-name descname"><span class="pre">convex_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#TranslateFunction.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the convex conjugate of the translated function.</p>
<div class="math notranslate nohighlight">
\[G^{*}(x^{*}) = F^{*}(x^{*}) + &lt;x^{*}, b &gt;\]</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="simple-functions">
<h3>Simple functions<a class="headerlink" href="#simple-functions" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.functions.ConstantFunction">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">ConstantFunction</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ConstantFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction" title="Permalink to this definition">#</a></dt>
<dd><p>ConstantFunction: <span class="math notranslate nohighlight">\(F(x) = constant, constant\in\mathbb{R}\)</span></p>
<dl class="py method">
<dt id="cil.optimisation.functions.ConstantFunction.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ConstantFunction.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.ConstantFunction.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ConstantFunction.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the function, <span class="math notranslate nohighlight">\(F(x) = constant\)</span></p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.ConstantFunction.gradient">
<code class="sig-name descname"><span class="pre">gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ConstantFunction.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of the function, <span class="math notranslate nohighlight">\(F'(x)=0\)</span></p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.ConstantFunction.convex_conjugate">
<code class="sig-name descname"><span class="pre">convex_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ConstantFunction.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>The convex conjugate of constant function <span class="math notranslate nohighlight">\(F(x) = c\in\mathbb{R}\)</span> is</p>
<div class="math notranslate nohighlight">
\[\begin{split}F(x^{*})
=
\begin{cases}
    -c, &amp; if x^{*} = 0\\
    \infty, &amp; \mbox{otherwise}
\end{cases}\end{split}\]</div>
<p>However, <span class="math notranslate nohighlight">\(x^{*} = 0\)</span> only in the limit of iterations, so in fact this can be infinity.
We do not want to have inf values in the convex conjugate, so we have to penalise this value accordingly.
The following penalisation is useful in the PDHG algorithm, when we compute primal &amp; dual objectives
for convergence purposes.</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \sum \max\{x^{*}, 0\}\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.ConstantFunction.proximal">
<code class="sig-name descname"><span class="pre">proximal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ConstantFunction.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the constant function, which is the same element, i.e.,</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{       au F}(x) = x\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.ConstantFunction.L">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">L</span></code><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <a href="#id38"><span class="problematic" id="id39">|f'(x) - f'(y)|</span></a> &lt;= L ||x-y||, assuming f: IG –&gt; R</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.ConstantFunction.__rmul__">
<code class="sig-name descname"><span class="pre">__rmul__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ConstantFunction.__rmul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.__rmul__" title="Permalink to this definition">#</a></dt>
<dd><p>defines the right multiplication with a number</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.functions.ZeroFunction">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">ZeroFunction</span></code><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ZeroFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ZeroFunction" title="Permalink to this definition">#</a></dt>
<dd><p>ZeroFunction represents the zero function, <span class="math notranslate nohighlight">\(F(x) = 0\)</span></p>
<dl class="py method">
<dt id="cil.optimisation.functions.ZeroFunction.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Function.html#ZeroFunction.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ZeroFunction.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.functions.Rosenbrock">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">Rosenbrock</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Rosenbrock.html#Rosenbrock"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Rosenbrock" title="Permalink to this definition">#</a></dt>
<dd><p>Rosenbrock function</p>
<div class="math notranslate nohighlight">
\[\]</div>
<p>F(x,y) = (alpha - x)^2 + beta(y-x^2)^2</p>
<p>The function has a global minimum at .. math:: (x,y)=(alpha, alpha^2)</p>
<dl class="py method">
<dt id="cil.optimisation.functions.Rosenbrock.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Rosenbrock.html#Rosenbrock.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Rosenbrock.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.Rosenbrock.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Rosenbrock.html#Rosenbrock.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Rosenbrock.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the function F at x: <span class="math notranslate nohighlight">\(F(x)\)</span></p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.Rosenbrock.gradient">
<code class="sig-name descname"><span class="pre">gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/Rosenbrock.html#Rosenbrock.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Rosenbrock.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Gradient of the Rosenbrock function</p>
<div class="math notranslate nohighlight">
\[\]</div>
<p>nabla f(x,y) = left[ 2*((x-alpha) - 2beta x(y-x^2)) ; 2beta (y - x^2)  right]</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="composition-of-operator-and-a-function">
<h3>Composition of operator and a function<a class="headerlink" href="#composition-of-operator-and-a-function" title="Permalink to this headline">#</a></h3>
<p>This class allows the user to write a function which does the following:</p>
<div class="math notranslate nohighlight">
\[F ( x ) = G ( Ax )\]</div>
<p>where <span class="math notranslate nohighlight">\(A\)</span> is an operator. For instance the least squares function <a href="#id48"><span class="problematic" id="id49">l2norm_</span></a> <code class="code docutils literal notranslate"><span class="pre">Norm2Sq</span></code> can
be expressed as</p>
<div class="math notranslate nohighlight">
\[F(x) = || Ax - b ||^2_2\]</div>
<dl class="py class">
<dt id="cil.optimisation.functions.OperatorCompositionFunction">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">OperatorCompositionFunction</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/OperatorCompositionFunction.html#OperatorCompositionFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction" title="Permalink to this definition">#</a></dt>
<dd><p>Composition of a function with an operator as : <span class="math notranslate nohighlight">\((F \otimes A)(x) = F(Ax)\)</span></p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">parameter function</dt>
<dd class="field-odd"><p><code class="code docutils literal notranslate"><span class="pre">Function</span></code> F</p>
</dd>
<dt class="field-even">parameter operator</dt>
<dd class="field-even"><p><code class="code docutils literal notranslate"><span class="pre">Operator</span></code> A</p>
</dd>
</dl>
</div></blockquote>
<p>For general operator, we have no explicit formulas for convex_conjugate,
proximal and proximal_conjugate</p>
<dl class="py method">
<dt id="cil.optimisation.functions.OperatorCompositionFunction.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/OperatorCompositionFunction.html#OperatorCompositionFunction.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>creator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<code class="code docutils literal notranslate"><span class="pre">Operator</span></code>) – operator</p></li>
<li><p><strong>f</strong> (<code class="code docutils literal notranslate"><span class="pre">Function</span></code>) – function</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.OperatorCompositionFunction.L">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">L</span></code><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <a href="#id40"><span class="problematic" id="id41">|f'(x) - f'(y)|</span></a> &lt;= L ||x-y||, assuming f: IG –&gt; R</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.OperatorCompositionFunction.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/OperatorCompositionFunction.html#OperatorCompositionFunction.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(F(Ax)\)</span></p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.OperatorCompositionFunction.gradient">
<code class="sig-name descname"><span class="pre">gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/OperatorCompositionFunction.html#OperatorCompositionFunction.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Return the gradient of F(Ax),</p>
<p>..math ::  (F(Ax))’ = A^{T}F’(Ax)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="indicator-box">
<h3>Indicator box<a class="headerlink" href="#indicator-box" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.functions.IndicatorBox">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">IndicatorBox</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accelerated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/IndicatorBox.html#IndicatorBox"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox" title="Permalink to this definition">#</a></dt>
<dd><p>Indicator function for box constraint</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}f(x) = \mathbb{I}_{[a, b]} = \begin{cases}
                                   0, \text{ if } x \in [a, b] \\
                                   \infty, \text{otherwise}
                            \end{cases}\end{split}\]</div>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lower</strong> (<em>float</em><em>, </em><a class="reference internal" href="framework.html#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><em>numpy array</em><em>, </em><em>default None</em>) – Lower bound. If set to None, it is equivalent to <code class="docutils literal notranslate"><span class="pre">-np.inf</span></code>.</p></li>
<li><p><strong>upper</strong> (<em>float</em><em>, </em><a class="reference internal" href="framework.html#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><em>numpy array</em><em>, </em><em>default None</em>) – Upper bound. If set to None, it is equivalent to <code class="docutils literal notranslate"><span class="pre">np.inf</span></code>.</p></li>
<li><p><strong>accelerated</strong> (<em>bool</em><em>, </em><em>default True</em>) – Specifies whether to use the accelerated version or not, using numba or
numpy backends respectively.</p></li>
</ul>
</dd>
</dl>
<p>If <code class="docutils literal notranslate"><span class="pre">lower</span></code> or <code class="docutils literal notranslate"><span class="pre">upper</span></code> are passed a <code class="docutils literal notranslate"><span class="pre">DataContainer</span></code> (or derived class
such as <code class="docutils literal notranslate"><span class="pre">ImageData</span></code> or <code class="docutils literal notranslate"><span class="pre">AcquisitionData</span></code>) or a <code class="docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>, the bounds
can be set to different values for each element.</p>
<p>In order to save computing time it is possible to suppress the evaluation of
the function. This is achieved by setting <code class="docutils literal notranslate"><span class="pre">suppress_evaluation</span></code> to <code class="docutils literal notranslate"><span class="pre">True</span></code>.
<code class="docutils literal notranslate"><span class="pre">IndicatorBox</span></code> evaluated on any input will then return 0.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">accelerated</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> (default), the Numba backend is used.
Otherwise, the Numpy backend is used. An optional parameter to set the number of
threads used by Numba can be set with <code class="docutils literal notranslate"><span class="pre">set_num_threads</span></code>. Setting the number of
threads when <code class="docutils literal notranslate"><span class="pre">accelerate</span></code> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code> will not have any effect.
The default number of threads is defined in the <code class="docutils literal notranslate"><span class="pre">cil.utilities.multiprocessing</span></code>
module, and it is equivalent to half of the CPU cores available.</p>
<p>In order to save computing time it is possible to suppress the evaluation of the
function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ib</span> <span class="o">=</span> <span class="n">IndicatorBox</span><span class="p">(</span><span class="n">lower</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ib</span><span class="o">.</span><span class="n">set_suppress_evaluation</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ib</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># returns 0</span>
</pre></div>
</div>
<p>Set the number of threads used in accelerated mode.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">num_threads</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">ib</span> <span class="o">=</span> <span class="n">IndicatorBox</span><span class="p">(</span><span class="n">lower</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ib</span><span class="o">.</span><span class="n">set_num_threads</span><span class="p">(</span><span class="n">num_threads</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt id="cil.optimisation.functions.IndicatorBox.__new__">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">__new__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accelerated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/IndicatorBox.html#IndicatorBox.__new__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.__new__" title="Permalink to this definition">#</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.IndicatorBox.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accelerated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/IndicatorBox.html#IndicatorBox.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.__init__" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.IndicatorBox.set_suppress_evaluation">
<code class="sig-name descname"><span class="pre">set_suppress_evaluation</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/IndicatorBox.html#IndicatorBox.set_suppress_evaluation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.set_suppress_evaluation" title="Permalink to this definition">#</a></dt>
<dd><p>Suppresses the evaluation of the function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>value</strong> (<em>bool</em>) – If True, the function evaluation on any input will return 0, without calculation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.IndicatorBox.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/IndicatorBox.html#IndicatorBox.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Evaluates IndicatorBox at x</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="framework.html#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – </p>
</dd>
</dl>
<p>Evaluates the IndicatorBox at x. If <code class="docutils literal notranslate"><span class="pre">suppress_evaluation</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, returns 0.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.IndicatorBox.proximal">
<code class="sig-name descname"><span class="pre">proximal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/IndicatorBox.html#IndicatorBox.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Proximal operator of IndicatorBox at x</p>
<div class="math notranslate nohighlight">
\[prox_{\tau * f}(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="framework.html#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – Input to the proximal operator</p></li>
<li><p><strong>tau</strong> (<em>float</em>) – Step size. Notice it is ignored in IndicatorBox</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="framework.html#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>optional</em>) – Output of the proximal operator. If not provided, a new DataContainer is created.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">tau</span></code> is ignored but it is in the signature of the generic Function class</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.IndicatorBox.gradient">
<code class="sig-name descname"><span class="pre">gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/IndicatorBox.html#IndicatorBox.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>IndicatorBox is not differentiable, so calling gradient will raise a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code></p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.IndicatorBox.num_threads">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">num_threads</span></code><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.num_threads" title="Permalink to this definition">#</a></dt>
<dd><p>Get the optional number of threads parameter to use for the accelerated version.</p>
<p>Defaults to the value set in the CIL multiprocessing module.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.IndicatorBox.set_num_threads">
<code class="sig-name descname"><span class="pre">set_num_threads</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/IndicatorBox.html#IndicatorBox.set_num_threads"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.set_num_threads" title="Permalink to this definition">#</a></dt>
<dd><p>Set the optional number of threads parameter to use for the accelerated version.</p>
<p>This is discarded if <code class="docutils literal notranslate"><span class="pre">accelerated=False</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="kullbackleibler">
<h3>KullbackLeibler<a class="headerlink" href="#kullbackleibler" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.functions.KullbackLeibler">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">KullbackLeibler</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'numba'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/KullbackLeibler.html#KullbackLeibler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler" title="Permalink to this definition">#</a></dt>
<dd><p>Kullback Leibler</p>
<div class="math notranslate nohighlight">
\[\begin{split}F(u, v)
= \begin{cases}
u \log(\frac{u}{v}) - u + v &amp; \mbox{ if } u &gt; 0, v &gt; 0\\
v &amp; \mbox{ if } u = 0, v \ge 0 \\
\infty, &amp; \mbox{otherwise}
\end{cases}\end{split}\]</div>
<p>where the <span class="math notranslate nohighlight">\(0\log0 := 0\)</span> convention is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>b</strong> (<a class="reference internal" href="framework.html#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>non-negative</em>) – Translates the function at point <cite>b</cite>.</p></li>
<li><p><strong>eta</strong> (<a class="reference internal" href="framework.html#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>default = 0</em>) – Background noise</p></li>
<li><p><strong>mask</strong> (<a class="reference internal" href="framework.html#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>default = None</em>) – Mask for the data <cite>b</cite></p></li>
<li><p><strong>backend</strong> (<em>{'numba'</em><em>,</em><em>'numpy'}</em><em>, </em><em>optional</em>) – Backend for the KullbackLeibler methods. Numba is the default backend.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Kullback-Leibler function is used in practice as a fidelity term in minimisation problems where the
acquired data follow Poisson distribution. If we denote the acquired data with <code class="code docutils literal notranslate"><span class="pre">b</span></code>
then, we write</p>
<div class="math notranslate nohighlight">
\[\underset{i}{\sum} F(b_{i}, (v + \eta)_{i})\]</div>
<p>where, <span class="math notranslate nohighlight">\(\eta\)</span> is an additional noise.</p>
<p>In the case of Positron Emission Tomography reconstruction <span class="math notranslate nohighlight">\(\eta\)</span> represents
scatter and random events contribution during the PET acquisition. Hence, in that case the KullbackLeibler
fidelity measures the distance between <span class="math notranslate nohighlight">\(\mathcal{A}v + \eta\)</span> and acquisition data <span class="math notranslate nohighlight">\(b\)</span>, where
<span class="math notranslate nohighlight">\(\mathcal{A}\)</span> is the projection operator. This is related to <a class="reference external" href="http://stir.sourceforge.net/documentation/doxy/html/classstir_1_1PoissonLogLikelihoodWithLinearModelForMean.html">PoissonLogLikelihoodWithLinearModelForMean</a> ,
definition that is used in PET reconstruction in the <a class="reference external" href="https://github.com/SyneRBI/SIRF">SIRF</a> software.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default implementation uses the build-in function <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.kl_div.html">kl_div</a> from scipy.
The methods of the <a class="reference internal" href="#cil.optimisation.functions.KullbackLeibler" title="cil.optimisation.functions.KullbackLeibler"><code class="xref py py-class docutils literal notranslate"><span class="pre">KullbackLeibler</span></code></a> are accelerated provided that <a class="reference external" href="https://numba.pydata.org/">numba</a> library is installed.</p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cil.optimisation.functions</span> <span class="kn">import</span> <span class="n">KullbackLeibler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cil.framework</span> <span class="kn">import</span> <span class="n">ImageGeometry</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ig</span> <span class="o">=</span> <span class="n">ImageGeometry</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s1">&#39;random&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">KullbackLeibler</span><span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt id="cil.optimisation.functions.KullbackLeibler.__new__">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">__new__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'numba'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/KullbackLeibler.html#KullbackLeibler.__new__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler.__new__" title="Permalink to this definition">#</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.KullbackLeibler.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'numba'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/KullbackLeibler.html#KullbackLeibler.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="l1-norm">
<h3>L1 Norm<a class="headerlink" href="#l1-norm" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.functions.L1Norm">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">L1Norm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L1Norm.html#L1Norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L1Norm" title="Permalink to this definition">#</a></dt>
<dd><p>L1Norm function</p>
<dl>
<dt>Consider the following cases:</dt><dd><ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[F(x) = ||x||_{1}\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[F(x) = ||x - b||_{1}\]</div>
</li>
</ol>
</dd>
</dl>
<dl class="py method">
<dt id="cil.optimisation.functions.L1Norm.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L1Norm.html#L1Norm.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L1Norm.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>creator</p>
<p>Cases considered (with/without data):
a) <span class="math notranslate nohighlight">\(f(x) = ||x||_{1}\)</span>
b) <span class="math notranslate nohighlight">\(f(x) = ||x - b||_{1}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>b</strong> (<code class="code docutils literal notranslate"><span class="pre">DataContainer</span></code>, optional) – translation of the function</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.L1Norm.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L1Norm.html#L1Norm.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L1Norm.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the L1Norm function at x.</p>
<dl>
<dt>Consider the following cases:</dt><dd><ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[F(x) = ||x||_{1}\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[F(x) = ||x - b||_{1}\]</div>
</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.L1Norm.convex_conjugate">
<code class="sig-name descname"><span class="pre">convex_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L1Norm.html#L1Norm.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L1Norm.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the convex conjugate of the L1Norm function at x.
Here, we need to use the convex conjugate of L1Norm, which is the Indicator of the unit
<span class="math notranslate nohighlight">\(L^{\infty}\)</span> norm</p>
<p>Consider the following cases:</p>
<blockquote>
<div><ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \mathbb{I}_{\{\|\cdot\|_{\infty}\leq1\}}(x^{*})\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \mathbb{I}_{\{\|\cdot\|_{\infty}\leq1\}}(x^{*}) + &lt;x^{*},b&gt;\]</div>
</li>
</ol>
</div></blockquote>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbb{I}_{\{\|\cdot\|_{\infty}\leq1\}}(x^{*})
= \begin{cases}
0, \mbox{if } \|x^{*}\|_{\infty}\leq1\\
\infty, \mbox{otherwise}
\end{cases}\end{split}\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.L1Norm.proximal">
<code class="sig-name descname"><span class="pre">proximal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L1Norm.html#L1Norm.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L1Norm.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the proximal operator of the L1Norm function at x.</p>
<p>Consider the following cases:</p>
<blockquote>
<div><ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \mathrm{ShinkOperator}(x)\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \mathrm{ShinkOperator}(x) + b\]</div>
</li>
</ol>
</div></blockquote>
<p>where,</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \mathrm{ShinkOperator}(x) = sgn(x) * \max\{ |x| - \tau, 0 \}\]</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="squared-l2-norm-squared">
<h3>Squared L2 norm squared<a class="headerlink" href="#squared-l2-norm-squared" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.functions.L2NormSquared">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">L2NormSquared</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#L2NormSquared"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared" title="Permalink to this definition">#</a></dt>
<dd><p>L2NormSquared function: <span class="math notranslate nohighlight">\(F(x) = \| x\|^{2}_{2} = \underset{i}{\sum}x_{i}^{2}\)</span></p>
<p>Following cases are considered:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p><span class="math notranslate nohighlight">\(F(x) = \|x\|^{2}_{2}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(F(x) = \|x - b\|^{2}_{2}\)</span></p></li>
</ol>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For case b) case we can use <code class="code docutils literal notranslate"><span class="pre">F</span> <span class="pre">=</span> <span class="pre">L2NormSquared().centered_at(b)</span></code>,
see <em>TranslateFunction</em>.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Example</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">L2NormSquared</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">L2NormSquared</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">L2NormSquared</span><span class="p">()</span><span class="o">.</span><span class="n">centered_at</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
<dl class="py method">
<dt id="cil.optimisation.functions.L2NormSquared.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#L2NormSquared.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>creator</p>
<dl>
<dt>Cases considered (with/without data):</dt><dd><ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[f(x) = \|x\|^{2}_{2}\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[f(x) = \|\|x - b\|\|^{2}_{2}\]</div>
</li>
</ol>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>b</strong> (<code class="code docutils literal notranslate"><span class="pre">DataContainer</span></code>, optional) – translation of the function</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.L2NormSquared.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#L2NormSquared.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the L2NormSquared function at x.</p>
<p>Following cases are considered:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p><span class="math notranslate nohighlight">\(F(x) = \|x\|^{2}_{2}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(F(x) = \|x - b\|^{2}_{2}\)</span></p></li>
</ol>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p><span class="math notranslate nohighlight">\(x\)</span></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(\underset{i}{\sum}x_{i}^{2}\)</span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.L2NormSquared.gradient">
<code class="sig-name descname"><span class="pre">gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#L2NormSquared.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of the L2NormSquared function at x.</p>
<p>Following cases are considered:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p><span class="math notranslate nohighlight">\(F'(x) = 2x\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(F'(x) = 2(x-b)\)</span></p></li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.L2NormSquared.convex_conjugate">
<code class="sig-name descname"><span class="pre">convex_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#L2NormSquared.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the convex conjugate of the L2NormSquared function at x.</p>
<p>Consider the following cases:</p>
<blockquote>
<div><ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \frac{1}{4}\|x^{*}\|^{2}_{2}\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \frac{1}{4}\|x^{*}\|^{2}_{2} + &lt;x^{*}, b&gt;\]</div>
</li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.L2NormSquared.proximal">
<code class="sig-name descname"><span class="pre">proximal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#L2NormSquared.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the proximal operator of the L2NormSquared function at x.</p>
<p>Consider the following cases:</p>
<blockquote>
<div><ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \frac{x}{1+2\tau}\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \frac{x-b}{1+2\tau} + b\]</div>
</li>
</ol>
</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="cil.optimisation.functions.WeightedL2NormSquared">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">WeightedL2NormSquared</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#WeightedL2NormSquared"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared" title="Permalink to this definition">#</a></dt>
<dd><p>WeightedL2NormSquared function: <span class="math notranslate nohighlight">\(F(x) = \| x\|_{w}^{2}_{2} = \underset{i}{\sum}w_{i}*x_{i}^{2} = &lt;x, w*x&gt; = x^{T}*w*x\)</span></p>
<dl class="py method">
<dt id="cil.optimisation.functions.WeightedL2NormSquared.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#WeightedL2NormSquared.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.WeightedL2NormSquared.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#WeightedL2NormSquared.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the function F at x: <span class="math notranslate nohighlight">\(F(x)\)</span></p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.WeightedL2NormSquared.gradient">
<code class="sig-name descname"><span class="pre">gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#WeightedL2NormSquared.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of function F at x, if it is differentiable</p>
<div class="math notranslate nohighlight">
\[F'(x)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.WeightedL2NormSquared.convex_conjugate">
<code class="sig-name descname"><span class="pre">convex_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#WeightedL2NormSquared.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the convex conjugate of function <span class="math notranslate nohighlight">\(F\)</span> at <span class="math notranslate nohighlight">\(x^{*}\)</span>,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x^{*}}{\sup} &lt;x^{*}, x&gt; - F(x)\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.WeightedL2NormSquared.proximal">
<code class="sig-name descname"><span class="pre">proximal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L2NormSquared.html#WeightedL2NormSquared.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of function <span class="math notranslate nohighlight">\(\tau F\)</span> at x
.. math:: mathrm{prox}_{tau F}(x) = underset{z}{mathrm{argmin}} frac{1}{2}|z - x|^{2} + tau F(z)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="least-squares">
<h3>Least Squares<a class="headerlink" href="#least-squares" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.functions.LeastSquares">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">LeastSquares</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/LeastSquares.html#LeastSquares"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.LeastSquares" title="Permalink to this definition">#</a></dt>
<dd><p>(Weighted) Least Squares function</p>
<div class="math notranslate nohighlight">
\[F(x) = c\|Ax-b\|_2^2\]</div>
<p>or if weighted</p>
<div class="math notranslate nohighlight">
\[F(x) = c\|Ax-b\|_{2,W}^{2}\]</div>
<blockquote>
<div><p>A : LinearOperator</p>
<p>b : Data, DataContainer</p>
<p>c : Scaling Constant, float, default 1.0</p>
<p>weight: DataContainer with all positive elements of size of the range of operator A, default None</p>
</div></blockquote>
<blockquote>
<div><p>L : Lipshitz Constant of the gradient of <span class="math notranslate nohighlight">\(F\)</span> which is <span class="math notranslate nohighlight">\(2 c ||A||_2^2 = 2 c s1(A)^2\)</span>, or</p>
<p>L : Lipshitz Constant of the gradient of <span class="math notranslate nohighlight">\(F\)</span> which is <span class="math notranslate nohighlight">\(2 c ||weight|| ||A||_2^2 = 2s1(A)^2\)</span>,</p>
</div></blockquote>
<p>where s1(A) is the largest singular value of A.</p>
<dl class="py method">
<dt id="cil.optimisation.functions.LeastSquares.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/LeastSquares.html#LeastSquares.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.LeastSquares.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.LeastSquares.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/LeastSquares.html#LeastSquares.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.LeastSquares.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of <span class="math notranslate nohighlight">\(F(x) = c\|Ax-b\|_2^2\)</span> or c|Ax-b|_{2,weight}^2</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.LeastSquares.gradient">
<code class="sig-name descname"><span class="pre">gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/LeastSquares.html#LeastSquares.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.LeastSquares.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of <span class="math notranslate nohighlight">\(F(x) = c*\|A*x-b\|_2^2\)</span></p>
<div class="math notranslate nohighlight">
\[F'(x) = 2cA^T(Ax-b)\]</div>
<div class="math notranslate nohighlight">
\[F'(x) = 2cA^T(weight(Ax-b))\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.LeastSquares.L">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">L</span></code><a class="headerlink" href="#cil.optimisation.functions.LeastSquares.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <a href="#id42"><span class="problematic" id="id43">|f'(x) - f'(y)|</span></a> &lt;= L ||x-y||, assuming f: IG –&gt; R</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.LeastSquares.__rmul__">
<code class="sig-name descname"><span class="pre">__rmul__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/LeastSquares.html#LeastSquares.__rmul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.LeastSquares.__rmul__" title="Permalink to this definition">#</a></dt>
<dd><p>defines the right multiplication with a number</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="mixed-l21-norm">
<h3>Mixed L21 norm<a class="headerlink" href="#mixed-l21-norm" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.functions.MixedL21Norm">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">MixedL21Norm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/MixedL21Norm.html#MixedL21Norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm" title="Permalink to this definition">#</a></dt>
<dd><p>MixedL21Norm function: <span class="math notranslate nohighlight">\(F(x) = ||x||_{2,1} = \sum |x|_{2} = \sum \sqrt{ (x^{1})^{2} + (x^{2})^{2} + \dots}\)</span></p>
<p>where x is a BlockDataContainer, i.e., <span class="math notranslate nohighlight">\(x=(x^{1}, x^{2}, \dots)\)</span></p>
<dl class="py method">
<dt id="cil.optimisation.functions.MixedL21Norm.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/MixedL21Norm.html#MixedL21Norm.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.MixedL21Norm.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/MixedL21Norm.html#MixedL21Norm.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the MixedL21Norm function at x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> – <code class="code docutils literal notranslate"><span class="pre">BlockDataContainer</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.MixedL21Norm.convex_conjugate">
<code class="sig-name descname"><span class="pre">convex_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/MixedL21Norm.html#MixedL21Norm.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the convex conjugate of the MixedL21Norm function at x.</p>
<p>This is the Indicator function of <span class="math notranslate nohighlight">\(\mathbb{I}_{\{\|\cdot\|_{2,\infty}\leq1\}}(x^{*})\)</span>,</p>
<p>i.e.,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbb{I}_{\{\|\cdot\|_{2, \infty}\leq1\}}(x^{*})
= \begin{cases}
0, \mbox{if } \|x\|_{2, \infty}\leq1\\
\infty, \mbox{otherwise}
\end{cases}\end{split}\]</div>
<p>where,</p>
<div class="math notranslate nohighlight">
\[\|x\|_{2,\infty} = \max\{ \|x\|_{2} \} = \max\{ \sqrt{ (x^{1})^{2} + (x^{2})^{2} + \dots}\}\]</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.MixedL21Norm.proximal">
<code class="sig-name descname"><span class="pre">proximal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/MixedL21Norm.html#MixedL21Norm.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the proximal operator of the MixedL21Norm function at x.</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \frac{x}{\|x\|_{2}}\max\{ \|x\|_{2} - \tau, 0 \}\]</div>
<p>where the convention 0 · (0/0) = 0 is used.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="smooth-mixed-l21-norm">
<h3>Smooth Mixed L21 norm<a class="headerlink" href="#smooth-mixed-l21-norm" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.functions.SmoothMixedL21Norm">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">SmoothMixedL21Norm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">epsilon</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/MixedL21Norm.html#SmoothMixedL21Norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SmoothMixedL21Norm" title="Permalink to this definition">#</a></dt>
<dd><p>SmoothMixedL21Norm function: <span class="math notranslate nohighlight">\(F(x) = ||x||_{2,1} = \sum |x|_{2} = \sum \sqrt{ (x^{1})^{2} + (x^{2})^{2} + \epsilon^2 + \dots}\)</span></p>
<p>where x is a BlockDataContainer, i.e., <span class="math notranslate nohighlight">\(x=(x^{1}, x^{2}, \dots)\)</span></p>
<p>Conjugate, proximal and proximal conjugate methods no closed-form solution</p>
<dl class="py method">
<dt id="cil.optimisation.functions.SmoothMixedL21Norm.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">epsilon</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/MixedL21Norm.html#SmoothMixedL21Norm.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SmoothMixedL21Norm.__init__" title="Permalink to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>epsilon</strong> – smoothing parameter making MixedL21Norm differentiable</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.SmoothMixedL21Norm.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/MixedL21Norm.html#SmoothMixedL21Norm.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SmoothMixedL21Norm.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the SmoothMixedL21Norm function at x.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.SmoothMixedL21Norm.gradient">
<code class="sig-name descname"><span class="pre">gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/MixedL21Norm.html#SmoothMixedL21Norm.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SmoothMixedL21Norm.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of the SmoothMixedL21Norm function at x.</p>
<p>frac{x}{<a href="#id44"><span class="problematic" id="id45">|x|</span></a>}</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="mixed-l11-norm">
<h3>Mixed L11 norm<a class="headerlink" href="#mixed-l11-norm" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.functions.MixedL11Norm">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">MixedL11Norm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L1Norm.html#MixedL11Norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL11Norm" title="Permalink to this definition">#</a></dt>
<dd><p>MixedL11Norm function</p>
<div class="math notranslate nohighlight">
\[F(x) = ||x||_{1,1} = \sum |x_{1}| + |x_{2}| + \cdots + |x_{n}|\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>MixedL11Norm is a separable function, therefore it can also be defined using the <a class="reference internal" href="#cil.optimisation.functions.BlockFunction" title="cil.optimisation.functions.BlockFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockFunction</span></code></a>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#cil.optimisation.functions.L1Norm" title="cil.optimisation.functions.L1Norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">L1Norm</span></code></a>, <a class="reference internal" href="#cil.optimisation.functions.MixedL21Norm" title="cil.optimisation.functions.MixedL21Norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MixedL21Norm</span></code></a></p>
</div>
<dl class="py method">
<dt id="cil.optimisation.functions.MixedL11Norm.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L1Norm.html#MixedL11Norm.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL11Norm.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.MixedL11Norm.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L1Norm.html#MixedL11Norm.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL11Norm.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the MixedL11Norm function at x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> – <code class="code docutils literal notranslate"><span class="pre">BlockDataContainer</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.MixedL11Norm.proximal">
<code class="sig-name descname"><span class="pre">proximal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/L1Norm.html#MixedL11Norm.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL11Norm.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the proximal operator of the MixedL11Norm function at x.</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \mathrm{ShinkOperator}(x)\]</div>
<p>where,</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \mathrm{ShinkOperator}(x) := sgn(x) * \max\{ |x| - \tau, 0 \}\]</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="total-variation">
<h3>Total variation<a class="headerlink" href="#total-variation" title="Permalink to this headline">#</a></h3>
<dl class="py class">
<dt id="cil.optimisation.functions.TotalVariation">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">TotalVariation</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_iteration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">correlation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Space'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'c'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isotropic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">info</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strong_convexity_constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warm_start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/TotalVariation.html#TotalVariation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation" title="Permalink to this definition">#</a></dt>
<dd><p>Total variation Function</p>
<div class="math notranslate nohighlight">
\[\mathrm{TV}(u) := \|\nabla u\|_{2,1} = \sum \|\nabla u\|_{2},\, (\mbox{isotropic})\]</div>
<div class="math notranslate nohighlight">
\[\mathrm{TV}(u) := \|\nabla u\|_{1,1} = \sum \|\nabla u\|_{1}\, (\mbox{anisotropic})\]</div>
<p class="rubric">Notes</p>
<p>The <code class="code docutils literal notranslate"><span class="pre">TotalVariation</span></code> (TV) <code class="code docutils literal notranslate"><span class="pre">Function</span></code> acts as a composite function, i.e.,
the composition of the <a class="reference internal" href="#cil.optimisation.functions.MixedL21Norm" title="cil.optimisation.functions.MixedL21Norm"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedL21Norm</span></code></a> function and the <a class="reference internal" href="#cil.optimisation.operators.GradientOperator" title="cil.optimisation.operators.GradientOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientOperator</span></code></a> operator,</p>
<div class="math notranslate nohighlight">
\[f(u) = \|u\|_{2,1}, \Rightarrow (f\circ\nabla)(u) = f(\nabla x) = \mathrm{TV}(u)\]</div>
<p>In that case, the proximal operator of TV does not have an exact solution and we use an iterative
algorithm to solve:</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau \mathrm{TV}}(b) := \underset{u}{\mathrm{argmin}} \frac{1}{2\tau}\|u - b\|^{2} + \mathrm{TV}(u)\]</div>
<p>The algorithm used for the proximal operator of TV is the Fast Gradient Projection algorithm (or FISTA)
applied to the _dual <a href="#id50"><span class="problematic" id="id51">problem_</span></a> of the above problem, see <span id="id12">[<a class="reference internal" href="#id28" title="Amir Beck and Marc Teboulle. A fast iterative shrinkage-thresholding algorithm for linear inverse problems. SIAM Journal on Imaging Sciences, 2(1):183-202, 2009. URL: https://doi.org/10.1137/080716542, arXiv:https://doi.org/10.1137/080716542, doi:10.1137/080716542.">1</a>]</span>, <span id="id13">[<a class="reference internal" href="#id27" title="Amir Beck and Marc Teboulle. Fast gradient-based algorithms for constrained total variation image denoising and deblurring problems. IEEE Transactions on Image Processing, 18(11):2419-2434, 2009. doi:10.1109/TIP.2009.2028250.">2</a>]</span>, <span id="id14">[<a class="reference internal" href="#id31" title="Mingqiang Zhu, Stephen J. Wright, and Tony F. Chan. Duality-based algorithms for total-variation-regularized image restoration. Computational Optimization and Applications, 47(3):377-400, Nov 2010. URL: https://doi.org/10.1007/s10589-008-9225-2, doi:10.1007/s10589-008-9225-2.">9</a>]</span>.</p>
<p>See also “Multicontrast MRI Reconstruction with Structure-Guided Total Variation”, Ehrhardt, Betcke, 2016.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>max_iteration</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, default = 5) – Maximum number of iterations for the FGP algorithm to solve to solve the dual problem
of the Total Variation Denoising problem (ROF). If warm_start=False, this should be around 100,
or larger, with a set tolerance.</p></li>
<li><p><strong>tolerance</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, default = None) – <p>Stopping criterion for the FGP algorithm used to to solve the dual problem
of the Total Variation Denoising problem (ROF). If the difference between iterates in the FGP algorithm is less than the tolerance
the iterations end before the max_iteration number.</p>
<div class="math notranslate nohighlight">
\[\|x^{k+1} - x^{k}\|_{2} &lt; \mathrm{tolerance}\]</div>
</p></li>
<li><p><strong>correlation</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>, default = <cite>Space</cite>) – Correlation between <cite>Space</cite> and/or <cite>SpaceChannels</cite> for the <a class="reference internal" href="#cil.optimisation.operators.GradientOperator" title="cil.optimisation.operators.GradientOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientOperator</span></code></a>.</p></li>
<li><p><strong>backend</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>, default = <cite>c</cite>) – Backend to compute the <a class="reference internal" href="#cil.optimisation.operators.GradientOperator" title="cil.optimisation.operators.GradientOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientOperator</span></code></a></p></li>
<li><p><strong>lower</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">'float</span></code>, default = None) – A constraint is enforced using the <a class="reference internal" href="#cil.optimisation.functions.IndicatorBox" title="cil.optimisation.functions.IndicatorBox"><code class="xref py py-class docutils literal notranslate"><span class="pre">IndicatorBox</span></code></a> function, e.g., <code class="code docutils literal notranslate"><span class="pre">IndicatorBox(lower,</span> <span class="pre">upper)</span></code>.</p></li>
<li><p><strong>upper</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">'float</span></code>, default = None) – A constraint is enforced using the <a class="reference internal" href="#cil.optimisation.functions.IndicatorBox" title="cil.optimisation.functions.IndicatorBox"><code class="xref py py-class docutils literal notranslate"><span class="pre">IndicatorBox</span></code></a> function, e.g., <code class="code docutils literal notranslate"><span class="pre">IndicatorBox(lower,</span> <span class="pre">upper)</span></code>.</p></li>
<li><p><strong>isotropic</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">boolean</span></code>, default = True) – <p>Use either isotropic or anisotropic definition of TV.</p>
<div class="math notranslate nohighlight">
\[|x|_{2} = \sqrt{x_{1}^{2} + x_{2}^{2}},\, (\mbox{isotropic})\]</div>
<div class="math notranslate nohighlight">
\[|x|_{1} = |x_{1}| + |x_{2}|\, (\mbox{anisotropic})\]</div>
</p></li>
<li><p><strong>split</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">boolean</span></code>, default = False) – Splits the Gradient into spatial gradient and spectral or temporal gradient for multichannel data.</p></li>
<li><p><strong>info</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">boolean</span></code>, default = False) – Information is printed for the stopping criterion of the FGP algorithm used to solve the dual problem
of the Total Variation Denoising problem (ROF).</p></li>
<li><p><strong>strong_convexity_constant</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, default = 0) – <p>A strongly convex term weighted by the <code class="code docutils literal notranslate"><span class="pre">strong_convexity_constant</span></code> (<span class="math notranslate nohighlight">\(\gamma\)</span>) parameter is added to the Total variation.
Now the <code class="code docutils literal notranslate"><span class="pre">TotalVariation</span></code> function is <span class="math notranslate nohighlight">\(\gamma\)</span> - strongly convex and the proximal operator is</p>
<div class="math notranslate nohighlight">
\[\underset{u}{\mathrm{argmin}} \frac{1}{2\tau}\|u - b\|^{2} + \mathrm{TV}(u) + \frac{\gamma}{2}\|u\|^{2} \Leftrightarrow\]</div>
<div class="math notranslate nohighlight">
\[\underset{u}{\mathrm{argmin}} \frac{1}{2\frac{\tau}{1+\gamma\tau}}\|u - \frac{b}{1+\gamma\tau}\|^{2} + \mathrm{TV}(u)\]</div>
</p></li>
<li><p><strong>warm_start</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">boolean</span></code>, default = True) – If set to true, the FGP algorithm used to solve the dual problem of the Total Variation Denoising problem (ROF) is initiated by the final value from the previous iteration and not at zero.
This allows the max_iteration value to be reduced to 5-10 iterations.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>With warm_start set to the default, True, the TV function will keep in memory the range of the gradient of the image to be denoised, i.e. N times the dimensionality of the image. This increases the memory requirements.
However, during the evaluation of <cite>proximal</cite> the memory requirements will be unchanged as the same amount of memory will need to be allocated and deallocated.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the case where the Total variation becomes a <span class="math notranslate nohighlight">\(\gamma\)</span> - strongly convex function, i.e.,</p>
<div class="math notranslate nohighlight">
\[\mathrm{TV}(u) + \frac{\gamma}{2}\|u\|^{2}\]</div>
<p><span class="math notranslate nohighlight">\(\gamma\)</span> should be relatively small, so as the second term above will not act as an additional regulariser.
For more information, see <span id="id15">[<a class="reference internal" href="#id29" title="Julian Rasch and Antonin Chambolle. Inexact first-order primal–dual algorithms. Computational Optimization and Applications, 76(2):381-430, Jun 2020. URL: https://doi.org/10.1007/s10589-020-00186-y, doi:10.1007/s10589-020-00186-y.">8</a>]</span>, <span id="id16">[<a class="reference internal" href="#id23" title="Antonin Chambolle and Thomas Pock. A first-order primal-dual algorithm for convex problems with applications to imaging. Journal of Mathematical Imaging and Vision, 40(1):120-145, May 2011. URL: https://doi.org/10.1007/s10851-010-0251-1, doi:10.1007/s10851-010-0251-1.">3</a>]</span>.</p>
</div>
<p class="rubric">Examples</p>
<div class="math notranslate nohighlight">
\[\underset{u}{\mathrm{argmin}} \frac{1}{2}\|u - b\|^{2} + \alpha\|\nabla u\|_{2,1}\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TV</span> <span class="o">=</span> <span class="n">TotalVariation</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">TV</span><span class="o">.</span><span class="n">proximal</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="math notranslate nohighlight">
\[\underset{u}{\mathrm{argmin}} \frac{1}{2}\|u - b\|^{2} + \alpha\|\nabla u\|_{1,1} + \mathbb{I}_{C}(u)\]</div>
<p>where <span class="math notranslate nohighlight">\(C = \{1.0\leq u\leq 2.0\}\)</span>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TV</span> <span class="o">=</span> <span class="n">TotalVariation</span><span class="p">(</span><span class="n">isotropic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">TV</span><span class="o">.</span><span class="n">proximal</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="math notranslate nohighlight">
\[\underset{u}{\mathrm{argmin}} \frac{1}{2}\|u - b\|^{2} + (\alpha\|\nabla u\|_{2,1} + \frac{\gamma}{2}\|u\|^{2})\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gamma</span> <span class="o">=</span> <span class="mf">1e-3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TV</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">TotalVariation</span><span class="p">(</span><span class="n">isotropic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">strong_convexity_constant</span><span class="o">=</span><span class="n">gamma</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">TV</span><span class="o">.</span><span class="n">proximal</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt id="cil.optimisation.functions.TotalVariation.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_iteration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">correlation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Space'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'c'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isotropic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">info</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strong_convexity_constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warm_start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/TotalVariation.html#TotalVariation.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.TotalVariation.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/TotalVariation.html#TotalVariation.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the TotalVariation function at <code class="code docutils literal notranslate"><span class="pre">x</span></code> .</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.TotalVariation.proximal">
<code class="sig-name descname"><span class="pre">proximal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/TotalVariation.html#TotalVariation.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the TotalVariation function at <code class="code docutils literal notranslate"><span class="pre">x</span></code> .</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.TotalVariation.convex_conjugate">
<code class="sig-name descname"><span class="pre">convex_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/TotalVariation.html#TotalVariation.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of convex conjugate of the TotalVariation function at <code class="code docutils literal notranslate"><span class="pre">x</span></code> .</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.TotalVariation.calculate_Lipschitz">
<code class="sig-name descname"><span class="pre">calculate_Lipschitz</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/TotalVariation.html#TotalVariation.calculate_Lipschitz"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.calculate_Lipschitz" title="Permalink to this definition">#</a></dt>
<dd><p>Default value for the Lipschitz constant.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.TotalVariation.gradient">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">gradient</span></code><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>GradientOperator is created if it is not instantiated yet. The domain of the <cite>_gradient</cite>,
is created in the <cite>__call__</cite> and <cite>proximal</cite> methods.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.TotalVariation.__rmul__">
<code class="sig-name descname"><span class="pre">__rmul__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scalar</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/TotalVariation.html#TotalVariation.__rmul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.__rmul__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a function multiplied by a scalar.</p>
</dd></dl>

</dd></dl>

</div>
</div>
</div>
<div class="section" id="block-framework">
<h1>Block Framework<a class="headerlink" href="#block-framework" title="Permalink to this headline">#</a></h1>
<p>To be able to express more advanced optimisation problems we developed the
<a class="reference internal" href="#block-framework">Block Framework</a>, which provides a generic strategy to treat variational
problems in the following form:</p>
<div class="math notranslate nohighlight">
\[\min \text{Regulariser} + \text{Fidelity}\]</div>
<p>The block framework consists of:</p>
<ul class="simple">
<li><p><a class="reference external" href="framework.html#cil.framework.BlockDataContainer">BlockDataContainer</a></p></li>
<li><p><a class="reference external" href="optimisation.html#cil.optimisation.functions.BlockFunction">BlockFunction</a></p></li>
<li><p><a class="reference external" href="optimisation.html#cil.optimisation.operators.BlockOperators">BlockOperator</a></p></li>
</ul>
<p>The block framework allows writing more advanced <a href="#id52"><span class="problematic" id="id53">`optimisation problems`_</span></a>. Consider the typical
<a class="reference external" href="https://en.wikipedia.org/wiki/Tikhonov_regularization">Tikhonov regularisation</a>:</p>
<div class="math notranslate nohighlight">
\[\underset{u}{\mathrm{argmin}}\begin{Vmatrix}A u - b \end{Vmatrix}^2_2 + \alpha^2\|Lu\|^2_2\]</div>
<p>where,</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(A\)</span> is the projection operator</p></li>
<li><p><span class="math notranslate nohighlight">\(b\)</span> is the acquired data</p></li>
<li><p><span class="math notranslate nohighlight">\(u\)</span> is the unknown image to be solved for</p></li>
<li><p><span class="math notranslate nohighlight">\(\alpha\)</span> is the regularisation parameter</p></li>
<li><p><span class="math notranslate nohighlight">\(L\)</span> is a regularisation operator</p></li>
</ul>
<p>The first term measures the fidelity of the solution to the data. The second term measures the
fidelity to the prior knowledge we have imposed on the system, operator <span class="math notranslate nohighlight">\(L\)</span>.</p>
<p>This can be re-written equivalently in the block matrix form:</p>
<div class="math notranslate nohighlight">
\[\underset{u}{\mathrm{argmin}}\begin{Vmatrix}\binom{A}{\alpha L} u - \binom{b}{0}\end{Vmatrix}^2_2\]</div>
<p>With the definitions:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\tilde{A} = \binom{A}{\alpha L}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\tilde{b} = \binom{b}{0}\)</span></p></li>
</ul>
<p>this can now be recognised as a least squares problem which can be solved by any algorithm in the <code class="code docutils literal notranslate"><span class="pre">cil.optimisation</span></code>
which can solve least squares problem, e.g. CGLS.</p>
<div class="math notranslate nohighlight">
\[\underset{u}{\mathrm{argmin}}\begin{Vmatrix}\tilde{A} u - \tilde{b}\end{Vmatrix}^2_2\]</div>
<p>To be able to express our optimisation problems in the matrix form above, we developed the so-called,
Block Framework comprising 4 main actors: <code class="code docutils literal notranslate"><span class="pre">BlockGeometry</span></code>, <code class="code docutils literal notranslate"><span class="pre">BlockDataContainer</span></code>,
<code class="code docutils literal notranslate"><span class="pre">BlockFunction</span></code> and <code class="code docutils literal notranslate"><span class="pre">BlockOperator</span></code>.</p>
<div class="section" id="blockdatacontainer">
<h2>BlockDataContainer<a class="headerlink" href="#blockdatacontainer" title="Permalink to this headline">#</a></h2>
<p><a class="reference external" href="framework.html#cil.framework.BlockDataContainer">BlockDataContainer</a> holds <a href="#id54"><span class="problematic" id="id55">`DataContainer`_</span></a> as column vector. It is possible to
do basic algebra between <a class="reference external" href="framework.html#cil.framework.BlockDataContainer">BlockDataContainer</a> s and with numbers, list or numpy arrays.</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}x = [x_{1}, x_{2} ]\in (X_{1}\times X_{2})\\y = [y_{1}, y_{2}, y_{3} ]\in(Y_{1}\times Y_{2} \times Y_{3})\end{aligned}\end{align} \]</div>
<dl class="py class">
<dt id="cil.framework.BlockDataContainer">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.framework.</span></code><code class="sig-name descname"><span class="pre">BlockDataContainer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer" title="Permalink to this definition">#</a></dt>
<dd><p>Class to hold DataContainers as column vector</p>
<p>Provides basic algebra between BlockDataContainer’s, DataContainer’s and
subclasses and Numbers</p>
<ol class="arabic simple">
<li><p>algebra between <a href="#id17"><span class="problematic" id="id18">`</span></a>BlockDataContainer`s will be element-wise, only if
the shape of the 2 <a href="#id19"><span class="problematic" id="id20">`</span></a>BlockDataContainer`s is the same, otherwise it
will fail</p></li>
<li><p>algebra between <cite>BlockDataContainer`s and `list</cite> or <cite>numpy array</cite> will
work as long as the number of <cite>rows</cite> and element of the arrays match,
independently on the fact that the <cite>BlockDataContainer</cite> could be nested</p></li>
<li><p>algebra between <cite>BlockDataContainer</cite> and one <cite>DataContainer</cite> is possible.
It will require all the <cite>DataContainers</cite> in the block to be
compatible with the <cite>DataContainer</cite> we want to operate with.</p></li>
<li><p>algebra between <cite>BlockDataContainer</cite> and a <cite>Number</cite> is possible and it
will be done with each element of the <cite>BlockDataContainer</cite> even if nested</p></li>
</ol>
<p>A = [ [B,C] , D]
A * 3 = [ 3 * [B,C] , 3* D] = [ [ 3*B, 3*C]  , 3*D ]</p>
<dl class="py method">
<dt id="cil.framework.BlockDataContainer.__iter__">
<code class="sig-name descname"><span class="pre">__iter__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__iter__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__iter__" title="Permalink to this definition">#</a></dt>
<dd><p>BlockDataContainer is Iterable</p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.next">
<code class="sig-name descname"><span class="pre">next</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.next"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.next" title="Permalink to this definition">#</a></dt>
<dd><p>python2 backwards compatibility</p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.is_compatible">
<code class="sig-name descname"><span class="pre">is_compatible</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.is_compatible"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.is_compatible" title="Permalink to this definition">#</a></dt>
<dd><p>basic check if the size of the 2 objects fit</p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.add">
<code class="sig-name descname"><span class="pre">add</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.add"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.add" title="Permalink to this definition">#</a></dt>
<dd><p>Algebra: add method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>other (number, DataContainer or subclasses or BlockDataContainer</p>
</dd>
<dt class="field-even">Param</dt>
<dd class="field-even"><p>out (optional): provides a placehold for the resul.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.subtract">
<code class="sig-name descname"><span class="pre">subtract</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.subtract"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.subtract" title="Permalink to this definition">#</a></dt>
<dd><p>Algebra: subtract method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>other (number, DataContainer or subclasses or BlockDataContainer</p>
</dd>
<dt class="field-even">Param</dt>
<dd class="field-even"><p>out (optional): provides a placeholder for the result.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.multiply">
<code class="sig-name descname"><span class="pre">multiply</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.multiply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.multiply" title="Permalink to this definition">#</a></dt>
<dd><p>Algebra: multiply method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>other (number, DataContainer or subclasses or BlockDataContainer)</p>
</dd>
<dt class="field-even">Param</dt>
<dd class="field-even"><p>out (optional): provides a placeholder for the result.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.divide">
<code class="sig-name descname"><span class="pre">divide</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.divide"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.divide" title="Permalink to this definition">#</a></dt>
<dd><p>Algebra: divide method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>other (number, DataContainer or subclasses or BlockDataContainer)</p>
</dd>
<dt class="field-even">Param</dt>
<dd class="field-even"><p>out (optional): provides a placeholder for the result.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.power">
<code class="sig-name descname"><span class="pre">power</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.power"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.power" title="Permalink to this definition">#</a></dt>
<dd><p>Algebra: power method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>other (number, DataContainer or subclasses or BlockDataContainer</p>
</dd>
<dt class="field-even">Param</dt>
<dd class="field-even"><p>out (optional): provides a placeholder for the result.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.maximum">
<code class="sig-name descname"><span class="pre">maximum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.maximum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.maximum" title="Permalink to this definition">#</a></dt>
<dd><p>Algebra: power method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>other (number, DataContainer or subclasses or BlockDataContainer)</p>
</dd>
<dt class="field-even">Param</dt>
<dd class="field-even"><p>out (optional): provides a placeholder for the result.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.minimum">
<code class="sig-name descname"><span class="pre">minimum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.minimum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.minimum" title="Permalink to this definition">#</a></dt>
<dd><p>Algebra: power method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Param</dt>
<dd class="field-odd"><p>other (number, DataContainer or subclasses or BlockDataContainer)</p>
</dd>
<dt class="field-even">Param</dt>
<dd class="field-even"><p>out (optional): provides a placeholder for the result.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.sapyb">
<code class="sig-name descname"><span class="pre">sapyb</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.sapyb"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.sapyb" title="Permalink to this definition">#</a></dt>
<dd><p>performs axpby element-wise on the BlockDataContainer containers</p>
<p>Does the operation .. math:: a*x+b*y and stores the result in out, where x is self</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – scalar</p></li>
<li><p><strong>b</strong> – scalar</p></li>
<li><p><strong>y</strong> – compatible (Block)DataContainer</p></li>
<li><p><strong>out</strong> – (Block)DataContainer to store the result</p></li>
</ul>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ig</span> <span class="o">=</span> <span class="n">ImageGeometry</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bdc1</span> <span class="o">=</span> <span class="n">BlockDataContainer</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bdc2</span> <span class="o">=</span> <span class="n">BlockDataContainer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">bdc1</span><span class="o">.</span><span class="n">sapyb</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">bdc2</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.axpby">
<code class="sig-name descname"><span class="pre">axpby</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">b</span></em>, <em class="sig-param"><span class="pre">y</span></em>, <em class="sig-param"><span class="pre">out</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></em>, <em class="sig-param"><span class="pre">num_threads=2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.axpby"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.axpby" title="Permalink to this definition">#</a></dt>
<dd><p>Deprecated method. Alias of sapyb</p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.binary_operations">
<code class="sig-name descname"><span class="pre">binary_operations</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.binary_operations"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.binary_operations" title="Permalink to this definition">#</a></dt>
<dd><p>Algebra: generic method of algebric operation with BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<p>Provides commutativity with DataContainer and subclasses, i.e. this
class’s reverse algebraic methods take precedence w.r.t. direct algebraic
methods of DataContainer and subclasses.</p>
<p>This method is not to be used directly</p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.unary_operations">
<code class="sig-name descname"><span class="pre">unary_operations</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operation</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.unary_operations"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.unary_operations" title="Permalink to this definition">#</a></dt>
<dd><p>Unary operation on BlockDataContainer:</p>
<p>generic method of unary operation with BlockDataContainer: abs, sign, sqrt and conjugate</p>
<p>This method is not to be used directly</p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.copy">
<code class="sig-name descname"><span class="pre">copy</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.copy" title="Permalink to this definition">#</a></dt>
<dd><p>alias of clone</p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.__radd__">
<code class="sig-name descname"><span class="pre">__radd__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__radd__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__radd__" title="Permalink to this definition">#</a></dt>
<dd><p>Reverse addition</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.__rsub__">
<code class="sig-name descname"><span class="pre">__rsub__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__rsub__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__rsub__" title="Permalink to this definition">#</a></dt>
<dd><p>Reverse subtraction</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.__rmul__">
<code class="sig-name descname"><span class="pre">__rmul__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__rmul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__rmul__" title="Permalink to this definition">#</a></dt>
<dd><p>Reverse multiplication</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.__rdiv__">
<code class="sig-name descname"><span class="pre">__rdiv__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__rdiv__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__rdiv__" title="Permalink to this definition">#</a></dt>
<dd><p>Reverse division</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.__rtruediv__">
<code class="sig-name descname"><span class="pre">__rtruediv__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__rtruediv__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__rtruediv__" title="Permalink to this definition">#</a></dt>
<dd><p>Reverse truedivision</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.__rpow__">
<code class="sig-name descname"><span class="pre">__rpow__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__rpow__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__rpow__" title="Permalink to this definition">#</a></dt>
<dd><p>Reverse power</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.__iadd__">
<code class="sig-name descname"><span class="pre">__iadd__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__iadd__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__iadd__" title="Permalink to this definition">#</a></dt>
<dd><p>Inline addition</p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.__isub__">
<code class="sig-name descname"><span class="pre">__isub__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__isub__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__isub__" title="Permalink to this definition">#</a></dt>
<dd><p>Inline subtraction</p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.__imul__">
<code class="sig-name descname"><span class="pre">__imul__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__imul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__imul__" title="Permalink to this definition">#</a></dt>
<dd><p>Inline multiplication</p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.__idiv__">
<code class="sig-name descname"><span class="pre">__idiv__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__idiv__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__idiv__" title="Permalink to this definition">#</a></dt>
<dd><p>Inline division</p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.__itruediv__">
<code class="sig-name descname"><span class="pre">__itruediv__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__itruediv__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__itruediv__" title="Permalink to this definition">#</a></dt>
<dd><p>Inline truedivision</p>
</dd></dl>

<dl class="py method">
<dt id="cil.framework.BlockDataContainer.__neg__">
<code class="sig-name descname"><span class="pre">__neg__</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/framework/BlockDataContainer.html#BlockDataContainer.__neg__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__neg__" title="Permalink to this definition">#</a></dt>
<dd><p>Return - self</p>
</dd></dl>

<dl class="py attribute">
<dt id="cil.framework.BlockDataContainer.__weakref__">
<code class="sig-name descname"><span class="pre">__weakref__</span></code><a class="headerlink" href="#cil.framework.BlockDataContainer.__weakref__" title="Permalink to this definition">#</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="block-function">
<h2>Block Function<a class="headerlink" href="#block-function" title="Permalink to this headline">#</a></h2>
<p><a class="reference external" href="optimisation.html#cil.optimisation.functions.BlockFunction">BlockFunction</a> acts on <a class="reference external" href="framework.html#cil.framework.BlockDataContainer">BlockDataContainer</a> as a separable sum function:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}f = [f_1,...,f_n] \newline\\f([x_1,...,x_n]) = f_1(x_1) +  .... + f_n(x_n)\end{aligned}\end{align} \]</div>
</div></blockquote>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}Y = \begin{bmatrix}
y_{1}\\
y_{2}\\
y_{3}\\
\end{bmatrix}, \quad  F  = [ f_{1}, f_{2}, f_{3} ]\end{split}\\F(Y) : = f_{1}(y_{1}) + f_{2}(y_{2}) + f_{3}(y_{3})\end{aligned}\end{align} \]</div>
<dl class="py class">
<dt id="cil.optimisation.functions.BlockFunction">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></code><code class="sig-name descname"><span class="pre">BlockFunction</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">functions</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/BlockFunction.html#BlockFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction" title="Permalink to this definition">#</a></dt>
<dd><p>BlockFunction represents a <em>separable sum</em> function <span class="math notranslate nohighlight">\(F\)</span> defined as</p>
<div class="math notranslate nohighlight">
\[F:X_{1}\times X_{2}\cdots\times X_{m} \rightarrow (-\infty, \infty]\]</div>
<p>where <span class="math notranslate nohighlight">\(F\)</span> is the separable sum of functions <span class="math notranslate nohighlight">\((f_{i})_{i=1}^{m}\)</span>,</p>
<div class="math notranslate nohighlight">
\[F(x_{1}, x_{2}, \cdots, x_{m}) = \overset{m}{\underset{i=1}{\sum}}f_{i}(x_{i}), \mbox{ with } f_{i}: X_{i} \rightarrow (-\infty, \infty].\]</div>
<p>A nice property (due to it’s separability structure) is that the proximal operator
can be decomposed along the proximal operators of each function <span class="math notranslate nohighlight">\(f_{i}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = ( \mathrm{prox}_{\tau f_{i}}(x_{i}) )_{i=1}^{m}\]</div>
<p>In addition, if <span class="math notranslate nohighlight">\(\tau := (\tau_{1},\dots,\tau_{m})\)</span>, then</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = ( \mathrm{prox}_{\tau_{i} f_{i}}(x_{i}) )_{i=1}^{m}\]</div>
<dl class="py method">
<dt id="cil.optimisation.functions.BlockFunction.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">functions</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/BlockFunction.html#BlockFunction.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.BlockFunction.L">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">L</span></code><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.L" title="Permalink to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <a href="#id46"><span class="problematic" id="id47">|f'(x) - f'(y)|</span></a> &lt;= L ||x-y||, assuming f: IG –&gt; R</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.BlockFunction.__call__">
<code class="sig-name descname"><span class="pre">__call__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/BlockFunction.html#BlockFunction.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.__call__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the BlockFunction <span class="math notranslate nohighlight">\(F\)</span></p>
<div class="math notranslate nohighlight">
\[F(x) = \overset{m}{\underset{i=1}{\sum}}f_{i}(x_{i}), \mbox{ where } x = (x_{1}, x_{2}, \cdots, x_{m}), \quad i = 1,2,\dots,m\]</div>
<p>Parameter:</p>
<blockquote>
<div><p>x : BlockDataContainer and must have as many rows as self.length</p>
<p>returns ..math:: sum(f_i(x_i))</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.BlockFunction.convex_conjugate">
<code class="sig-name descname"><span class="pre">convex_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/BlockFunction.html#BlockFunction.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.convex_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the convex conjugate of the BlockFunction at <span class="math notranslate nohighlight">\(x^{*}\)</span>.</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \overset{m}{\underset{i=1}{\sum}}f_{i}^{*}(x^{*}_{i})\]</div>
<p>Parameter:</p>
<blockquote>
<div><p>x : BlockDataContainer and must have as many rows as self.length</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.BlockFunction.proximal">
<code class="sig-name descname"><span class="pre">proximal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/BlockFunction.html#BlockFunction.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.proximal" title="Permalink to this definition">#</a></dt>
<dd><p>Proximal operator of the BlockFunction at x:</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) =  (\mathrm{prox}_{\tau f_{i}}(x_{i}))_{i=1}^{m}\]</div>
<p>Parameter:</p>
<blockquote>
<div><p>x : BlockDataContainer and must have as many rows as self.length</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.BlockFunction.gradient">
<code class="sig-name descname"><span class="pre">gradient</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/BlockFunction.html#BlockFunction.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.gradient" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of the BlockFunction function at x.</p>
<div class="math notranslate nohighlight">
\[F'(x) = [f_{1}'(x_{1}), ... , f_{m}'(x_{m})]\]</div>
<p>Parameter:</p>
<blockquote>
<div><p>x : BlockDataContainer and must have as many rows as self.length</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.BlockFunction.proximal_conjugate">
<code class="sig-name descname"><span class="pre">proximal_conjugate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/BlockFunction.html#BlockFunction.proximal_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.proximal_conjugate" title="Permalink to this definition">#</a></dt>
<dd><p>Proximal operator of the convex conjugate of BlockFunction at x:</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F^{*}}(x) = (\mathrm{prox}_{\tau f^{*}_{i}}(x^{*}_{i}))_{i=1}^{m}\]</div>
<p>Parameter:</p>
<blockquote>
<div><p>x : BlockDataContainer and must have as many rows as self.length</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.functions.BlockFunction.__rmul__">
<code class="sig-name descname"><span class="pre">__rmul__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/functions/BlockFunction.html#BlockFunction.__rmul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.__rmul__" title="Permalink to this definition">#</a></dt>
<dd><p>Define multiplication with a scalar</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>other</strong> – number</p>
</dd>
</dl>
<p>Returns a new <a class="reference external" href="optimisation.html#cil.optimisation.functions.BlockFunction">BlockFunction</a> containing the product of the scalar with all the functions in the block</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="block-operator">
<h2>Block Operator<a class="headerlink" href="#block-operator" title="Permalink to this headline">#</a></h2>
<p><a class="reference external" href="optimisation.html#cil.optimisation.operators.BlockOperators">BlockOperator</a> represent a block matrix with operators</p>
<div class="math notranslate nohighlight">
\[\begin{split}K = \begin{bmatrix}
     A_{1} &amp; A_{2} \\
     A_{3} &amp; A_{4} \\
     A_{5} &amp; A_{6}
\end{bmatrix}_{(3,2)} *  \quad \underbrace{\begin{bmatrix}
x_{1} \\
x_{2}
\end{bmatrix}_{(2,1)}}_{\textbf{x}} =  \begin{bmatrix}
A_{1}x_{1}  + A_{2}x_{2}\\
A_{3}x_{1}  + A_{4}x_{2}\\
A_{5}x_{1}  + A_{6}x_{2}\\
\end{bmatrix}_{(3,1)} =  \begin{bmatrix}
y_{1}\\
y_{2}\\
y_{3}
\end{bmatrix}_{(3,1)} = \textbf{y}\end{split}\]</div>
<p>Column: Share the same domains <span class="math notranslate nohighlight">\(X_{1}, X_{2}\)</span></p>
<p>Rows: Share the same ranges <span class="math notranslate nohighlight">\(Y_{1}, Y_{2}, Y_{3}\)</span></p>
<div class="math notranslate nohighlight">
\[K : (X_{1}\times X_{2}) \rightarrow (Y_{1}\times Y_{2} \times Y_{3})\]</div>
<p><span class="math notranslate nohighlight">\(A_{1}, A_{3}, A_{5}\)</span>: share the same domain <span class="math notranslate nohighlight">\(X_{1}\)</span> and
<span class="math notranslate nohighlight">\(A_{2}, A_{4}, A_{6}\)</span>: share the same domain <span class="math notranslate nohighlight">\(X_{2}\)</span></p>
<div class="math notranslate nohighlight">
\[\begin{split}A_{1}: X_{1} \rightarrow Y_{1} \\
A_{3}: X_{1} \rightarrow Y_{2} \\
A_{5}: X_{1} \rightarrow Y_{3} \\
A_{2}: X_{2} \rightarrow Y_{1} \\
A_{4}: X_{2} \rightarrow Y_{2} \\
A_{6}: X_{2} \rightarrow Y_{3}\end{split}\]</div>
<p>For instance with these ingredients one may write the following objective
function,</p>
<div class="math notranslate nohighlight">
\[\alpha ||\nabla u||_{2,1} + ||u - g||_2^2\]</div>
<p>where <span class="math notranslate nohighlight">\(g\)</span> represent the measured values, <span class="math notranslate nohighlight">\(u\)</span> the solution
<span class="math notranslate nohighlight">\(\nabla\)</span> is the gradient operator, <span class="math notranslate nohighlight">\(|| ~~ ||_{2,1}\)</span> is a norm for
the output of the gradient operator and <span class="math notranslate nohighlight">\(|| x-g ||^2_2\)</span> is
least squares fidelity function as</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}K = \begin{bmatrix}
          \nabla \\
          \mathbb{1}
        \end{bmatrix}\end{split}\\F(x) = \Big[ \alpha \lVert ~x~ \rVert_{2,1} ~~ , ~~ || x - g||_2^2 \Big]\\w = [ u ]\end{aligned}\end{align} \]</div>
<p>Then we have rewritten the problem as</p>
<div class="math notranslate nohighlight">
\[F(Kw) =   \alpha \left\lVert \nabla u \right\rVert_{2,1} + ||u-g||^2_2\]</div>
<p>Which in Python would be like</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">op1</span> <span class="o">=</span> <span class="n">GradientOperator</span><span class="p">(</span><span class="n">ig</span><span class="p">,</span> <span class="n">correlation</span><span class="o">=</span><span class="n">GradientOperator</span><span class="o">.</span><span class="n">CORRELATION_SPACE</span><span class="p">)</span>
<span class="n">op2</span> <span class="o">=</span> <span class="n">IdentityOperator</span><span class="p">(</span><span class="n">ig</span><span class="p">,</span> <span class="n">ag</span><span class="p">)</span>

<span class="c1"># Create BlockOperator</span>
<span class="n">K</span> <span class="o">=</span> <span class="n">BlockOperator</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>

<span class="c1"># Create functions</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">BlockFunction</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">MixedL21Norm</span><span class="p">(),</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">L2NormSquared</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="n">noisy_data</span><span class="p">))</span>
</pre></div>
</div>
<dl class="py class">
<dt id="cil.optimisation.operators.BlockOperator">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></code><code class="sig-name descname"><span class="pre">BlockOperator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator" title="Permalink to this definition">#</a></dt>
<dd><p>A Block matrix containing Operators</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> (<a class="reference internal" href="#cil.optimisation.operators.Operator" title="cil.optimisation.operators.Operator"><em>Operator</em></a>) – Operators in the block.</p></li>
<li><p><strong>**kwargs</strong> (<em>dict</em>) – shape (<code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code>, optional): If shape is passed the Operators in vararg are considered input in a row-by-row fashion.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Block Framework is a generic strategy to treat variational problems in the
following form:</p>
<div class="math notranslate nohighlight">
\[\min Regulariser + Fidelity\]</div>
</div>
<p>BlockOperators have a generic shape M x N, and when applied on an
Nx1 BlockDataContainer, will yield and Mx1 BlockDataContainer.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>BlockDatacontainer are only allowed to have the shape of N x 1, with
N rows and 1 column.</p>
<p>User may specify the shape of the block, by default is a row vector</p>
<p>Operators in a Block are required to have the same domain column-wise and the
same range row-wise.</p>
</div>
<p class="rubric">Examples</p>
<p>BlockOperator(op0,op1) results in a row block</p>
<p>BlockOperator(op0,op1,shape=(1,2)) results in a column block</p>
<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.__init__" title="Permalink to this definition">#</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.column_wise_compatible">
<code class="sig-name descname"><span class="pre">column_wise_compatible</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.column_wise_compatible"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.column_wise_compatible" title="Permalink to this definition">#</a></dt>
<dd><p>Operators in a Block should have the same domain per column</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.row_wise_compatible">
<code class="sig-name descname"><span class="pre">row_wise_compatible</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.row_wise_compatible"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.row_wise_compatible" title="Permalink to this definition">#</a></dt>
<dd><p>Operators in a Block should have the same range per row</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.get_item">
<code class="sig-name descname"><span class="pre">get_item</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">row</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.get_item"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.get_item" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the Operator at specified row and col
:param row: The row index required.
:type row: <cite>int</cite>
:param col: The column index required.
:type col: <cite>int</cite></p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.norm">
<code class="sig-name descname"><span class="pre">norm</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.norm" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the Euclidean norm of the norms of the individual operators in the BlockOperators</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.get_norms_as_list">
<code class="sig-name descname"><span class="pre">get_norms_as_list</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.get_norms_as_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.get_norms_as_list" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a list of the individual norms of the Operators in the BlockOperator</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.set_norms">
<code class="sig-name descname"><span class="pre">set_norms</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norms</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.set_norms"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.set_norms" title="Permalink to this definition">#</a></dt>
<dd><p>Uses the set_norm() function in Operator to set the norms of the operators in the BlockOperator from a list of custom values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>norms</strong> (<em>list</em>) – A list of positive real values the same length as the number of operators in the BlockOperator.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.direct">
<code class="sig-name descname"><span class="pre">direct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.direct" title="Permalink to this definition">#</a></dt>
<dd><p>Direct operation for the BlockOperator</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>BlockOperators work on BlockDataContainers, but they will also work on DataContainers
and inherited classes by simple wrapping the input in a BlockDataContainer of shape (1,1)</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.adjoint">
<code class="sig-name descname"><span class="pre">adjoint</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.adjoint" title="Permalink to this definition">#</a></dt>
<dd><p>Adjoint operation for the BlockOperator</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>BlockOperator may contain both LinearOperator and Operator
This method exists in BlockOperator as it is not known what type of
Operator it will contain.</p>
<p>BlockOperators work on BlockDataContainers, but they will also work on DataContainers
and inherited classes by simple wrapping the input in a BlockDataContainer of shape (1,1)</p>
<p>Raises: ValueError if the contained Operators are not linear</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.is_linear">
<code class="sig-name descname"><span class="pre">is_linear</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.is_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.is_linear" title="Permalink to this definition">#</a></dt>
<dd><p>Returns whether all the elements of the BlockOperator are linear</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.get_output_shape">
<code class="sig-name descname"><span class="pre">get_output_shape</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xshape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adjoint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.get_output_shape"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.get_output_shape" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the shape of the output BlockDataContainer
:param xshape:
:type xshape: BlockDataContainer
:param adjoint:
:type adjoint: <cite>bool</cite></p>
<p class="rubric">Examples</p>
<p>A(N,M) direct u(M,1) -&gt; N,1</p>
<p>A(N,M)^T adjoint u(N,1) -&gt; M,1</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.__rmul__">
<code class="sig-name descname"><span class="pre">__rmul__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scalar</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.__rmul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.__rmul__" title="Permalink to this definition">#</a></dt>
<dd><p>Defines the left multiplication with a scalar. Returns a block operator with Scaled Operators inside.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>scalar</strong> (<em>number</em><em> or </em><em>iterable containing numbers</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.T">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">T</span></code><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.T" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the transposed of self.</p>
<p>Recall the input list is shaped in a row-by-row fashion</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.domain_geometry">
<code class="sig-name descname"><span class="pre">domain_geometry</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.domain_geometry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.domain_geometry" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the domain of the BlockOperator</p>
<p>If the shape of the BlockOperator is (N,1) the domain is a ImageGeometry or AcquisitionGeometry.
Otherwise it is a BlockGeometry.</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.range_geometry">
<code class="sig-name descname"><span class="pre">range_geometry</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.range_geometry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.range_geometry" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the range of the BlockOperator</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.__getitem__">
<code class="sig-name descname"><span class="pre">__getitem__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.__getitem__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.__getitem__" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the index-th operator in the block irrespectively of it’s shape</p>
</dd></dl>

<dl class="py method">
<dt id="cil.optimisation.operators.BlockOperator.get_as_list">
<code class="sig-name descname"><span class="pre">get_as_list</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cil/optimisation/operators/BlockOperator.html#BlockOperator.get_as_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.get_as_list" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the list of operators</p>
</dd></dl>

</dd></dl>

<p><a class="reference internal" href="index.html#mastertoc"><span class="std std-ref">Return Home</span></a></p>
<div class="section" id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<div class="docutils container" id="id22">
<dl class="citation">
<dt class="label" id="id28"><span class="brackets">1</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id5">2</a>,<a href="#id12">3</a>)</span></dt>
<dd><p>Amir Beck and Marc Teboulle. A fast iterative shrinkage-thresholding algorithm for linear inverse problems. <em>SIAM Journal on Imaging Sciences</em>, 2(1):183–202, 2009. URL: <a class="reference external" href="https://doi.org/10.1137/080716542">https://doi.org/10.1137/080716542</a>, <a class="reference external" href="https://arxiv.org/abs/https://doi.org/10.1137/080716542">arXiv:https://doi.org/10.1137/080716542</a>, <a class="reference external" href="https://doi.org/10.1137/080716542">doi:10.1137/080716542</a>.</p>
</dd>
<dt class="label" id="id27"><span class="brackets">2</span><span class="fn-backref">(<a href="#id3">1</a>,<a href="#id6">2</a>,<a href="#id13">3</a>)</span></dt>
<dd><p>Amir Beck and Marc Teboulle. Fast gradient-based algorithms for constrained total variation image denoising and deblurring problems. <em>IEEE Transactions on Image Processing</em>, 18(11):2419–2434, 2009. <a class="reference external" href="https://doi.org/10.1109/TIP.2009.2028250">doi:10.1109/TIP.2009.2028250</a>.</p>
</dd>
<dt class="label" id="id23"><span class="brackets">3</span><span class="fn-backref">(<a href="#id7">1</a>,<a href="#id16">2</a>)</span></dt>
<dd><p>Antonin Chambolle and Thomas Pock. A first-order primal-dual algorithm for convex problems with applications to imaging. <em>Journal of Mathematical Imaging and Vision</em>, 40(1):120–145, May 2011. URL: <a class="reference external" href="https://doi.org/10.1007/s10851-010-0251-1">https://doi.org/10.1007/s10851-010-0251-1</a>, <a class="reference external" href="https://doi.org/10.1007/s10851-010-0251-1">doi:10.1007/s10851-010-0251-1</a>.</p>
</dd>
<dt class="label" id="id24"><span class="brackets"><a class="fn-backref" href="#id8">4</a></span></dt>
<dd><p>Ernie Esser, Xiaoqun Zhang, and Tony F. Chan. A general framework for a class of first order primal-dual algorithms for convex optimization in imaging science. <em>SIAM Journal on Imaging Sciences</em>, 3(4):1015–1046, 2010. URL: <a class="reference external" href="https://doi.org/10.1137/09076934X">https://doi.org/10.1137/09076934X</a>, <a class="reference external" href="https://arxiv.org/abs/https://doi.org/10.1137/09076934X">arXiv:https://doi.org/10.1137/09076934X</a>, <a class="reference external" href="https://doi.org/10.1137/09076934X">doi:10.1137/09076934X</a>.</p>
</dd>
<dt class="label" id="id26"><span class="brackets"><a class="fn-backref" href="#id9">5</a></span></dt>
<dd><p>J. S. Jörgensen, E. Ametova, G. Burca, G. Fardell, E. Papoutsellis, E. Pasca, K. Thielemans, M. Turner, R. Warr, W. R. B. Lionheart, and P. J. Withers. Core imaging library - part i: a versatile python framework for tomographic imaging. <em>Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences</em>, 379(2204):20200192, 2021. URL: <a class="reference external" href="https://royalsocietypublishing.org/doi/abs/10.1098/rsta.2020.0192">https://royalsocietypublishing.org/doi/abs/10.1098/rsta.2020.0192</a>, <a class="reference external" href="https://arxiv.org/abs/https://royalsocietypublishing.org/doi/pdf/10.1098/rsta.2020.0192">arXiv:https://royalsocietypublishing.org/doi/pdf/10.1098/rsta.2020.0192</a>, <a class="reference external" href="https://doi.org/10.1098/rsta.2020.0192">doi:10.1098/rsta.2020.0192</a>.</p>
</dd>
<dt class="label" id="id30"><span class="brackets"><a class="fn-backref" href="#id1">6</a></span></dt>
<dd><p>Avinash C. Kak and Malcolm Slaney. <em>Principles of Computerized Tomographic Imaging</em>. Society for Industrial and Applied Mathematics, January 2001. URL: <a class="reference external" href="https://doi.org/10.1137/1.9780898719277">https://doi.org/10.1137/1.9780898719277</a>, <a class="reference external" href="https://doi.org/10.1137/1.9780898719277">doi:10.1137/1.9780898719277</a>.</p>
</dd>
<dt class="label" id="id25"><span class="brackets"><a class="fn-backref" href="#id10">7</a></span></dt>
<dd><p>Evangelos Papoutsellis, Evelina Ametova, Claire Delplancke, Gemma Fardell, Jakob S. Jörgensen, Edoardo Pasca, Martin Turner, Ryan Warr, William R. B. Lionheart, and Philip J. Withers. Core imaging library - part ii: multichannel reconstruction for dynamic and spectral tomography. <em>Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences</em>, 379(2204):20200193, 2021. URL: <a class="reference external" href="https://royalsocietypublishing.org/doi/abs/10.1098/rsta.2020.0193">https://royalsocietypublishing.org/doi/abs/10.1098/rsta.2020.0193</a>, <a class="reference external" href="https://arxiv.org/abs/https://royalsocietypublishing.org/doi/pdf/10.1098/rsta.2020.0193">arXiv:https://royalsocietypublishing.org/doi/pdf/10.1098/rsta.2020.0193</a>, <a class="reference external" href="https://doi.org/10.1098/rsta.2020.0193">doi:10.1098/rsta.2020.0193</a>.</p>
</dd>
<dt class="label" id="id29"><span class="brackets"><a class="fn-backref" href="#id15">8</a></span></dt>
<dd><p>Julian Rasch and Antonin Chambolle. Inexact first-order primal–dual algorithms. <em>Computational Optimization and Applications</em>, 76(2):381–430, Jun 2020. URL: <a class="reference external" href="https://doi.org/10.1007/s10589-020-00186-y">https://doi.org/10.1007/s10589-020-00186-y</a>, <a class="reference external" href="https://doi.org/10.1007/s10589-020-00186-y">doi:10.1007/s10589-020-00186-y</a>.</p>
</dd>
<dt class="label" id="id31"><span class="brackets"><a class="fn-backref" href="#id14">9</a></span></dt>
<dd><p>Mingqiang Zhu, Stephen J. Wright, and Tony F. Chan. Duality-based algorithms for total-variation-regularized image restoration. <em>Computational Optimization and Applications</em>, 47(3):377–400, Nov 2010. URL: <a class="reference external" href="https://doi.org/10.1007/s10589-008-9225-2">https://doi.org/10.1007/s10589-008-9225-2</a>, <a class="reference external" href="https://doi.org/10.1007/s10589-008-9225-2">doi:10.1007/s10589-008-9225-2</a>.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>


              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="io.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Read/ write AcquisitionData and ImageData</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="processors.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Processors</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
              
          </main>
          

      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2017-2021 UKRI-STFC, University of Manchester.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.5.4.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>