
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Optimisation framework &#8212; CIL 24.2.1.dev31+g887fdf34 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=4b6f475cff7c1d6e2a7b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=4b6f475cff7c1d6e2a7b" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css?v=d2d258e8" />
  
  <!-- So that users can add custom icons -->
  <script src="../_static/scripts/fontawesome.js?digest=4b6f475cff7c1d6e2a7b"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=4b6f475cff7c1d6e2a7b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=4b6f475cff7c1d6e2a7b" />

    <script src="../_static/documentation_options.js?v=107f4003"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'optimisation';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_version = '0.16.1';
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = '/CIL/versions.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = '24.2.1.dev31+g887fdf34';
        DOCUMENTATION_OPTIONS.show_version_warning_banner =
            true;
        </script>
    <script>DOCUMENTATION_OPTIONS.search_as_you_type = false;</script>
    <link rel="index" title="Index" href="../genindex/" />
    <link rel="search" title="Search" href="../search/" />
    <link rel="next" title="Processors" href="../processors/" />
    <link rel="prev" title="Read/ write AcquisitionData and ImageData" href="../io/" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="24.2.1.dev31+g887fdf34" />
  
    
    <script src="../_static/searchtools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../searchindex.js"></script>
  
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../search/"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
     
  

<a class="navbar-brand logo" href="/">
  
  
  
  
  
    
    
      
    
    
    <img src="https://ccpi.ac.uk/wp-content/uploads/2022/11/CIL-logo-RGB.svg" class="logo__image only-light" alt="CIL - Home"/>
    <img src="https://ccpi.ac.uk/wp-content/uploads/2022/11/CIL-logo-RGB-reversed.svg" class="logo__image only-dark pst-js-only" alt="CIL - Home"/>
  
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../introduction/">
    Introduction
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../framework/">
    Framework
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../io/">
    Read/ write AcquisitionData and ImageData
  </a>
</li>


<li class="nav-item current active">
  <a class="nav-link nav-internal" href="#">
    Optimisation framework
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../processors/">
    Processors
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../recon/">
    Recon
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../utilities/">
    Utilities
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../plugins/">
    CIL Plugins
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../developer_guide/">
    Developers’ Guide
  </a>
</li>

            <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button"
                data-bs-toggle="dropdown" aria-expanded="false"
                aria-controls="pst-nav-more-links">
                    More
                </button>
                <ul id="pst-nav-more-links" class="dropdown-menu">
                    
<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="../demos/">
    Tutorials
  </a>
</li>

                </ul>
            </li>
            
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
    </div>
    
  </div>
  
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../introduction/">
    Introduction
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../framework/">
    Framework
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../io/">
    Read/ write AcquisitionData and ImageData
  </a>
</li>


<li class="nav-item current active">
  <a class="nav-link nav-internal" href="#">
    Optimisation framework
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../processors/">
    Processors
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../recon/">
    Recon
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../utilities/">
    Utilities
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../plugins/">
    CIL Plugins
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../developer_guide/">
    Developers’ Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../demos/">
    Tutorials
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<form class="bd-search d-flex align-items-center"
      action="../search/"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
        <div class="sidebar-primary-item">
<div class="version-switcher__container dropdown pst-js-only">
  <button id="pst-version-switcher-button-2"
    type="button"
    class="version-switcher__button btn btn-sm dropdown-toggle"
    data-bs-toggle="dropdown"
    aria-haspopup="listbox"
    aria-controls="pst-version-switcher-list-2"
    aria-label="Version switcher list"
  >
    Choose version  <!-- this text may get changed later by javascript -->
    <span class="caret"></span>
  </button>
  <div id="pst-version-switcher-list-2"
    class="version-switcher__menu dropdown-menu list-group-flush py-0"
    role="listbox" aria-labelledby="pst-version-switcher-button-2">
    <!-- dropdown will be populated by javascript on page load -->
  </div>
</div></div>
        <div class="sidebar-primary-item">
<h3><a href="../">Table of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../framework/">Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../io/">Read/ write AcquisitionData and ImageData</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Optimisation framework</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#algorithms-deterministic">Algorithms (Deterministic)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#base-class">Base class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#gd">GD</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cgls">CGLS</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sirt">SIRT</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ista-pgd">ISTA/PGD</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fista-apgd">FISTA/APGD</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pdhg">PDHG</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ladmm">LADMM</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pd3o">PD3O</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#algorithms-stochastic">Algorithms (Stochastic)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#spdhg">SPDHG</a></li>
<li class="toctree-l3"><a class="reference internal" href="#approximate-gradient-methods">Approximate gradient methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="#stochastic-gradient-descent-example">Stochastic Gradient Descent Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#note">Note</a></li>
<li class="toctree-l3"><a class="reference internal" href="#memory-requirements">Memory requirements</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#operators">Operators</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#operator-base-classes">Operator base classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#trivial-operators">Trivial operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#gradientoperator">GradientOperator</a></li>
<li class="toctree-l3"><a class="reference internal" href="#waveletoperator">WaveletOperator</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#functions">Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#base-classes">Base classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simple-functions">Simple functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#composition-of-operator-and-a-function">Composition of operator and a function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#indicator-box">Indicator box</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kullbackleibler">KullbackLeibler</a></li>
<li class="toctree-l3"><a class="reference internal" href="#l1-norm">L1 Norm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#l2-norm-squared">L2 Norm Squared</a></li>
<li class="toctree-l3"><a class="reference internal" href="#least-squares">Least Squares</a></li>
<li class="toctree-l3"><a class="reference internal" href="#l1-sparsity">L1 Sparsity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mixed-l21-norm">Mixed L21 norm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#smooth-mixed-l21-norm">Smooth Mixed L21 norm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mixed-l11-norm">Mixed L11 norm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#total-variation">Total variation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#approximate-gradient-base-class">Approximate Gradient base class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#stochastic-gradient-function">Stochastic Gradient function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sag-function">SAG function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#saga-function">SAGA function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#stochastic-variance-reduced-gradient-function">Stochastic Variance Reduced Gradient Function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#loopless-stochastic-variance-reduced-gradient-function">Loopless Stochastic Variance Reduced Gradient Function</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#utilities">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#samplers">Samplers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#callbacks">Callbacks</a></li>
<li class="toctree-l3"><a class="reference internal" href="#step-size-methods">Step size methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="#preconditioners">Preconditioners</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#block-framework">Block Framework</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#blockdatacontainer">BlockDataContainer</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cil.framework.BlockDataContainer"><code class="docutils literal notranslate"><span class="pre">BlockDataContainer</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#block-function">Block Function</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cil.optimisation.functions.BlockFunction"><code class="docutils literal notranslate"><span class="pre">BlockFunction</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#block-operator">Block Operator</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cil.optimisation.operators.BlockOperator"><code class="docutils literal notranslate"><span class="pre">BlockOperator</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../processors/">Processors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../recon/">Recon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utilities/">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plugins/">CIL Plugins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer_guide/">Developers’ Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demos/">Tutorials</a></li>
</ul>
</div>
        <div class="sidebar-primary-item">

  
  <div class="tocsection editthispage">
    <a href="https://github.com/TomographicImaging/CIL/edit/master/docs/source/optimisation.rst">
      <i class="fa-solid fa-pencil"></i>
      
      
        
          Edit on GitHub
        
      
    </a>
  </div>
</div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">Optimisation framework</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="optimisation-framework">
<h1>Optimisation framework<a class="headerlink" href="#optimisation-framework" title="Link to this heading">#</a></h1>
<p>This package allows rapid prototyping of optimisation-based reconstruction problems, i.e. defining and solving different optimization problems to enforce different properties on the reconstructed image.</p>
<p>Firstly, it provides an object-oriented framework for defining mathematical operators and functions as well a collection of useful example operators and functions. Both smooth and non-smooth functions can be used.</p>
<p>Further, it provides a number of high-level generic implementations of optimisation algorithms to solve generically formulated optimisation problems constructed from operator and function objects.</p>
<p>The fundamental components are:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">Operator</span></code>: A class specifying a (currently linear) operator.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">Function</span></code>: A class specifying mathematical functions such as a least squares data fidelity.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">Algorithm</span></code>: Implementation of an iterative optimisation algorithm to solve a particular generic optimisation problem. Algorithms are iterable Python object which can be run in a for loop. Can be stopped and warm restarted.</p></li>
</ul>
<section id="algorithms-deterministic">
<h2>Algorithms (Deterministic)<a class="headerlink" href="#algorithms-deterministic" title="Link to this heading">#</a></h2>
<p>A number of generic algorithm implementations are provided including
Gradient Descent (GD), Conjugate Gradient Least Squares (CGLS),
Simultaneous Iterative Reconstruction Technique (SIRT), Primal Dual Hybrid
Gradient (PDHG), Primal dual three-operator (PD3O),  Iterative Shrinkage Thresholding Algorithm (ISTA),
and Fast Iterative Shrinkage Thresholding Algorithm (FISTA).</p>
<p>An algorithm is designed for a particular generic optimisation problem accepts and number of
instances of <code class="code docutils literal notranslate"><span class="pre">Function</span></code> derived classes and/or <code class="code docutils literal notranslate"><span class="pre">Operator</span></code> derived classes as input to
define a specific instance of the generic optimisation problem to be solved.
They are iterable objects which can be run in a for loop.
The user can provide a stopping criterion different than the default max_iteration.</p>
<p>New algorithms can be easily created by extending the <code class="code docutils literal notranslate"><span class="pre">Algorithm</span></code> class.
The user is required to implement only 4 methods: set_up, __init__, update and update_objective.</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">set_up</span></code> and <code class="code docutils literal notranslate"><span class="pre">__init__</span></code> are used to configure the algorithm</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">update</span></code> is the actual iteration updating the solution</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">update_objective</span></code> defines how the objective is calculated.</p></li>
</ul>
<p>For example, the implementation of the update of the Gradient Descent
algorithm to minimise a Function will only be:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">rate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective_function</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">update_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objective_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>The <code class="code docutils literal notranslate"><span class="pre">Algorithm</span></code> provides the infrastructure to continue iteration, to access the values of the
objective function in subsequent iterations, the time for each iteration, and to provide a nice
print to screen of the status of the optimisation.</p>
<section id="base-class">
<h3>Base class<a class="headerlink" href="#base-class" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></span><span class="sig-name descname"><span class="pre">Algorithm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">update_objective_interval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iteration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/Algorithm/#Algorithm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm" title="Link to this definition">#</a></dt>
<dd><p>Base class providing minimal infrastructure for iterative algorithms.</p>
<p>An iterative algorithm is designed to solve an optimization problem by repeatedly refining a solution. In CIL, we use iterative algorithms to minimize an objective function, often referred to as a loss. The process begins with an initial guess, and with each iteration, the algorithm updates the current solution based on the results of previous iterations (previous iterates). Iterative algorithms typically continue until a stopping criterion is met, indicating that an optimal or sufficiently good solution has been found. In CIL, stopping criteria can be implemented using a callback function (<cite>cil.optimisation.utilities.callbacks</cite>).</p>
<blockquote>
<div><p>The user is required to implement the <code class="code docutils literal notranslate"><span class="pre">set_up</span></code>, <code class="code docutils literal notranslate"><span class="pre">__init__</span></code>, <code class="code docutils literal notranslate"><span class="pre">update</span></code> and <code class="code docutils literal notranslate"><span class="pre">update_objective</span></code> methods.</p>
<p>The method <code class="code docutils literal notranslate"><span class="pre">run</span></code> is available to run <code class="code docutils literal notranslate"><span class="pre">n</span></code> iterations. The method accepts <code class="code docutils literal notranslate"><span class="pre">callbacks</span></code>: a list of callables, each of which receive the current Algorithm object (which in turn contains the iteration number and the actual objective value) and can be used to trigger print to screens and other user interactions. The <code class="code docutils literal notranslate"><span class="pre">run</span></code> method will stop when the stopping criterion is met or <cite>StopIteration</cite> is raised.</p>
<dl class="simple">
<dt>update_objective_interval: int, optional, default 1</dt><dd><p>The objective (or loss) is calculated and saved every <cite>update_objective_interval</cite>.  1 means every iteration, 2 every 2 iterations and so forth. This is by default 1 and should be increased when evaluating the objective is computationally expensive.</p>
</dd>
</dl>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.set_up">
<span class="sig-name descname"><span class="pre">set_up</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/Algorithm/#Algorithm.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.set_up" title="Link to this definition">#</a></dt>
<dd><p>Set up the algorithm</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/Algorithm/#Algorithm.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.update" title="Link to this definition">#</a></dt>
<dd><p>A single iteration of the algorithm</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.should_stop">
<span class="sig-name descname"><span class="pre">should_stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/Algorithm/#Algorithm.should_stop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.should_stop" title="Link to this definition">#</a></dt>
<dd><p>default stopping criterion: number of iterations</p>
<p>The user can change this in concrete implementation of iterative algorithms.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.max_iteration_stop_criterion">
<span class="sig-name descname"><span class="pre">max_iteration_stop_criterion</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/Algorithm/#Algorithm.max_iteration_stop_criterion"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.max_iteration_stop_criterion" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.get_output">
<span class="sig-name descname"><span class="pre">get_output</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/Algorithm/#Algorithm.get_output"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.get_output" title="Link to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The current solution</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.is_provably_convergent">
<span class="sig-name descname"><span class="pre">is_provably_convergent</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/Algorithm/#Algorithm.is_provably_convergent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.is_provably_convergent" title="Link to this definition">#</a></dt>
<dd><p>Check if the algorithm is convergent based on the provable convergence criterion.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Outcome of the convergence check</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.solution">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">solution</span></span><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.solution" title="Link to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.get_last_loss">
<span class="sig-name descname"><span class="pre">get_last_loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/Algorithm/#Algorithm.get_last_loss"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.get_last_loss" title="Link to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function. “Loss” is an alias for “objective value”. If <cite>update_objective_interval</cite> is 1 it is the value of the objective at the current iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>return_all</strong> (<em>Boolean</em><em>, </em><em>default is False</em>) – If True, returns all the stored loss functions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Last stored value of the loss function</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.get_last_objective">
<span class="sig-name descname"><span class="pre">get_last_objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.get_last_objective" title="Link to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function. “Loss” is an alias for “objective value”. If <cite>update_objective_interval</cite> is 1 it is the value of the objective at the current iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>return_all</strong> (<em>Boolean</em><em>, </em><em>default is False</em>) – If True, returns all the stored loss functions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Last stored value of the loss function</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.update_objective">
<span class="sig-name descname"><span class="pre">update_objective</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/Algorithm/#Algorithm.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.update_objective" title="Link to this definition">#</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.iterations">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">iterations</span></span><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.iterations" title="Link to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.loss">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">loss</span></span><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.loss" title="Link to this definition">#</a></dt>
<dd><p>returns a list of the values of the objective (alias of loss) during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when the <cite>update_objective_interval</cite> &gt; 1</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.objective">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">objective</span></span><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.objective" title="Link to this definition">#</a></dt>
<dd><p>returns a list of the values of the objective (alias of loss) during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when the <cite>update_objective_interval</cite> &gt; 1</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.max_iteration">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_iteration</span></span><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.max_iteration" title="Link to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.update_objective_interval">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">update_objective_interval</span></span><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.update_objective_interval" title="Link to this definition">#</a></dt>
<dd><p>gets the update_objective_interval</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callbacks</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cil.optimisation.utilities.callbacks.Callback" title="cil.optimisation.utilities.callbacks.Callback"><span class="pre">Callback</span></a><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/Algorithm/#Algorithm.run"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.run" title="Link to this definition">#</a></dt>
<dd><p>run upto <code class="code docutils literal notranslate"><span class="pre">iterations</span></code> with callbacks/logging.</p>
<p>For a demonstration of callbacks see <a class="github reference external" href="https://github.com/TomographicImaging/CIL-Demos/blob/main/misc/callback_demonstration.ipynb">TomographicImaging/CIL-Demos</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> (<em>int</em><em>, </em><em>default is None</em>) – Number of iterations to run. If a positive infinity is passed, the algorithm will run indefinitely until a callback raises <cite>StopIteration</cite>.</p></li>
<li><p><strong>callbacks</strong> (list of callables, default is Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>) – List of callables which are passed the current Algorithm object each iteration. Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>.</p></li>
<li><p><strong>verbose</strong> (<em>0=quiet</em><em>, </em><em>1=info</em><em>, </em><em>2=debug</em>) – Passed to the default callback to determine the verbosity of the printed output.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.objective_to_dict">
<span class="sig-name descname"><span class="pre">objective_to_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/Algorithm/#Algorithm.objective_to_dict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.objective_to_dict" title="Link to this definition">#</a></dt>
<dd><p>Internal function to save and print objective functions</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.objective_to_string">
<span class="sig-name descname"><span class="pre">objective_to_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/Algorithm/#Algorithm.objective_to_string"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.objective_to_string" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.verbose_output">
<span class="sig-name descname"><span class="pre">verbose_output</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">__</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/Algorithm/#Algorithm.verbose_output"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.verbose_output" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.Algorithm.verbose_header">
<span class="sig-name descname"><span class="pre">verbose_header</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">__</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/Algorithm/#Algorithm.verbose_header"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.Algorithm.verbose_header" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

</dd></dl>

</section>
<section id="gd">
<h3>GD<a class="headerlink" href="#gd" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></span><span class="sig-name descname"><span class="pre">GD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preconditioner</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/GD/#GD"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD" title="Link to this definition">#</a></dt>
<dd><p>Gradient Descent algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> (</em><em>e.g. ImageData</em><em>)</em>) – The initial point for the optimisation</p></li>
<li><p><strong>f</strong> (CIL function (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Function()</span></code></a>. ) with a defined gradient method) – The function to be minimised.</p></li>
<li><p><strong>step_size</strong> (positive real float or subclass of <code class="xref py py-meth docutils literal notranslate"><span class="pre">StepSizeRule()</span></code>, default = None) – If you pass a float this will be used as a constant step size. If left as None and do not pass a step_size_rule then the Armijio rule will be used to perform backtracking to choose a step size at each iteration. If a child class of <code class="xref py py-meth docutils literal notranslate"><span class="pre">cil.optimisation.utilities.StepSizeRule()</span></code>’ is passed then it’s method <cite>get_step_size</cite> is called for each update.</p></li>
<li><p><strong>preconditioner</strong> (class with a <cite>apply</cite> method or a function that takes an initialised CIL function as an argument and modifies a provided <cite>gradient</cite>.) – This could be a custom <cite>preconditioner</cite> or one provided in <code class="xref py py-meth docutils literal notranslate"><span class="pre">preconditioner()</span></code>. If None is passed  then <cite>self.gradient_update</cite> will remain unmodified.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.set_up">
<span class="sig-name descname"><span class="pre">set_up</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preconditioner</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/GD/#GD.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD.set_up" title="Link to this definition">#</a></dt>
<dd><p>initialisation of the algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> (</em><em>e.g. ImageData</em><em>)</em>) – The initial point for the optimisation</p></li>
<li><p><strong>f</strong> (<em>CIL function with a defined gradient</em>) – The function to be minimised.</p></li>
<li><p><strong>step_size</strong> (positive real float or subclass of <code class="xref py py-meth docutils literal notranslate"><span class="pre">StepSizeRule()</span></code>, default = None) – If you pass a float this will be used as a constant step size. If left as None and do not pass a step_size_rule then the Armijio rule will be used to perform backtracking to choose a step size at each iteration. If a child class of <code class="xref py py-meth docutils literal notranslate"><span class="pre">cil.optimisation.utilities.StepSizeRule()</span></code>’ is passed then it’s method <cite>get_step_size</cite> is called for each update.</p></li>
<li><p><strong>preconditioner</strong> (class with a <cite>apply</cite> method or a function that takes an initialised CIL function as an argument and modifies a provided <cite>gradient</cite>.) – This could be a custom <cite>preconditioner</cite> or one provided in <code class="xref py py-meth docutils literal notranslate"><span class="pre">preconditioner()</span></code>. If None is passed  then <cite>self.gradient_update</cite> will remain unmodified.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/GD/#GD.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD.update" title="Link to this definition">#</a></dt>
<dd><p>Performs a single iteration of the gradient descent algorithm</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.update_objective">
<span class="sig-name descname"><span class="pre">update_objective</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/GD/#GD.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD.update_objective" title="Link to this definition">#</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.should_stop">
<span class="sig-name descname"><span class="pre">should_stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/GD/#GD.should_stop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD.should_stop" title="Link to this definition">#</a></dt>
<dd><p>Stopping criterion for the gradient descent algorithm</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.calculate_objective_function_at_point">
<span class="sig-name descname"><span class="pre">calculate_objective_function_at_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/GD/#GD.calculate_objective_function_at_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.GD.calculate_objective_function_at_point" title="Link to this definition">#</a></dt>
<dd><p>Calculates the objective at a given point x</p>
<div class="math notranslate nohighlight">
\[f(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.get_last_loss">
<span class="sig-name descname"><span class="pre">get_last_loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.GD.get_last_loss" title="Link to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function. “Loss” is an alias for “objective value”. If <cite>update_objective_interval</cite> is 1 it is the value of the objective at the current iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>return_all</strong> (<em>Boolean</em><em>, </em><em>default is False</em>) – If True, returns all the stored loss functions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Last stored value of the loss function</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.get_last_objective">
<span class="sig-name descname"><span class="pre">get_last_objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.GD.get_last_objective" title="Link to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function. “Loss” is an alias for “objective value”. If <cite>update_objective_interval</cite> is 1 it is the value of the objective at the current iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>return_all</strong> (<em>Boolean</em><em>, </em><em>default is False</em>) – If True, returns all the stored loss functions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Last stored value of the loss function</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.get_output">
<span class="sig-name descname"><span class="pre">get_output</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.GD.get_output" title="Link to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The current solution</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.is_provably_convergent">
<span class="sig-name descname"><span class="pre">is_provably_convergent</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.GD.is_provably_convergent" title="Link to this definition">#</a></dt>
<dd><p>Check if the algorithm is convergent based on the provable convergence criterion.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Outcome of the convergence check</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.iterations">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">iterations</span></span><a class="headerlink" href="#cil.optimisation.algorithms.GD.iterations" title="Link to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.loss">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">loss</span></span><a class="headerlink" href="#cil.optimisation.algorithms.GD.loss" title="Link to this definition">#</a></dt>
<dd><p>returns a list of the values of the objective (alias of loss) during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when the <cite>update_objective_interval</cite> &gt; 1</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.max_iteration">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_iteration</span></span><a class="headerlink" href="#cil.optimisation.algorithms.GD.max_iteration" title="Link to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.max_iteration_stop_criterion">
<span class="sig-name descname"><span class="pre">max_iteration_stop_criterion</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.GD.max_iteration_stop_criterion" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.objective">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">objective</span></span><a class="headerlink" href="#cil.optimisation.algorithms.GD.objective" title="Link to this definition">#</a></dt>
<dd><p>returns a list of the values of the objective (alias of loss) during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when the <cite>update_objective_interval</cite> &gt; 1</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.objective_to_dict">
<span class="sig-name descname"><span class="pre">objective_to_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.GD.objective_to_dict" title="Link to this definition">#</a></dt>
<dd><p>Internal function to save and print objective functions</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.objective_to_string">
<span class="sig-name descname"><span class="pre">objective_to_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.GD.objective_to_string" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callbacks</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cil.optimisation.utilities.callbacks.Callback" title="cil.optimisation.utilities.callbacks.Callback"><span class="pre">Callback</span></a><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.GD.run" title="Link to this definition">#</a></dt>
<dd><p>run upto <code class="code docutils literal notranslate"><span class="pre">iterations</span></code> with callbacks/logging.</p>
<p>For a demonstration of callbacks see <a class="github reference external" href="https://github.com/TomographicImaging/CIL-Demos/blob/main/misc/callback_demonstration.ipynb">TomographicImaging/CIL-Demos</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> (<em>int</em><em>, </em><em>default is None</em>) – Number of iterations to run. If a positive infinity is passed, the algorithm will run indefinitely until a callback raises <cite>StopIteration</cite>.</p></li>
<li><p><strong>callbacks</strong> (list of callables, default is Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>) – List of callables which are passed the current Algorithm object each iteration. Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>.</p></li>
<li><p><strong>verbose</strong> (<em>0=quiet</em><em>, </em><em>1=info</em><em>, </em><em>2=debug</em>) – Passed to the default callback to determine the verbosity of the printed output.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.solution">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">solution</span></span><a class="headerlink" href="#cil.optimisation.algorithms.GD.solution" title="Link to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.update_objective_interval">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">update_objective_interval</span></span><a class="headerlink" href="#cil.optimisation.algorithms.GD.update_objective_interval" title="Link to this definition">#</a></dt>
<dd><p>gets the update_objective_interval</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.verbose_header">
<span class="sig-name descname"><span class="pre">verbose_header</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">__</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.GD.verbose_header" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.GD.verbose_output">
<span class="sig-name descname"><span class="pre">verbose_output</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">__</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.GD.verbose_output" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

</dd></dl>

</section>
<section id="cgls">
<h3>CGLS<a class="headerlink" href="#cgls" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></span><span class="sig-name descname"><span class="pre">CGLS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/CGLS/#CGLS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS" title="Link to this definition">#</a></dt>
<dd><p>Conjugate Gradient Least Squares (CGLS) algorithm</p>
<p>The Conjugate Gradient Least Squares (CGLS) algorithm is commonly used for solving large systems of linear equations, due to its fast convergence.</p>
<p>Problem:</p>
<div class="math notranslate nohighlight">
\[\min_x || A x - b ||^2_2\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> (<a class="reference internal" href="#cil.optimisation.operators.Operator" title="cil.optimisation.operators.Operator"><em>Operator</em></a>) – Linear operator for the inverse problem</p></li>
<li><p><strong>initial</strong> (<em>(</em><em>optional</em><em>) </em><em>DataContainer in the domain</em><em> of </em><em>the operator</em><em>, </em><em>default is a DataContainer filled with zeros.</em>) – Initial guess</p></li>
<li><p><strong>data</strong> (<em>DataContainer in the range</em><em> of </em><em>the operator</em>) – Acquired data to reconstruct</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Passing tolerance directly to CGLS is being deprecated. Instead we recommend using the callback functionality: <a class="reference external" href="https://tomographicimaging.github.io/CIL/nightly/optimisation/#callbacks">https://tomographicimaging.github.io/CIL/nightly/optimisation/#callbacks</a> and in particular the CGLSEarlyStopping callback replicated the old behaviour.</p>
<p><a class="reference external" href="https://web.stanford.edu/group/SOL/software/cgls/">https://web.stanford.edu/group/SOL/software/cgls/</a></p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.set_up">
<span class="sig-name descname"><span class="pre">set_up</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/CGLS/#CGLS.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.set_up" title="Link to this definition">#</a></dt>
<dd><p>Initialisation of the algorithm
:param operator: Linear operator for the inverse problem
:type operator: Operator
:param initial: Initial guess
:type initial: (optional) DataContainer in the domain of the operator, default is a DataContainer filled with zeros.
:param data: Acquired data to reconstruct
:type data: DataContainer in the range of the operator</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/CGLS/#CGLS.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.update" title="Link to this definition">#</a></dt>
<dd><p>single iteration</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.update_objective">
<span class="sig-name descname"><span class="pre">update_objective</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/CGLS/#CGLS.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.update_objective" title="Link to this definition">#</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.should_stop">
<span class="sig-name descname"><span class="pre">should_stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/CGLS/#CGLS.should_stop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.should_stop" title="Link to this definition">#</a></dt>
<dd><p>default stopping criterion: number of iterations</p>
<p>The user can change this in concrete implementation of iterative algorithms.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.flag">
<span class="sig-name descname"><span class="pre">flag</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/CGLS/#CGLS.flag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.flag" title="Link to this definition">#</a></dt>
<dd><p>returns whether the tolerance has been reached</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.get_last_loss">
<span class="sig-name descname"><span class="pre">get_last_loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.get_last_loss" title="Link to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function. “Loss” is an alias for “objective value”. If <cite>update_objective_interval</cite> is 1 it is the value of the objective at the current iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>return_all</strong> (<em>Boolean</em><em>, </em><em>default is False</em>) – If True, returns all the stored loss functions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Last stored value of the loss function</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.get_last_objective">
<span class="sig-name descname"><span class="pre">get_last_objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.get_last_objective" title="Link to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function. “Loss” is an alias for “objective value”. If <cite>update_objective_interval</cite> is 1 it is the value of the objective at the current iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>return_all</strong> (<em>Boolean</em><em>, </em><em>default is False</em>) – If True, returns all the stored loss functions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Last stored value of the loss function</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.get_output">
<span class="sig-name descname"><span class="pre">get_output</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.get_output" title="Link to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The current solution</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.is_provably_convergent">
<span class="sig-name descname"><span class="pre">is_provably_convergent</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.is_provably_convergent" title="Link to this definition">#</a></dt>
<dd><p>Check if the algorithm is convergent based on the provable convergence criterion.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Outcome of the convergence check</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.iterations">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">iterations</span></span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.iterations" title="Link to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.loss">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">loss</span></span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.loss" title="Link to this definition">#</a></dt>
<dd><p>returns a list of the values of the objective (alias of loss) during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when the <cite>update_objective_interval</cite> &gt; 1</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.max_iteration">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_iteration</span></span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.max_iteration" title="Link to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.max_iteration_stop_criterion">
<span class="sig-name descname"><span class="pre">max_iteration_stop_criterion</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.max_iteration_stop_criterion" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.objective">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">objective</span></span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.objective" title="Link to this definition">#</a></dt>
<dd><p>returns a list of the values of the objective (alias of loss) during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when the <cite>update_objective_interval</cite> &gt; 1</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.objective_to_dict">
<span class="sig-name descname"><span class="pre">objective_to_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.objective_to_dict" title="Link to this definition">#</a></dt>
<dd><p>Internal function to save and print objective functions</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.objective_to_string">
<span class="sig-name descname"><span class="pre">objective_to_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.objective_to_string" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callbacks</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cil.optimisation.utilities.callbacks.Callback" title="cil.optimisation.utilities.callbacks.Callback"><span class="pre">Callback</span></a><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.run" title="Link to this definition">#</a></dt>
<dd><p>run upto <code class="code docutils literal notranslate"><span class="pre">iterations</span></code> with callbacks/logging.</p>
<p>For a demonstration of callbacks see <a class="github reference external" href="https://github.com/TomographicImaging/CIL-Demos/blob/main/misc/callback_demonstration.ipynb">TomographicImaging/CIL-Demos</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> (<em>int</em><em>, </em><em>default is None</em>) – Number of iterations to run. If a positive infinity is passed, the algorithm will run indefinitely until a callback raises <cite>StopIteration</cite>.</p></li>
<li><p><strong>callbacks</strong> (list of callables, default is Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>) – List of callables which are passed the current Algorithm object each iteration. Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>.</p></li>
<li><p><strong>verbose</strong> (<em>0=quiet</em><em>, </em><em>1=info</em><em>, </em><em>2=debug</em>) – Passed to the default callback to determine the verbosity of the printed output.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.solution">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">solution</span></span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.solution" title="Link to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.update_objective_interval">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">update_objective_interval</span></span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.update_objective_interval" title="Link to this definition">#</a></dt>
<dd><p>gets the update_objective_interval</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.verbose_header">
<span class="sig-name descname"><span class="pre">verbose_header</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">__</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.verbose_header" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.CGLS.verbose_output">
<span class="sig-name descname"><span class="pre">verbose_output</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">__</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.CGLS.verbose_output" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

</dd></dl>

</section>
<section id="sirt">
<h3>SIRT<a class="headerlink" href="#sirt" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></span><span class="sig-name descname"><span class="pre">SIRT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/SIRT/#SIRT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SIRT" title="Link to this definition">#</a></dt>
<dd><p>Simultaneous Iterative Reconstruction Technique, see <span id="id1">[<a class="reference internal" href="#id57" title="Avinash C. Kak and Malcolm Slaney. Principles of Computerized Tomographic Imaging. Society for Industrial and Applied Mathematics, January 2001. URL: https://doi.org/10.1137/1.9780898719277, doi:10.1137/1.9780898719277.">8</a>]</span>.</p>
<p>Simultaneous Iterative Reconstruction Technique (SIRT) solves
the following problem</p>
<div class="math notranslate nohighlight">
\[A x = b\]</div>
<p>The SIRT update step for iteration <span class="math notranslate nohighlight">\(k\)</span> is given by</p>
<div class="math notranslate nohighlight">
\[x^{k+1} =  \mathrm{proj}_{C}( x^{k} + \omega  D ( A^{T} ( M  (b - Ax^{k}) ) ) ),\]</div>
<p>where,
<span class="math notranslate nohighlight">\(M = \frac{1}{A\mathbb{1}}\)</span>,
<span class="math notranslate nohighlight">\(D = \frac{1}{A^{T}\mathbb{1}}\)</span>,
<span class="math notranslate nohighlight">\(\mathbb{1}\)</span> is a <code class="code docutils literal notranslate"><span class="pre">DataContainer</span></code> of ones,
<span class="math notranslate nohighlight">\(\mathrm{proj}_{C}\)</span> is the projection over a set <span class="math notranslate nohighlight">\(C\)</span>,
and <span class="math notranslate nohighlight">\(\omega\)</span> is the relaxation parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>default = None</em>) – Starting point of the algorithm, default value =  DataContainer in the domain of the operator allocated with zeros.</p></li>
<li><p><strong>operator</strong> (<a class="reference internal" href="#cil.optimisation.operators.LinearOperator" title="cil.optimisation.operators.LinearOperator"><em>LinearOperator</em></a>) – The operator A.</p></li>
<li><p><strong>data</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The data b.</p></li>
<li><p><strong>lower</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, default = None) – Lower bound constraint</p></li>
<li><p><strong>upper</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, default = None) – Upper bound constraint</p></li>
<li><p><strong>constraint</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a><em>, </em><em>default = None</em>) – A function with <code class="code docutils literal notranslate"><span class="pre">proximal</span></code> method, e.g., <a class="reference internal" href="#cil.optimisation.functions.IndicatorBox" title="cil.optimisation.functions.IndicatorBox"><code class="xref py py-class docutils literal notranslate"><span class="pre">IndicatorBox</span></code></a> function and <a class="reference internal" href="#cil.optimisation.functions.IndicatorBox.proximal" title="cil.optimisation.functions.IndicatorBox.proximal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">IndicatorBox.proximal()</span></code></a>,
or <a class="reference internal" href="#cil.optimisation.functions.TotalVariation" title="cil.optimisation.functions.TotalVariation"><code class="xref py py-class docutils literal notranslate"><span class="pre">TotalVariation</span></code></a> function and <a class="reference internal" href="#cil.optimisation.functions.TotalVariation.proximal" title="cil.optimisation.functions.TotalVariation.proximal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TotalVariation.proximal()</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="code docutils literal notranslate"><span class="pre">constraint</span></code> is not passed, <code class="code docutils literal notranslate"><span class="pre">lower</span></code> and <code class="code docutils literal notranslate"><span class="pre">upper</span></code> are used to create an <a class="reference internal" href="#cil.optimisation.functions.IndicatorBox" title="cil.optimisation.functions.IndicatorBox"><code class="xref py py-class docutils literal notranslate"><span class="pre">IndicatorBox</span></code></a> and apply its <code class="code docutils literal notranslate"><span class="pre">proximal</span></code>.</p>
<p>If <code class="code docutils literal notranslate"><span class="pre">constraint</span></code> is passed, <code class="code docutils literal notranslate"><span class="pre">proximal</span></code> method is required to be implemented.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The preconditioning arrays (weights) <code class="code docutils literal notranslate"><span class="pre">M</span></code> and <code class="code docutils literal notranslate"><span class="pre">D</span></code> used in SIRT are defined as</p>
<div class="math notranslate nohighlight">
\[M = \frac{1}{A\mathbb{1}}\]</div>
<div class="math notranslate nohighlight">
\[D = \frac{1}{A^T\mathbb{1}}\]</div>
</div>
<p class="rubric">Examples</p>
<div class="math notranslate nohighlight">
\[\underset{x}{\mathrm{argmin}} \frac{1}{2}\| Ax - d\|^{2}\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sirt</span> <span class="o">=</span> <span class="n">SIRT</span><span class="p">(</span><span class="n">initial</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">operator</span> <span class="o">=</span> <span class="n">A</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.set_up">
<span class="sig-name descname"><span class="pre">set_up</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/SIRT/#SIRT.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.set_up" title="Link to this definition">#</a></dt>
<dd><p>Initialisation of the algorithm</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.relaxation_parameter">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">relaxation_parameter</span></span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.relaxation_parameter" title="Link to this definition">#</a></dt>
<dd><p>Get the relaxation parameter <span class="math notranslate nohighlight">\(\omega\)</span></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.D">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">D</span></span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.D" title="Link to this definition">#</a></dt>
<dd><p>Get the preconditioning array <span class="math notranslate nohighlight">\(D\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.set_relaxation_parameter">
<span class="sig-name descname"><span class="pre">set_relaxation_parameter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/SIRT/#SIRT.set_relaxation_parameter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.set_relaxation_parameter" title="Link to this definition">#</a></dt>
<dd><p>Set the relaxation parameter <span class="math notranslate nohighlight">\(\omega\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>value</strong> (<em>float</em>) – The relaxation parameter to be applied to the update. Must be between 0 and 2 to guarantee asymptotic convergence.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/SIRT/#SIRT.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.update" title="Link to this definition">#</a></dt>
<dd><p>Performs a single iteration of the SIRT algorithm. The update step for iteration <span class="math notranslate nohighlight">\(k\)</span> is given by</p>
<div class="math notranslate nohighlight">
\[x^{k+1} =  \mathrm{proj}_{C}( x^{k} + \omega  D ( A^{T} ( M (b - Ax^{k}) ) ) )\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.update_objective">
<span class="sig-name descname"><span class="pre">update_objective</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/SIRT/#SIRT.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.update_objective" title="Link to this definition">#</a></dt>
<dd><p>Appends the current objective value to the list of previous objective values</p>
<div class="math notranslate nohighlight">
\[\frac{1}{2}\|A x - b\|^{2}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.get_last_loss">
<span class="sig-name descname"><span class="pre">get_last_loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.get_last_loss" title="Link to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function. “Loss” is an alias for “objective value”. If <cite>update_objective_interval</cite> is 1 it is the value of the objective at the current iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>return_all</strong> (<em>Boolean</em><em>, </em><em>default is False</em>) – If True, returns all the stored loss functions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Last stored value of the loss function</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.get_last_objective">
<span class="sig-name descname"><span class="pre">get_last_objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.get_last_objective" title="Link to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function. “Loss” is an alias for “objective value”. If <cite>update_objective_interval</cite> is 1 it is the value of the objective at the current iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>return_all</strong> (<em>Boolean</em><em>, </em><em>default is False</em>) – If True, returns all the stored loss functions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Last stored value of the loss function</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.get_output">
<span class="sig-name descname"><span class="pre">get_output</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.get_output" title="Link to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The current solution</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.is_provably_convergent">
<span class="sig-name descname"><span class="pre">is_provably_convergent</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.is_provably_convergent" title="Link to this definition">#</a></dt>
<dd><p>Check if the algorithm is convergent based on the provable convergence criterion.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Outcome of the convergence check</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.iterations">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">iterations</span></span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.iterations" title="Link to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.loss">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">loss</span></span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.loss" title="Link to this definition">#</a></dt>
<dd><p>returns a list of the values of the objective (alias of loss) during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when the <cite>update_objective_interval</cite> &gt; 1</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.max_iteration">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_iteration</span></span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.max_iteration" title="Link to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.max_iteration_stop_criterion">
<span class="sig-name descname"><span class="pre">max_iteration_stop_criterion</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.max_iteration_stop_criterion" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.objective">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">objective</span></span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.objective" title="Link to this definition">#</a></dt>
<dd><p>returns a list of the values of the objective (alias of loss) during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when the <cite>update_objective_interval</cite> &gt; 1</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.objective_to_dict">
<span class="sig-name descname"><span class="pre">objective_to_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.objective_to_dict" title="Link to this definition">#</a></dt>
<dd><p>Internal function to save and print objective functions</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.objective_to_string">
<span class="sig-name descname"><span class="pre">objective_to_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.objective_to_string" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callbacks</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cil.optimisation.utilities.callbacks.Callback" title="cil.optimisation.utilities.callbacks.Callback"><span class="pre">Callback</span></a><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.run" title="Link to this definition">#</a></dt>
<dd><p>run upto <code class="code docutils literal notranslate"><span class="pre">iterations</span></code> with callbacks/logging.</p>
<p>For a demonstration of callbacks see <a class="github reference external" href="https://github.com/TomographicImaging/CIL-Demos/blob/main/misc/callback_demonstration.ipynb">TomographicImaging/CIL-Demos</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> (<em>int</em><em>, </em><em>default is None</em>) – Number of iterations to run. If a positive infinity is passed, the algorithm will run indefinitely until a callback raises <cite>StopIteration</cite>.</p></li>
<li><p><strong>callbacks</strong> (list of callables, default is Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>) – List of callables which are passed the current Algorithm object each iteration. Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>.</p></li>
<li><p><strong>verbose</strong> (<em>0=quiet</em><em>, </em><em>1=info</em><em>, </em><em>2=debug</em>) – Passed to the default callback to determine the verbosity of the printed output.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.should_stop">
<span class="sig-name descname"><span class="pre">should_stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.should_stop" title="Link to this definition">#</a></dt>
<dd><p>default stopping criterion: number of iterations</p>
<p>The user can change this in concrete implementation of iterative algorithms.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.solution">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">solution</span></span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.solution" title="Link to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.update_objective_interval">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">update_objective_interval</span></span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.update_objective_interval" title="Link to this definition">#</a></dt>
<dd><p>gets the update_objective_interval</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.verbose_header">
<span class="sig-name descname"><span class="pre">verbose_header</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">__</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.verbose_header" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SIRT.verbose_output">
<span class="sig-name descname"><span class="pre">verbose_output</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">__</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SIRT.verbose_output" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

</dd></dl>

</section>
<section id="ista-pgd">
<h3>ISTA/PGD<a class="headerlink" href="#ista-pgd" title="Link to this heading">#</a></h3>
<p>The Iterative Soft Thresholding Algorithm (ISTA) is also known as Proximal Gradient Descent (PGD). Note that in CIL, <a class="reference internal" href="#ista"><span class="std std-ref">PGD</span></a> is an alias of <cite>ISTA</cite>.</p>
<dl class="py class" id="ista">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></span><span class="sig-name descname"><span class="pre">ISTA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preconditioner</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/FISTA/#ISTA"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.ISTA" title="Link to this definition">#</a></dt>
<dd><p>Iterative Shrinkage-Thresholding Algorithm (ISTA), see <span id="id2">[<a class="reference internal" href="#id55" title="Amir Beck and Marc Teboulle. A fast iterative shrinkage-thresholding algorithm for linear inverse problems. SIAM Journal on Imaging Sciences, 2(1):183-202, 2009. URL: https://doi.org/10.1137/080716542, arXiv:https://doi.org/10.1137/080716542, doi:10.1137/080716542.">1</a>]</span>, <span id="id3">[<a class="reference internal" href="#id54" title="Amir Beck and Marc Teboulle. Fast gradient-based algorithms for constrained total variation image denoising and deblurring problems. IEEE Transactions on Image Processing, 18(11):2419-2434, 2009. doi:10.1109/TIP.2009.2028250.">2</a>]</span>, is used to solve:</p>
<div class="math notranslate nohighlight">
\[\min_{x} f(x) + g(x)\]</div>
<p>where <span class="math notranslate nohighlight">\(f\)</span> is differentiable, and <span class="math notranslate nohighlight">\(g\)</span> has a <em>simple</em> proximal operator.</p>
<p>In each update, the algorithm computes:</p>
<div class="math notranslate nohighlight">
\[x_{k+1} = \mathrm{prox}_{\alpha g}(x_{k} - \alpha\nabla f(x_{k}))\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha\)</span> is the <code class="code docutils literal notranslate"><span class="pre">step_size</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For a constant step size, <span class="math notranslate nohighlight">\(\alpha\)</span>, convergence of ISTA
is guaranteed if</p>
<div class="math notranslate nohighlight">
\[\alpha\in(0, \frac{2}{L}),\]</div>
<p>where <span class="math notranslate nohighlight">\(L\)</span> is the Lipschitz constant of <span class="math notranslate nohighlight">\(f\)</span>, see <span id="id4">[<a class="reference internal" href="#id59" title="Patrick L. Combettes and Valérie R. Wajs. Signal recovery by proximal forward-backward splitting. Multiscale Modeling &amp; Simulation, 4(4):1168-1200, 2005. URL: https://doi.org/10.1137/050626090, arXiv:https://doi.org/10.1137/050626090, doi:10.1137/050626090.">4</a>]</span>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – Initial guess of ISTA. <span class="math notranslate nohighlight">\(x_{0}\)</span></p></li>
<li><p><strong>f</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – Differentiable function. If <cite>None</cite> is passed, the algorithm will use the ZeroFunction.</p></li>
<li><p><strong>g</strong> (Function or <cite>None</cite>) – Convex function with <em>simple</em> proximal operator. If <cite>None</cite> is passed, the algorithm will use the ZeroFunction.</p></li>
<li><p><strong>step_size</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code> or child class of <code class="xref py py-meth docutils literal notranslate"><span class="pre">cil.optimisation.utilities.StepSizeRule()</span></code>’,  default = None) – Step size for the gradient step of ISTA. If a float is passed, this is used as a constant step size.  If a child class of <code class="xref py py-meth docutils literal notranslate"><span class="pre">cil.optimisation.utilities.StepSizeRule()</span></code> is passed then its method <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_step_size()</span></code> is called for each update.
The default <code class="code docutils literal notranslate"><span class="pre">step_size</span></code> is a constant <span class="math notranslate nohighlight">\(\frac{0.99*2}{L}\)</span> or 1 if <cite>f=None</cite>.</p></li>
<li><p><strong>preconditioner</strong> (class with an <cite>apply</cite> method or a function that takes an initialised CIL function as an argument and modifies a provided <cite>gradient</cite>.) – This could be a custom <cite>preconditioner</cite> or one provided in <code class="xref py py-meth docutils literal notranslate"><span class="pre">preconditoner()</span></code>. If None is passed then <cite>self.gradient_update</cite> will remain unmodified.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>kwargs: Keyword arguments</dt><dd><p>Arguments from the base class <a class="reference internal" href="#cil.optimisation.algorithms.Algorithm" title="cil.optimisation.algorithms.Algorithm"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algorithm</span></code></a>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the function <cite>g</cite> is set to <cite>None</cite> or to the <cite>ZeroFunction</cite> then the ISTA algorithm is equivalent to Gradient Descent.</p>
<p>If the function <cite>f</cite> is set to <cite>None</cite> or to the <cite>ZeroFunction</cite> then the ISTA algorithm is equivalent to a Proximal Point Algorithm.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The ISTA algorithm is equivalent to the Proximal Gradient Descent (PGD) algorithm. In CIL, the PGD algorithm is an alias for the ISTA algorithm.</p>
</div>
<p class="rubric">Examples</p>
<div class="math notranslate nohighlight">
\[\underset{x}{\mathrm{argmin}}\|A x - b\|^{2}_{2}\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">LeastSquares</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">ZeroFunction</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ig</span> <span class="o">=</span> <span class="n">Aop</span><span class="o">.</span><span class="n">domain</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ista</span> <span class="o">=</span> <span class="n">ISTA</span><span class="p">(</span><span class="n">initial</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">allocate</span><span class="p">(),</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ista</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#cil.optimisation.algorithms.FISTA" title="cil.optimisation.algorithms.FISTA"><code class="xref py py-class docutils literal notranslate"><span class="pre">FISTA</span></code></a>, <a class="reference internal" href="#cil.optimisation.algorithms.GD" title="cil.optimisation.algorithms.GD"><code class="xref py py-class docutils literal notranslate"><span class="pre">GD</span></code></a></p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.set_up">
<span class="sig-name descname"><span class="pre">set_up</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preconditioner</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/FISTA/#ISTA.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.set_up" title="Link to this definition">#</a></dt>
<dd><p>Set up of the algorithm</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/FISTA/#ISTA.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.update" title="Link to this definition">#</a></dt>
<dd><p>Performs a single iteration of ISTA</p>
<div class="math notranslate nohighlight">
\[x_{k+1} = \mathrm{prox}_{\alpha g}(x_{k} - \alpha\nabla f(x_{k}))\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.get_output">
<span class="sig-name descname"><span class="pre">get_output</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/FISTA/#ISTA.get_output"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.get_output" title="Link to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.update_objective">
<span class="sig-name descname"><span class="pre">update_objective</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/FISTA/#ISTA.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.update_objective" title="Link to this definition">#</a></dt>
<dd><p>Updates the objective</p>
<div class="math notranslate nohighlight">
\[f(x) + g(x)\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.calculate_objective_function_at_point">
<span class="sig-name descname"><span class="pre">calculate_objective_function_at_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/FISTA/#ISTA.calculate_objective_function_at_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.calculate_objective_function_at_point" title="Link to this definition">#</a></dt>
<dd><p>Calculates the objective at a given point x</p>
<div class="math notranslate nohighlight">
\[f(x) + g(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.get_last_loss">
<span class="sig-name descname"><span class="pre">get_last_loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.get_last_loss" title="Link to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function. “Loss” is an alias for “objective value”. If <cite>update_objective_interval</cite> is 1 it is the value of the objective at the current iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>return_all</strong> (<em>Boolean</em><em>, </em><em>default is False</em>) – If True, returns all the stored loss functions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Last stored value of the loss function</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.get_last_objective">
<span class="sig-name descname"><span class="pre">get_last_objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.get_last_objective" title="Link to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function. “Loss” is an alias for “objective value”. If <cite>update_objective_interval</cite> is 1 it is the value of the objective at the current iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>return_all</strong> (<em>Boolean</em><em>, </em><em>default is False</em>) – If True, returns all the stored loss functions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Last stored value of the loss function</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.is_provably_convergent">
<span class="sig-name descname"><span class="pre">is_provably_convergent</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.is_provably_convergent" title="Link to this definition">#</a></dt>
<dd><p>Check if the algorithm is convergent based on the provable convergence criterion.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Outcome of the convergence check</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.iterations">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">iterations</span></span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.iterations" title="Link to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.loss">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">loss</span></span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.loss" title="Link to this definition">#</a></dt>
<dd><p>returns a list of the values of the objective (alias of loss) during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when the <cite>update_objective_interval</cite> &gt; 1</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.max_iteration">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_iteration</span></span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.max_iteration" title="Link to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.max_iteration_stop_criterion">
<span class="sig-name descname"><span class="pre">max_iteration_stop_criterion</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.max_iteration_stop_criterion" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.objective">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">objective</span></span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.objective" title="Link to this definition">#</a></dt>
<dd><p>returns a list of the values of the objective (alias of loss) during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when the <cite>update_objective_interval</cite> &gt; 1</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.objective_to_dict">
<span class="sig-name descname"><span class="pre">objective_to_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.objective_to_dict" title="Link to this definition">#</a></dt>
<dd><p>Internal function to save and print objective functions</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.objective_to_string">
<span class="sig-name descname"><span class="pre">objective_to_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.objective_to_string" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callbacks</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cil.optimisation.utilities.callbacks.Callback" title="cil.optimisation.utilities.callbacks.Callback"><span class="pre">Callback</span></a><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.run" title="Link to this definition">#</a></dt>
<dd><p>run upto <code class="code docutils literal notranslate"><span class="pre">iterations</span></code> with callbacks/logging.</p>
<p>For a demonstration of callbacks see <a class="github reference external" href="https://github.com/TomographicImaging/CIL-Demos/blob/main/misc/callback_demonstration.ipynb">TomographicImaging/CIL-Demos</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> (<em>int</em><em>, </em><em>default is None</em>) – Number of iterations to run. If a positive infinity is passed, the algorithm will run indefinitely until a callback raises <cite>StopIteration</cite>.</p></li>
<li><p><strong>callbacks</strong> (list of callables, default is Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>) – List of callables which are passed the current Algorithm object each iteration. Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>.</p></li>
<li><p><strong>verbose</strong> (<em>0=quiet</em><em>, </em><em>1=info</em><em>, </em><em>2=debug</em>) – Passed to the default callback to determine the verbosity of the printed output.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.should_stop">
<span class="sig-name descname"><span class="pre">should_stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.should_stop" title="Link to this definition">#</a></dt>
<dd><p>default stopping criterion: number of iterations</p>
<p>The user can change this in concrete implementation of iterative algorithms.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.solution">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">solution</span></span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.solution" title="Link to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.update_objective_interval">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">update_objective_interval</span></span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.update_objective_interval" title="Link to this definition">#</a></dt>
<dd><p>gets the update_objective_interval</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.verbose_header">
<span class="sig-name descname"><span class="pre">verbose_header</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">__</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.verbose_header" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.ISTA.verbose_output">
<span class="sig-name descname"><span class="pre">verbose_output</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">__</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.ISTA.verbose_output" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

</dd></dl>

</section>
<section id="fista-apgd">
<h3>FISTA/APGD<a class="headerlink" href="#fista-apgd" title="Link to this heading">#</a></h3>
<p>The Fast Iterative Soft Thresholding Algorithm (FISTA) is also known as Accelerated Proximal Gradient Descent (APGD). Note that in CIL, <a class="reference internal" href="#fista"><span class="std std-ref">APGD</span></a> is an alias of <cite>FISTA</cite>.</p>
<dl class="py class" id="fista">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></span><span class="sig-name descname"><span class="pre">FISTA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preconditioner</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/FISTA/#FISTA"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.FISTA" title="Link to this definition">#</a></dt>
<dd><p>Fast Iterative Shrinkage-Thresholding Algorithm (FISTA), see <span id="id5">[<a class="reference internal" href="#id55" title="Amir Beck and Marc Teboulle. A fast iterative shrinkage-thresholding algorithm for linear inverse problems. SIAM Journal on Imaging Sciences, 2(1):183-202, 2009. URL: https://doi.org/10.1137/080716542, arXiv:https://doi.org/10.1137/080716542, doi:10.1137/080716542.">1</a>]</span>, <span id="id6">[<a class="reference internal" href="#id54" title="Amir Beck and Marc Teboulle. Fast gradient-based algorithms for constrained total variation image denoising and deblurring problems. IEEE Transactions on Image Processing, 18(11):2419-2434, 2009. doi:10.1109/TIP.2009.2028250.">2</a>]</span>, is used to solve:</p>
<div class="math notranslate nohighlight">
\[\min_{x} f(x) + g(x)\]</div>
<p>where <span class="math notranslate nohighlight">\(f\)</span> is differentiable and <span class="math notranslate nohighlight">\(g\)</span> has a <em>simple</em> proximal operator.</p>
<p>In each update the algorithm completes the following steps:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
        x_{k} = \mathrm{prox}_{\alpha g}(y_{k} - \alpha\nabla f(y_{k}))\\
        t_{k+1} = \frac{1+\sqrt{1+ 4t_{k}^{2}}}{2}\\
        y_{k+1} = x_{k} + \frac{t_{k}-1}{t_{k+1}}(x_{k} - x_{k-1})
\end{cases}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha\)</span> is the <code class="code docutils literal notranslate"><span class="pre">step_size</span></code>.</p>
<p>Note that the above applies for <span class="math notranslate nohighlight">\(k\geq 1\)</span>. For <span class="math notranslate nohighlight">\(k=0\)</span>, <span class="math notranslate nohighlight">\(x_{0}\)</span> and <span class="math notranslate nohighlight">\(y_{0}\)</span> are initialised to <cite>initial</cite>, and <span class="math notranslate nohighlight">\(t_{1}=1\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – Starting point of the algorithm</p></li>
<li><p><strong>f</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – Differentiable function.  If <cite>None</cite> is passed, the algorithm will use the ZeroFunction.</p></li>
<li><p><strong>g</strong> (Function or <cite>None</cite>) – Convex function with <em>simple</em> proximal operator. If <cite>None</cite> is passed, the algorithm will use the ZeroFunction.</p></li>
<li><p><strong>step_size</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code> or child class of <code class="xref py py-meth docutils literal notranslate"><span class="pre">cil.optimisation.utilities.StepSizeRule()</span></code>’,  default = None) – Step size for the gradient step of ISTA. If a float is passed, this is used as a constant step size. If a child class of <code class="xref py py-meth docutils literal notranslate"><span class="pre">cil.optimisation.utilities.StepSizeRule()</span></code> is passed then it’s method <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_step_size()</span></code> is called for each update.
The default <code class="code docutils literal notranslate"><span class="pre">step_size</span></code> is a constant <span class="math notranslate nohighlight">\(\frac{1}{L}\)</span> or 1 if <cite>f=None</cite>.</p></li>
<li><p><strong>preconditioner</strong> (class with an <cite>apply</cite> method or a function that takes an initialised CIL function as an argument and modifies a provided <cite>gradient</cite>.) – This could be a custom <cite>preconditioner</cite> or one provided in <code class="xref py py-meth docutils literal notranslate"><span class="pre">preconditoner()</span></code>. If None is passed  then <cite>self.gradient_update</cite> will remain unmodified.</p></li>
<li><p><strong>kwargs</strong> (<em>Keyword arguments</em>) – Arguments from the base class <a class="reference internal" href="#cil.optimisation.algorithms.Algorithm" title="cil.optimisation.algorithms.Algorithm"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algorithm</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the function <cite>g</cite> is set to <cite>None</cite> or to the <cite>ZeroFunction</cite> then the FISTA algorithm is equivalent to Accelerated Gradient Descent by Nesterov (<span id="id7">[<a class="reference internal" href="#id49" title="Yurii Nesterov. Introductory lectures on convex optimization: A basic course. Volume 87. Springer Science &amp; Business Media, 2003.">9</a>]</span> algorithm 2.2.9).</p>
<p>If the function <cite>f</cite> is set to <cite>None</cite> or to the <cite>ZeroFunction</cite> then the FISTA algorithm is equivalent to Guler’s First Accelerated Proximal Point Method  (<span id="id8">[<a class="reference internal" href="#id48" title="Osman Güler. New proximal point algorithms for convex minimization. SIAM Journal on Optimization, 2(4):649–664, 1992.">6</a>]</span> sec 2).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>FISTA is also known as Accelerated Proximal Gradient Descent (APGD). Note that in CIL, ‘APGD’ is an alias of ‘FISTA’.</p>
</div>
<p class="rubric">Examples</p>
<div class="math notranslate nohighlight">
\[\underset{x}{\mathrm{argmin}}\|A x - b\|^{2}_{2}\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">LeastSquares</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">ZeroFunction</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ig</span> <span class="o">=</span> <span class="n">Aop</span><span class="o">.</span><span class="n">domain</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fista</span> <span class="o">=</span> <span class="n">FISTA</span><span class="p">(</span><span class="n">initial</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">allocate</span><span class="p">(),</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fista</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#cil.optimisation.algorithms.FISTA" title="cil.optimisation.algorithms.FISTA.FISTA"><code class="xref py py-class docutils literal notranslate"><span class="pre">FISTA</span></code></a>, <a class="reference internal" href="#cil.optimisation.algorithms.GD" title="cil.optimisation.algorithms.GD"><code class="xref py py-class docutils literal notranslate"><span class="pre">GD</span></code></a></p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/FISTA/#FISTA.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.update" title="Link to this definition">#</a></dt>
<dd><p>Performs a single iteration of FISTA. For <span class="math notranslate nohighlight">\(k\geq 1\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
    x_{k} = \mathrm{prox}_{\alpha g}(y_{k} - \alpha\nabla f(y_{k}))\\
    t_{k+1} = \frac{1+\sqrt{1+ 4t_{k}^{2}}}{2}\\
    y_{k+1} = x_{k} + \frac{t_{k}-1}{t_{k+1}}(x_{k} - x_{k-1})
\end{cases}\end{split}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.calculate_objective_function_at_point">
<span class="sig-name descname"><span class="pre">calculate_objective_function_at_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.calculate_objective_function_at_point" title="Link to this definition">#</a></dt>
<dd><p>Calculates the objective at a given point x</p>
<div class="math notranslate nohighlight">
\[f(x) + g(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.get_last_loss">
<span class="sig-name descname"><span class="pre">get_last_loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.get_last_loss" title="Link to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function. “Loss” is an alias for “objective value”. If <cite>update_objective_interval</cite> is 1 it is the value of the objective at the current iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>return_all</strong> (<em>Boolean</em><em>, </em><em>default is False</em>) – If True, returns all the stored loss functions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Last stored value of the loss function</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.get_last_objective">
<span class="sig-name descname"><span class="pre">get_last_objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.get_last_objective" title="Link to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function. “Loss” is an alias for “objective value”. If <cite>update_objective_interval</cite> is 1 it is the value of the objective at the current iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>return_all</strong> (<em>Boolean</em><em>, </em><em>default is False</em>) – If True, returns all the stored loss functions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Last stored value of the loss function</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.get_output">
<span class="sig-name descname"><span class="pre">get_output</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.get_output" title="Link to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.is_provably_convergent">
<span class="sig-name descname"><span class="pre">is_provably_convergent</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.is_provably_convergent" title="Link to this definition">#</a></dt>
<dd><p>Check if the algorithm is convergent based on the provable convergence criterion.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Outcome of the convergence check</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.iterations">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">iterations</span></span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.iterations" title="Link to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.loss">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">loss</span></span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.loss" title="Link to this definition">#</a></dt>
<dd><p>returns a list of the values of the objective (alias of loss) during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when the <cite>update_objective_interval</cite> &gt; 1</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.max_iteration">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_iteration</span></span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.max_iteration" title="Link to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.max_iteration_stop_criterion">
<span class="sig-name descname"><span class="pre">max_iteration_stop_criterion</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.max_iteration_stop_criterion" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.objective">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">objective</span></span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.objective" title="Link to this definition">#</a></dt>
<dd><p>returns a list of the values of the objective (alias of loss) during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when the <cite>update_objective_interval</cite> &gt; 1</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.objective_to_dict">
<span class="sig-name descname"><span class="pre">objective_to_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.objective_to_dict" title="Link to this definition">#</a></dt>
<dd><p>Internal function to save and print objective functions</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.objective_to_string">
<span class="sig-name descname"><span class="pre">objective_to_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.objective_to_string" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callbacks</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cil.optimisation.utilities.callbacks.Callback" title="cil.optimisation.utilities.callbacks.Callback"><span class="pre">Callback</span></a><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.run" title="Link to this definition">#</a></dt>
<dd><p>run upto <code class="code docutils literal notranslate"><span class="pre">iterations</span></code> with callbacks/logging.</p>
<p>For a demonstration of callbacks see <a class="github reference external" href="https://github.com/TomographicImaging/CIL-Demos/blob/main/misc/callback_demonstration.ipynb">TomographicImaging/CIL-Demos</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> (<em>int</em><em>, </em><em>default is None</em>) – Number of iterations to run. If a positive infinity is passed, the algorithm will run indefinitely until a callback raises <cite>StopIteration</cite>.</p></li>
<li><p><strong>callbacks</strong> (list of callables, default is Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>) – List of callables which are passed the current Algorithm object each iteration. Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>.</p></li>
<li><p><strong>verbose</strong> (<em>0=quiet</em><em>, </em><em>1=info</em><em>, </em><em>2=debug</em>) – Passed to the default callback to determine the verbosity of the printed output.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.set_up">
<span class="sig-name descname"><span class="pre">set_up</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preconditioner</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.set_up" title="Link to this definition">#</a></dt>
<dd><p>Set up of the algorithm</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.should_stop">
<span class="sig-name descname"><span class="pre">should_stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.should_stop" title="Link to this definition">#</a></dt>
<dd><p>default stopping criterion: number of iterations</p>
<p>The user can change this in concrete implementation of iterative algorithms.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.solution">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">solution</span></span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.solution" title="Link to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.update_objective">
<span class="sig-name descname"><span class="pre">update_objective</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.update_objective" title="Link to this definition">#</a></dt>
<dd><p>Updates the objective</p>
<div class="math notranslate nohighlight">
\[f(x) + g(x)\]</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.update_objective_interval">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">update_objective_interval</span></span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.update_objective_interval" title="Link to this definition">#</a></dt>
<dd><p>gets the update_objective_interval</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.verbose_header">
<span class="sig-name descname"><span class="pre">verbose_header</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">__</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.verbose_header" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.FISTA.verbose_output">
<span class="sig-name descname"><span class="pre">verbose_output</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">__</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.FISTA.verbose_output" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

</dd></dl>

</section>
<section id="pdhg">
<h3>PDHG<a class="headerlink" href="#pdhg" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></span><span class="sig-name descname"><span class="pre">PDHG</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma_g</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma_fconj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/PDHG/#PDHG"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG" title="Link to this definition">#</a></dt>
<dd><p>Primal Dual Hybrid Gradient (PDHG) algorithm, see <span id="id9">[<a class="reference internal" href="#id50" title="Antonin Chambolle and Thomas Pock. A first-order primal-dual algorithm for convex problems with applications to imaging. Journal of Mathematical Imaging and Vision, 40(1):120-145, May 2011. URL: https://doi.org/10.1007/s10851-010-0251-1, doi:10.1007/s10851-010-0251-1.">3</a>]</span>, <span id="id10">[<a class="reference internal" href="#id51" title="Ernie Esser, Xiaoqun Zhang, and Tony F. Chan. A general framework for a class of first order primal-dual algorithms for convex optimization in imaging science. SIAM Journal on Imaging Sciences, 3(4):1015-1046, 2010. URL: https://doi.org/10.1137/09076934X, arXiv:https://doi.org/10.1137/09076934X, doi:10.1137/09076934X.">5</a>]</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – A convex function with a “simple” proximal method of its conjugate.</p></li>
<li><p><strong>g</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – A convex function with a “simple” proximal.</p></li>
<li><p><strong>operator</strong> (<a class="reference internal" href="#cil.optimisation.operators.LinearOperator" title="cil.optimisation.operators.LinearOperator"><em>LinearOperator</em></a>) – A Linear Operator.</p></li>
<li><p><strong>sigma</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, or <cite>np.ndarray</cite>, <cite>DataContainer</cite>, <cite>BlockDataContainer</cite>, optional, default is 1.0/norm(K) or 1.0/ (tau*norm(K)**2) if tau is provided) – Step size for the dual problem.</p></li>
<li><p><strong>tau</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, or <cite>np.ndarray</cite>, <cite>DataContainer</cite>, <cite>BlockDataContainer</cite>, optional, default is 1.0/norm(K) or 1.0/ (sigma*norm(K)**2) if sigma is provided) – Step size for the primal problem.</p></li>
<li><p><strong>initial</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>optional</em><em>, </em><em>default is a DataContainer</em><em> of </em><em>zeros</em>) – Initial point for the PDHG algorithm.</p></li>
<li><p><strong>gamma_g</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, optional, default=None) – Strongly convex constant if the function g is strongly convex. Allows primal acceleration of the PDHG algorithm.</p></li>
<li><p><strong>gamma_fconj</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, optional, default=None) – Strongly convex constant if the convex conjugate of f is strongly convex. Allows dual acceleration of the PDHG algorithm.</p></li>
<li><p><strong>**kwargs</strong> – <dl>
<dt>update_objective_interval<span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional, default=1</span></dt><dd><p>Evaluates objectives, e.g., primal/dual/primal-dual gap every <code class="docutils literal notranslate"><span class="pre">update_objective_interval</span></code>.</p>
</dd>
<dt>check_convergence<span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">boolean</span></code>, default=True</span></dt><dd><p>Checks scalar sigma and tau values satisfy convergence criterion and warns if not satisfied. Can be computationally expensive for custom sigma or tau values.</p>
</dd>
<dt>theta<span class="classifier">Float between 0 and 1, default 1.0</span></dt><dd><p>Relaxation parameter for the over-relaxation of the primal variable.</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<p>In our CIL-Demos repository (<a class="github reference external" href="https://github.com/TomographicImaging/CIL-Demos">TomographicImaging/CIL-Demos</a>) you can find examples using the PDHG algorithm for different imaging problems, such as Total Variation denoising, Total Generalised Variation inpainting
and Total Variation Tomography reconstruction. More examples can also be found in <span id="id11">[<a class="reference internal" href="#id53" title="J. S. Jörgensen, E. Ametova, G. Burca, G. Fardell, E. Papoutsellis, E. Pasca, K. Thielemans, M. Turner, R. Warr, W. R. B. Lionheart, and P. J. Withers. Core imaging library - part i: a versatile python framework for tomographic imaging. Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences, 379(2204):20200192, 2021. URL: https://royalsocietypublishing.org/doi/abs/10.1098/rsta.2020.0192, arXiv:https://royalsocietypublishing.org/doi/pdf/10.1098/rsta.2020.0192, doi:10.1098/rsta.2020.0192.">7</a>]</span>, <span id="id12">[<a class="reference internal" href="#id52" title="Evangelos Papoutsellis, Evelina Ametova, Claire Delplancke, Gemma Fardell, Jakob S. Jörgensen, Edoardo Pasca, Martin Turner, Ryan Warr, William R. B. Lionheart, and Philip J. Withers. Core imaging library - part ii: multichannel reconstruction for dynamic and spectral tomography. Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences, 379(2204):20200193, 2021. URL: https://royalsocietypublishing.org/doi/abs/10.1098/rsta.2020.0193, arXiv:https://royalsocietypublishing.org/doi/pdf/10.1098/rsta.2020.0193, doi:10.1098/rsta.2020.0193.">10</a>]</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, the strongly convex constants are passed as parameters of PDHG.
In the future, these parameters will be properties of the corresponding functions.</p>
</div>
<p class="rubric">Notes</p>
<p>A first-order primal-dual algorithm for convex optimization problems with known saddle-point structure with applications in imaging.</p>
<p>The general problem considered in the PDHG algorithm is the generic saddle-point problem</p>
<div class="math notranslate nohighlight">
\[\min_{x\in X}\max_{y\in Y} \langle Kx, y \rangle + g(x) - f^{*}(x)\]</div>
<p>where <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> are convex functions with “simple” proximal operators.</p>
<p><span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> are two two finite-dimensional vector spaces with an inner product and representing the domain of <span class="math notranslate nohighlight">\(g\)</span> and <span class="math notranslate nohighlight">\(f^{*}\)</span>, the convex conjugate of <span class="math notranslate nohighlight">\(f\)</span>, respectively.</p>
<p>The operator <span class="math notranslate nohighlight">\(K\)</span> is a continuous linear operator with operator norm defined as</p>
<div class="math notranslate nohighlight">
\[\|K\| = \max\{ \|Kx\| : x\in X, \|x\|\leq1\}\]</div>
<p>The saddle point problem is decomposed into the primal problem:</p>
<div class="math notranslate nohighlight">
\[\min_{x\in X} f(Kx) + g(x),\]</div>
<p>and its corresponding dual problem</p>
<div class="math notranslate nohighlight">
\[\max_{y\in Y} - g^{*}(-K^{*}y) - f^{*}(y).\]</div>
<p>The PDHG algorithm consists of three steps:</p>
<ul class="simple">
<li><p>gradient ascent step for the dual problem,</p></li>
<li><p>gradient descent step for the primal problem and</p></li>
<li><p>an over-relaxation of the primal variable.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[y^{n+1} = \mathrm{prox}_{\sigma f^{*}}(y^{n} + \sigma K \bar{x}^{n})\]</div>
<div class="math notranslate nohighlight">
\[x^{n+1} = \mathrm{prox}_{\tau g}(x^{n} - \tau K^{*}y^{n+1})\]</div>
<div class="math notranslate nohighlight">
\[\bar{x}^{n+1} = x^{n+1} + \theta (x^{n+1} - x^{n})\]</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Convergence is guaranteed if <span class="math notranslate nohighlight">\(\theta\)</span> = 1.0,  the operator norm <span class="math notranslate nohighlight">\(\|K\|\)</span>, the dual step size <span class="math notranslate nohighlight">\(\sigma\)</span> and the primal step size <span class="math notranslate nohighlight">\(\tau\)</span>, satisfy the following inequality:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\tau \sigma \|K\|^2 &lt; 1\]</div>
<ul>
<li><p>By default, the step sizes <span class="math notranslate nohighlight">\(\sigma\)</span> and <span class="math notranslate nohighlight">\(\tau\)</span> are positive scalars and defined as below:</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">sigma</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code> and <code class="docutils literal notranslate"><span class="pre">tau</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\sigma = \frac{1}{\|K\|},  \tau = \frac{1}{\|K\|}\]</div>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">tau</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\tau = \frac{1}{\sigma\|K\|^{2}}\]</div>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">sigma</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\sigma = \frac{1}{\tau\|K\|^{2}}\]</div>
</li>
<li><p>To monitor the convergence of the algorithm, we compute the primal/dual objectives and the primal-dual gap in <a class="reference internal" href="#cil.optimisation.algorithms.PDHG.update_objective" title="cil.optimisation.algorithms.PDHG.update_objective"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update_objective()</span></code></a>.</p>
<p>The primal objective is</p>
<div class="math notranslate nohighlight">
\[f(Kx) + g(x)\]</div>
<p>and the dual objective is</p>
<div class="math notranslate nohighlight">
\[- g^{*}(-K^{*}y) - f^{*}(y)\]</div>
<p>The primal-dual gap (or duality gap) is</p>
<div class="math notranslate nohighlight">
\[f(Kx) + g(x) + g^{*}(-K^{*}y) + f^{*}(y)\]</div>
<p>and measures how close is the primal-dual pair (x,y) to the primal-dual solution. It is always non-negative and is used to monitor convergence of the PDHG algorithm. For more information, see <a class="reference external" href="https://en.wikipedia.org/wiki/Duality_gap">Duality Gap</a>.</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>The primal objective is printed if <cite>verbose=1</cite>, <code class="docutils literal notranslate"><span class="pre">pdhg.run(verbose=1)</span></code>.</p></li>
<li><p>All the objectives are printed if <cite>verbose=2</cite>, <code class="docutils literal notranslate"><span class="pre">pdhg.run(verbose=2)</span></code>.</p></li>
</ul>
<p>Computing these objectives can be costly, so it is better to compute every some iterations. To do this, use <code class="docutils literal notranslate"><span class="pre">update_objective_interval</span> <span class="pre">=</span> <span class="pre">#number</span></code>.</p>
</div>
<ul>
<li><p>PDHG algorithm can be accelerated if the functions <span class="math notranslate nohighlight">\(f^{*}\)</span> and/or <span class="math notranslate nohighlight">\(g\)</span> are strongly convex. In these cases, the step-sizes <span class="math notranslate nohighlight">\(\sigma\)</span> and <span class="math notranslate nohighlight">\(\tau\)</span> are updated using the <a class="reference internal" href="#cil.optimisation.algorithms.PDHG.update_step_sizes" title="cil.optimisation.algorithms.PDHG.update_step_sizes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update_step_sizes()</span></code></a> method. A function <span class="math notranslate nohighlight">\(f\)</span> is strongly convex with constant <span class="math notranslate nohighlight">\(\gamma&gt;0\)</span> if</p>
<div class="math notranslate nohighlight">
\[f(x) - \frac{\gamma}{2}\|x\|^{2} \quad\mbox{ is convex. }\]</div>
<ul class="simple">
<li><p>For instance the function <span class="math notranslate nohighlight">\(\frac{1}{2}\|x\|^{2}_{2}\)</span> is <span class="math notranslate nohighlight">\(\gamma\)</span> strongly convex for <span class="math notranslate nohighlight">\(\gamma\in(-\infty,1]\)</span>. We say it is 1-strongly convex because it is the largest constant for which <span class="math notranslate nohighlight">\(f - \frac{1}{2}\|\cdot\|^{2}\)</span> is convex.</p></li>
<li><p>The <span class="math notranslate nohighlight">\(\|\cdot\|_{1}\)</span> norm is not strongly convex. For more information, see <a class="reference external" href="https://en.wikipedia.org/wiki/Convex_function#Strongly_convex_functions">Strongly Convex</a>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(g\)</span> is strongly convex with constant <span class="math notranslate nohighlight">\(\gamma\)</span> then the step-sizes <span class="math notranslate nohighlight">\(\sigma\)</span>, <span class="math notranslate nohighlight">\(\tau\)</span> and <span class="math notranslate nohighlight">\(\theta\)</span> are updated as:</p></li>
</ul>
<div class="math notranslate nohighlight">
   \begin{aligned}

       \theta_{n} &amp; = \frac{1}{\sqrt{1 + 2\gamma\tau_{n}}}\\
       \tau_{n+1} &amp; = \theta_{n}\tau_{n}\\
       \sigma_{n+1} &amp; = \frac{\sigma_{n}}{\theta_{n}}

   \end{aligned}</div><ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(f^{*}\)</span> is strongly convex, we swap <span class="math notranslate nohighlight">\(\sigma\)</span> with <span class="math notranslate nohighlight">\(\tau\)</span>.</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The case where both functions are strongly convex is not available at the moment.</p>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.tau">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tau</span></span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.tau" title="Link to this definition">#</a></dt>
<dd><p>The primal step-size</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.sigma">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sigma</span></span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.sigma" title="Link to this definition">#</a></dt>
<dd><p>The dual step-size</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.theta">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">theta</span></span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.theta" title="Link to this definition">#</a></dt>
<dd><p>The relaxation parameter for the over-relaxation of the primal variable</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.gamma_g">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">gamma_g</span></span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.gamma_g" title="Link to this definition">#</a></dt>
<dd><p>The strongly convex constant for the function g</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.gamma_fconj">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">gamma_fconj</span></span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.gamma_fconj" title="Link to this definition">#</a></dt>
<dd><p>The strongly convex constant for the convex conjugate of the function f</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.set_gamma_g">
<span class="sig-name descname"><span class="pre">set_gamma_g</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/PDHG/#PDHG.set_gamma_g"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.set_gamma_g" title="Link to this definition">#</a></dt>
<dd><p>Set the value of the strongly convex constant for function <cite>g</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>value</strong> (<em>a positive number</em><em> or </em><em>None</em>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.set_gamma_fconj">
<span class="sig-name descname"><span class="pre">set_gamma_fconj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/PDHG/#PDHG.set_gamma_fconj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.set_gamma_fconj" title="Link to this definition">#</a></dt>
<dd><p>Set the value of the strongly convex constant for the convex conjugate of function <cite>f</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>value</strong> (<em>a positive number</em><em> or </em><em>None</em>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.set_up">
<span class="sig-name descname"><span class="pre">set_up</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/PDHG/#PDHG.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.set_up" title="Link to this definition">#</a></dt>
<dd><p>Initialisation of the algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – A convex function with a “simple” proximal method of its conjugate.</p></li>
<li><p><strong>g</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – A convex function with a “simple” proximal.</p></li>
<li><p><strong>operator</strong> (<a class="reference internal" href="#cil.optimisation.operators.LinearOperator" title="cil.optimisation.operators.LinearOperator"><em>LinearOperator</em></a>) – A Linear Operator.</p></li>
<li><p><strong>sigma</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, or <cite>np.ndarray</cite>, <cite>DataContainer</cite>, <cite>BlockDataContainer</cite>, optional, default is 1.0/norm(K) or 1.0/ (tau*norm(K)**2) if tau is provided) – Step size for the dual problem.</p></li>
<li><p><strong>tau</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, or <cite>np.ndarray</cite>, <cite>DataContainer</cite>, <cite>BlockDataContainer</cite>, optional, default is 1.0/norm(K) or 1.0/ (sigma*norm(K)**2) if sigma is provided) – Step size for the primal problem.</p></li>
<li><p><strong>initial</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>optional</em><em>, </em><em>default is a DataContainer</em><em> of </em><em>zeros</em>) – Initial point for the PDHG algorithm.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.get_output">
<span class="sig-name descname"><span class="pre">get_output</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/PDHG/#PDHG.get_output"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.get_output" title="Link to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/PDHG/#PDHG.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.update" title="Link to this definition">#</a></dt>
<dd><p>Performs a single iteration of the PDHG algorithm</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.check_convergence">
<span class="sig-name descname"><span class="pre">check_convergence</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/PDHG/#PDHG.check_convergence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.check_convergence" title="Link to this definition">#</a></dt>
<dd><p>Check whether convergence criterion for PDHG is satisfied with scalar values of tau and sigma</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if convergence criterion is satisfied. False if not satisfied or convergence is unknown.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.set_step_sizes">
<span class="sig-name descname"><span class="pre">set_step_sizes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/PDHG/#PDHG.set_step_sizes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.set_step_sizes" title="Link to this definition">#</a></dt>
<dd><p>Sets sigma and tau step-sizes for the PDHG algorithm. The step sizes can be either scalar or array-objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sigma</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, or <cite>np.ndarray</cite>, <cite>DataContainer</cite>, <cite>BlockDataContainer</cite>, optional, default=None) – Step size for the dual problem.</p></li>
<li><p><strong>tau</strong> (positive <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, or <cite>np.ndarray</cite>, <cite>DataContainer</cite>, <cite>BlockDataContainer</cite>, optional, default=None) – Step size for the primal problem.</p></li>
</ul>
</dd>
</dl>
<p>The user can set either, both or none. Values passed by the user will be accepted as long as they are positive numbers,
or correct shape array like objects.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.update_step_sizes">
<span class="sig-name descname"><span class="pre">update_step_sizes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/PDHG/#PDHG.update_step_sizes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.update_step_sizes" title="Link to this definition">#</a></dt>
<dd><p>Updates step sizes in the cases of primal or dual acceleration using the strongly convexity property.
The case where both functions are strongly convex is not available at the moment.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.update_objective">
<span class="sig-name descname"><span class="pre">update_objective</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/PDHG/#PDHG.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.update_objective" title="Link to this definition">#</a></dt>
<dd><p>Evaluates the primal objective, the dual objective and the primal-dual gap.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.objective">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">objective</span></span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.objective" title="Link to this definition">#</a></dt>
<dd><p>returns a list of the values of the objective (alias of loss) during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when the <cite>update_objective_interval</cite> &gt; 1</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.get_last_loss">
<span class="sig-name descname"><span class="pre">get_last_loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.get_last_loss" title="Link to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function. “Loss” is an alias for “objective value”. If <cite>update_objective_interval</cite> is 1 it is the value of the objective at the current iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>return_all</strong> (<em>Boolean</em><em>, </em><em>default is False</em>) – If True, returns all the stored loss functions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Last stored value of the loss function</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.get_last_objective">
<span class="sig-name descname"><span class="pre">get_last_objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.get_last_objective" title="Link to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function. “Loss” is an alias for “objective value”. If <cite>update_objective_interval</cite> is 1 it is the value of the objective at the current iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>return_all</strong> (<em>Boolean</em><em>, </em><em>default is False</em>) – If True, returns all the stored loss functions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Last stored value of the loss function</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.is_provably_convergent">
<span class="sig-name descname"><span class="pre">is_provably_convergent</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.is_provably_convergent" title="Link to this definition">#</a></dt>
<dd><p>Check if the algorithm is convergent based on the provable convergence criterion.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Outcome of the convergence check</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.iterations">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">iterations</span></span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.iterations" title="Link to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.loss">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">loss</span></span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.loss" title="Link to this definition">#</a></dt>
<dd><p>returns a list of the values of the objective (alias of loss) during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when the <cite>update_objective_interval</cite> &gt; 1</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.max_iteration">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_iteration</span></span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.max_iteration" title="Link to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.max_iteration_stop_criterion">
<span class="sig-name descname"><span class="pre">max_iteration_stop_criterion</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.max_iteration_stop_criterion" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.objective_to_dict">
<span class="sig-name descname"><span class="pre">objective_to_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.objective_to_dict" title="Link to this definition">#</a></dt>
<dd><p>Internal function to save and print objective functions</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.objective_to_string">
<span class="sig-name descname"><span class="pre">objective_to_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.objective_to_string" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callbacks</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cil.optimisation.utilities.callbacks.Callback" title="cil.optimisation.utilities.callbacks.Callback"><span class="pre">Callback</span></a><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.run" title="Link to this definition">#</a></dt>
<dd><p>run upto <code class="code docutils literal notranslate"><span class="pre">iterations</span></code> with callbacks/logging.</p>
<p>For a demonstration of callbacks see <a class="github reference external" href="https://github.com/TomographicImaging/CIL-Demos/blob/main/misc/callback_demonstration.ipynb">TomographicImaging/CIL-Demos</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> (<em>int</em><em>, </em><em>default is None</em>) – Number of iterations to run. If a positive infinity is passed, the algorithm will run indefinitely until a callback raises <cite>StopIteration</cite>.</p></li>
<li><p><strong>callbacks</strong> (list of callables, default is Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>) – List of callables which are passed the current Algorithm object each iteration. Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>.</p></li>
<li><p><strong>verbose</strong> (<em>0=quiet</em><em>, </em><em>1=info</em><em>, </em><em>2=debug</em>) – Passed to the default callback to determine the verbosity of the printed output.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.should_stop">
<span class="sig-name descname"><span class="pre">should_stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.should_stop" title="Link to this definition">#</a></dt>
<dd><p>default stopping criterion: number of iterations</p>
<p>The user can change this in concrete implementation of iterative algorithms.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.solution">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">solution</span></span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.solution" title="Link to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.update_objective_interval">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">update_objective_interval</span></span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.update_objective_interval" title="Link to this definition">#</a></dt>
<dd><p>gets the update_objective_interval</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.verbose_header">
<span class="sig-name descname"><span class="pre">verbose_header</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">__</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.verbose_header" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PDHG.verbose_output">
<span class="sig-name descname"><span class="pre">verbose_output</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">__</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PDHG.verbose_output" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

</dd></dl>

</section>
<section id="ladmm">
<h3>LADMM<a class="headerlink" href="#ladmm" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></span><span class="sig-name descname"><span class="pre">LADMM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/ADMM/#LADMM"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.LADMM" title="Link to this definition">#</a></dt>
<dd><p>LADMM is the Linearized Alternating Direction Method of Multipliers (LADMM)</p>
<p>General form of ADMM : min_{x} f(x) + g(y), subject to Ax + By = b</p>
<p>Case: A = Id, B = -K, b = 0   ==&gt; min_x f(Kx) + g(x)</p>
<p>The quadratic term in the augmented Lagrangian is linearized for the x-update.</p>
<p>Main algorithmic difference is that in ADMM we compute two proximal subproblems,
where in the PDHG a proximal and proximal conjugate.</p>
<p>Reference (Section 8) : <a class="reference external" href="https://link.springer.com/content/pdf/10.1007/s10107-018-1321-1.pdf">https://link.springer.com/content/pdf/10.1007/s10107-018-1321-1.pdf</a></p>
<blockquote>
<div><p>x^{k} = prox_{      au f } (x^{k-1} - tau/sigma A^{T}(Ax^{k-1} - z^{k-1} + u^{k-1} )</p>
<p>z^{k} = prox_{sigma g} (Ax^{k} + u^{k-1})</p>
<p>u^{k} = u^{k-1} + Ax^{k} - z^{k}</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.set_up">
<span class="sig-name descname"><span class="pre">set_up</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/ADMM/#LADMM.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.set_up" title="Link to this definition">#</a></dt>
<dd><p>Set up the algorithm</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/ADMM/#LADMM.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.update" title="Link to this definition">#</a></dt>
<dd><p>A single iteration of the algorithm</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.update_objective">
<span class="sig-name descname"><span class="pre">update_objective</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/ADMM/#LADMM.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.update_objective" title="Link to this definition">#</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.get_last_loss">
<span class="sig-name descname"><span class="pre">get_last_loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.get_last_loss" title="Link to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function. “Loss” is an alias for “objective value”. If <cite>update_objective_interval</cite> is 1 it is the value of the objective at the current iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>return_all</strong> (<em>Boolean</em><em>, </em><em>default is False</em>) – If True, returns all the stored loss functions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Last stored value of the loss function</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.get_last_objective">
<span class="sig-name descname"><span class="pre">get_last_objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.get_last_objective" title="Link to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function. “Loss” is an alias for “objective value”. If <cite>update_objective_interval</cite> is 1 it is the value of the objective at the current iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>return_all</strong> (<em>Boolean</em><em>, </em><em>default is False</em>) – If True, returns all the stored loss functions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Last stored value of the loss function</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.get_output">
<span class="sig-name descname"><span class="pre">get_output</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.get_output" title="Link to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The current solution</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.is_provably_convergent">
<span class="sig-name descname"><span class="pre">is_provably_convergent</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.is_provably_convergent" title="Link to this definition">#</a></dt>
<dd><p>Check if the algorithm is convergent based on the provable convergence criterion.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Outcome of the convergence check</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.iterations">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">iterations</span></span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.iterations" title="Link to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.loss">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">loss</span></span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.loss" title="Link to this definition">#</a></dt>
<dd><p>returns a list of the values of the objective (alias of loss) during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when the <cite>update_objective_interval</cite> &gt; 1</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.max_iteration">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_iteration</span></span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.max_iteration" title="Link to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.max_iteration_stop_criterion">
<span class="sig-name descname"><span class="pre">max_iteration_stop_criterion</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.max_iteration_stop_criterion" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.objective">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">objective</span></span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.objective" title="Link to this definition">#</a></dt>
<dd><p>returns a list of the values of the objective (alias of loss) during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when the <cite>update_objective_interval</cite> &gt; 1</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.objective_to_dict">
<span class="sig-name descname"><span class="pre">objective_to_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.objective_to_dict" title="Link to this definition">#</a></dt>
<dd><p>Internal function to save and print objective functions</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.objective_to_string">
<span class="sig-name descname"><span class="pre">objective_to_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.objective_to_string" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callbacks</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cil.optimisation.utilities.callbacks.Callback" title="cil.optimisation.utilities.callbacks.Callback"><span class="pre">Callback</span></a><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.run" title="Link to this definition">#</a></dt>
<dd><p>run upto <code class="code docutils literal notranslate"><span class="pre">iterations</span></code> with callbacks/logging.</p>
<p>For a demonstration of callbacks see <a class="github reference external" href="https://github.com/TomographicImaging/CIL-Demos/blob/main/misc/callback_demonstration.ipynb">TomographicImaging/CIL-Demos</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> (<em>int</em><em>, </em><em>default is None</em>) – Number of iterations to run. If a positive infinity is passed, the algorithm will run indefinitely until a callback raises <cite>StopIteration</cite>.</p></li>
<li><p><strong>callbacks</strong> (list of callables, default is Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>) – List of callables which are passed the current Algorithm object each iteration. Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>.</p></li>
<li><p><strong>verbose</strong> (<em>0=quiet</em><em>, </em><em>1=info</em><em>, </em><em>2=debug</em>) – Passed to the default callback to determine the verbosity of the printed output.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.should_stop">
<span class="sig-name descname"><span class="pre">should_stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.should_stop" title="Link to this definition">#</a></dt>
<dd><p>default stopping criterion: number of iterations</p>
<p>The user can change this in concrete implementation of iterative algorithms.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.solution">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">solution</span></span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.solution" title="Link to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.update_objective_interval">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">update_objective_interval</span></span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.update_objective_interval" title="Link to this definition">#</a></dt>
<dd><p>gets the update_objective_interval</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.verbose_header">
<span class="sig-name descname"><span class="pre">verbose_header</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">__</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.verbose_header" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.LADMM.verbose_output">
<span class="sig-name descname"><span class="pre">verbose_output</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">__</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.LADMM.verbose_output" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

</dd></dl>

</section>
<section id="pd3o">
<h3>PD3O<a class="headerlink" href="#pd3o" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PD3O">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></span><span class="sig-name descname"><span class="pre">PD3O</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/PD3O/#PD3O"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PD3O" title="Link to this definition">#</a></dt>
<dd><p>Primal Dual Three Operator Splitting (PD3O) algorithm, see “A New Primal–Dual Algorithm for Minimizing the Sum
of Three Functions with a Linear Operator”.  This is a primal dual algorithm for minimising <span class="math notranslate nohighlight">\(f(x)+g(x)+h(Ax)\)</span> where all functions are proper, lower semi-continuous and convex,
<span class="math notranslate nohighlight">\(f\)</span> should be differentiable with a Lipschitz continuous gradient and <span class="math notranslate nohighlight">\(A\)</span> is a bounded linear operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – A smooth function with Lipschitz continuous gradient.</p></li>
<li><p><strong>g</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – A convex function with a computationally computable proximal.</p></li>
<li><p><strong>h</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – A composite convex function.</p></li>
<li><p><strong>operator</strong> (<a class="reference internal" href="#cil.optimisation.operators.Operator" title="cil.optimisation.operators.Operator"><em>Operator</em></a>) – Bounded linear operator</p></li>
<li><p><strong>delta</strong> (Float, optional, default is  <cite>1./(gamma*operator.norm()**2)</cite>) – The dual step-size</p></li>
<li><p><strong>gamma</strong> (Float, optional, default is <cite>2.0/f.L</cite>) – The primal step size</p></li>
<li><p><strong>initial</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>optional default is a container</em><em> of </em><em>zeros</em><em>, </em><em>in the domain</em><em> of </em><em>the operator</em>) – Initial point for the  algorithm.</p></li>
</ul>
</dd>
</dl>
<section id="reference">
<h4>Reference<a class="headerlink" href="#reference" title="Link to this heading">#</a></h4>
<p>Yan, M. A New Primal–Dual Algorithm for Minimizing the Sum of Three Functions with a Linear Operator. J Sci Comput 76, 1698–1717 (2018). <a class="reference external" href="https://doi.org/10.1007/s10915-018-0680-3">https://doi.org/10.1007/s10915-018-0680-3</a></p>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PD3O.set_up">
<span class="sig-name descname"><span class="pre">set_up</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/PD3O/#PD3O.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PD3O.set_up" title="Link to this definition">#</a></dt>
<dd><p>Set up the algorithm</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PD3O.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/PD3O/#PD3O.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PD3O.update" title="Link to this definition">#</a></dt>
<dd><p>Performs a single iteration of the PD3O algorithm</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PD3O.update_objective">
<span class="sig-name descname"><span class="pre">update_objective</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/PD3O/#PD3O.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.PD3O.update_objective" title="Link to this definition">#</a></dt>
<dd><p>Evaluates the primal objective</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PD3O.get_last_loss">
<span class="sig-name descname"><span class="pre">get_last_loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PD3O.get_last_loss" title="Link to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function. “Loss” is an alias for “objective value”. If <cite>update_objective_interval</cite> is 1 it is the value of the objective at the current iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>return_all</strong> (<em>Boolean</em><em>, </em><em>default is False</em>) – If True, returns all the stored loss functions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Last stored value of the loss function</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PD3O.get_last_objective">
<span class="sig-name descname"><span class="pre">get_last_objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PD3O.get_last_objective" title="Link to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function. “Loss” is an alias for “objective value”. If <cite>update_objective_interval</cite> is 1 it is the value of the objective at the current iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>return_all</strong> (<em>Boolean</em><em>, </em><em>default is False</em>) – If True, returns all the stored loss functions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Last stored value of the loss function</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PD3O.get_output">
<span class="sig-name descname"><span class="pre">get_output</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PD3O.get_output" title="Link to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The current solution</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PD3O.is_provably_convergent">
<span class="sig-name descname"><span class="pre">is_provably_convergent</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PD3O.is_provably_convergent" title="Link to this definition">#</a></dt>
<dd><p>Check if the algorithm is convergent based on the provable convergence criterion.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Outcome of the convergence check</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PD3O.iterations">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">iterations</span></span><a class="headerlink" href="#cil.optimisation.algorithms.PD3O.iterations" title="Link to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PD3O.loss">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">loss</span></span><a class="headerlink" href="#cil.optimisation.algorithms.PD3O.loss" title="Link to this definition">#</a></dt>
<dd><p>returns a list of the values of the objective (alias of loss) during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when the <cite>update_objective_interval</cite> &gt; 1</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PD3O.max_iteration">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_iteration</span></span><a class="headerlink" href="#cil.optimisation.algorithms.PD3O.max_iteration" title="Link to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PD3O.max_iteration_stop_criterion">
<span class="sig-name descname"><span class="pre">max_iteration_stop_criterion</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PD3O.max_iteration_stop_criterion" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PD3O.objective">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">objective</span></span><a class="headerlink" href="#cil.optimisation.algorithms.PD3O.objective" title="Link to this definition">#</a></dt>
<dd><p>returns a list of the values of the objective (alias of loss) during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when the <cite>update_objective_interval</cite> &gt; 1</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PD3O.objective_to_dict">
<span class="sig-name descname"><span class="pre">objective_to_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PD3O.objective_to_dict" title="Link to this definition">#</a></dt>
<dd><p>Internal function to save and print objective functions</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PD3O.objective_to_string">
<span class="sig-name descname"><span class="pre">objective_to_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PD3O.objective_to_string" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PD3O.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callbacks</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cil.optimisation.utilities.callbacks.Callback" title="cil.optimisation.utilities.callbacks.Callback"><span class="pre">Callback</span></a><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PD3O.run" title="Link to this definition">#</a></dt>
<dd><p>run upto <code class="code docutils literal notranslate"><span class="pre">iterations</span></code> with callbacks/logging.</p>
<p>For a demonstration of callbacks see <a class="github reference external" href="https://github.com/TomographicImaging/CIL-Demos/blob/main/misc/callback_demonstration.ipynb">TomographicImaging/CIL-Demos</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> (<em>int</em><em>, </em><em>default is None</em>) – Number of iterations to run. If a positive infinity is passed, the algorithm will run indefinitely until a callback raises <cite>StopIteration</cite>.</p></li>
<li><p><strong>callbacks</strong> (list of callables, default is Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>) – List of callables which are passed the current Algorithm object each iteration. Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>.</p></li>
<li><p><strong>verbose</strong> (<em>0=quiet</em><em>, </em><em>1=info</em><em>, </em><em>2=debug</em>) – Passed to the default callback to determine the verbosity of the printed output.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PD3O.should_stop">
<span class="sig-name descname"><span class="pre">should_stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PD3O.should_stop" title="Link to this definition">#</a></dt>
<dd><p>default stopping criterion: number of iterations</p>
<p>The user can change this in concrete implementation of iterative algorithms.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PD3O.solution">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">solution</span></span><a class="headerlink" href="#cil.optimisation.algorithms.PD3O.solution" title="Link to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PD3O.update_objective_interval">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">update_objective_interval</span></span><a class="headerlink" href="#cil.optimisation.algorithms.PD3O.update_objective_interval" title="Link to this definition">#</a></dt>
<dd><p>gets the update_objective_interval</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PD3O.verbose_header">
<span class="sig-name descname"><span class="pre">verbose_header</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">__</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PD3O.verbose_header" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.PD3O.verbose_output">
<span class="sig-name descname"><span class="pre">verbose_output</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">__</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.PD3O.verbose_output" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

</section>
</dd></dl>

</section>
</section>
<section id="algorithms-stochastic">
<h2>Algorithms (Stochastic)<a class="headerlink" href="#algorithms-stochastic" title="Link to this heading">#</a></h2>
<p>Consider optimisation problems that take the form of a separable sum:</p>
<div class="math notranslate nohighlight">
\[\min_{x} f(x)+g(x) = \min_{x} \sum_{i=0}^{n-1} f_{i}(x) + g(x) = \min_{x} (f_{0}(x) + f_{1}(x) + ... + f_{n-1}(x))+g(x)\]</div>
<p>where <span class="math notranslate nohighlight">\(n\)</span> is the number of functions.  Where there is a large number of <span class="math notranslate nohighlight">\(f_i\)</span> or their gradients are expensive to calculate, stochastic optimisation methods could prove more efficient.
There is a growing range of Stochastic optimisation algorithms available with potential benefits of faster convergence in number of iterations or in computational cost.
This is an area of continued development for CIL and, depending on  the properties of the <span class="math notranslate nohighlight">\(f_i\)</span> and the regulariser <span class="math notranslate nohighlight">\(g\)</span>, there is a range of different options for the user.</p>
<section id="spdhg">
<h3>SPDHG<a class="headerlink" href="#spdhg" title="Link to this heading">#</a></h3>
<p>Stochastic Primal Dual Hybrid Gradient (SPDHG) is a stochastic version of PDHG and deals with optimisation problems of the form:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\min_{x} f(Kx) + g(x) = \min_{x} \sum f_i(K_i x) + g(x)\]</div>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(f_i\)</span> and the regulariser <span class="math notranslate nohighlight">\(g\)</span> need only be proper, convex and lower semi-continuous ( i.e. do not need to be differentiable).
Each iteration considers just one index of the sum, potentially reducing computational cost. For more examples see our [user notebooks]( <a class="github reference external" href="https://github.com/vais-ral/CIL-Demos/blob/master/Tomography/Simulated/Single%20Channel/PDHG_vs_SPDHG.py">vais-ral/CIL-Demos</a>).</p>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.algorithms.</span></span><span class="sig-name descname"><span class="pre">SPDHG</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampler</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/SPDHG/#SPDHG"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG" title="Link to this definition">#</a></dt>
<dd><p>Stochastic Primal Dual Hybrid Gradient (SPDHG) solves separable optimisation problems of the type:
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>\<span class="n">min_</span><span class="p">{</span><span class="n">x</span><span class="p">}</span> <span class="n">f</span><span class="p">(</span><span class="n">Kx</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> \<span class="n">min_</span><span class="p">{</span><span class="n">x</span><span class="p">}</span> \<span class="nb">sum</span> <span class="n">f_i</span><span class="p">(</span><span class="n">K_i</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>where <span class="math notranslate nohighlight">\(f_i\)</span> and the regulariser <span class="math notranslate nohighlight">\(g\)</span> need to be proper, convex and lower semi-continuous.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<a class="reference internal" href="#cil.optimisation.functions.BlockFunction" title="cil.optimisation.functions.BlockFunction"><em>BlockFunction</em></a>) – Each must be a convex function with a “simple” proximal method of its conjugate</p></li>
<li><p><strong>g</strong> (<a class="reference internal" href="#cil.optimisation.functions.Function" title="cil.optimisation.functions.Function"><em>Function</em></a>) – A convex function with a “simple” proximal</p></li>
<li><p><strong>operator</strong> (<a class="reference internal" href="#cil.optimisation.operators.BlockOperator" title="cil.optimisation.operators.BlockOperator"><em>BlockOperator</em></a>) – BlockOperator must contain Linear Operators</p></li>
<li><p><strong>tau</strong> (<em>positive float</em><em>, </em><em>optional</em>) – Step size parameter for the primal problem. If <cite>None</cite> will be computed by algorithm, see note for details.</p></li>
<li><p><strong>sigma</strong> (<em>list</em><em> of </em><em>positive float</em><em>, </em><em>optional</em>) – List of Step size parameters for dual problem.  If <cite>None</cite> will be computed by algorithm, see note for details.</p></li>
<li><p><strong>initial</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>optional</em>) – Initial point for the SPDHG algorithm. The default value is a zero DataContainer in the range of the <cite>operator</cite>.</p></li>
<li><p><strong>gamma</strong> (<em>float</em><em>, </em><em>optional</em>) – Parameter controlling the trade-off between the primal and dual step sizes</p></li>
<li><p><strong>sampler</strong> (<cite>cil.optimisation.utilities.Sampler</cite>, optional) – A <cite>Sampler</cite> controllingthe selection of the next index for the SPDHG update. If <cite>None</cite>, a sampler will be created for uniform random sampling with replacement. See notes.</p></li>
<li><p><strong>prob_weights</strong> (<em>list</em><em> of </em><em>floats</em><em>, </em><em>optional</em><em>,</em>) – Consider that the sampler is called a large number of times this argument holds the expected number of times each index would be called,  normalised to 1. Note that this should not be passed if the provided sampler has it as an attribute: if the sampler has a <cite>prob_weight</cite> attribute it will take precedence on this parameter. Should be a list of floats of length <cite>num_indices</cite> that sum to 1. If no sampler with <cite>prob_weights</cite> is passed, it defaults to <cite>[1/len(operator)]*len(operator)</cite>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <cite>sampler</cite> can be an instance of the <cite>cil.optimisation.utilities.Sampler</cite> class or a custom class with the <cite>__next__(self)</cite> method implemented, which outputs an integer index from {1, …, len(operator)}.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>“Random sampling with replacement” will select the next index with equal probability from  <cite>1 - len(operator)</cite>.</p>
</div>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">dataexample</span><span class="o">.</span><span class="n">SIMULATED_PARALLEL_BEAM_DATA</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="s1">&#39;astra&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_slice</span><span class="p">(</span><span class="n">vertical</span><span class="o">=</span><span class="s1">&#39;centre&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ig</span> <span class="o">=</span> <span class="n">ag</span><span class="o">.</span><span class="n">get_ImageGeometry</span><span class="p">()</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data_partitioned</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">num_batches</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;staggered&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_partitioned</span> <span class="o">=</span> <span class="n">ProjectionOperator</span><span class="p">(</span><span class="n">ig</span><span class="p">,</span> <span class="n">data_partitioned</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">BlockFunction</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">L2NormSquared</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="n">data_partitioned</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="go">                        for i in range(10)])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.025</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">TotalVariation</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spdhg</span> <span class="o">=</span> <span class="n">SPDHG</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="n">F</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="n">G</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="n">A_partitioned</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="n">Sampler</span><span class="o">.</span><span class="n">sequential</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)),</span>
<span class="go">                  initial=A.domain_geometry().allocate(1), update_objective_interval=10)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spdhg</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Example</p>
<p>Further examples of usage see the [CIL demos.](<a class="github reference external" href="https://github.com/vais-ral/CIL-Demos/blob/master/Tomography/Simulated/Single%20Channel/PDHG_vs_SPDHG.py">vais-ral/CIL-Demos</a>)</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When setting <cite>sigma</cite> and <cite>tau</cite>, there are 4 possible cases considered by setup function. In all cases the probabilities <span class="math notranslate nohighlight">\(p_i\)</span> are set by a default or user defined sampler:</p>
<ul class="simple">
<li><p>Case 1: If neither <cite>sigma</cite> or <cite>tau</cite> are provided then <cite>sigma</cite> is set using the formula:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\sigma_i= \frac{0.99}{\|K_i\|^2}\]</div>
<p>and <cite>tau</cite> is set as per case 2</p>
<ul class="simple">
<li><p>Case 2: If <cite>sigma</cite> is provided but not <cite>tau</cite> then <cite>tau</cite> is calculated using the formula</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\tau = 0.99\min_i( \frac{p_i}{ (\sigma_i  \|K_i\|^2) })\]</div>
<ul class="simple">
<li><p>Case 3: If <cite>tau</cite> is provided but not <cite>sigma</cite> then <cite>sigma</cite> is calculated using the formula</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\sigma_i= \frac{0.99 p_i}{\tau\|K_i\|^2}\]</div>
<ul class="simple">
<li><p>Case 4: Both <cite>sigma</cite> and <cite>tau</cite> are provided.</p></li>
</ul>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Convergence is guaranteed provided that [2, eq. (12)]:</p>
<div class="math notranslate nohighlight">
\[\|\sigma[i]^{1/2}  K[i]  \tau^{1/2} \|^2  &lt; p_i \text{ for all } i\]</div>
</div>
<p class="rubric">References</p>
<p>[1]”Stochastic primal-dual hybrid gradient algorithm with arbitrary
sampling and imaging applications”,
Chambolle, Antonin, Matthias J. Ehrhardt, Peter Richtárik, and Carola-Bibiane Schonlieb,
SIAM Journal on Optimization 28, no. 4 (2018): 2783-2808.   <a class="reference external" href="https://doi.org/10.1137/17M1134834">https://doi.org/10.1137/17M1134834</a></p>
<p>[2]”Faster PET reconstruction with non-smooth priors by randomization and preconditioning”,
Matthias J Ehrhardt, Pawel Markiewicz and Carola-Bibiane Schönlieb,
Physics in Medicine &amp; Biology, Volume 64, Number 22, 2019. <a class="reference external" href="https://doi.org/10.1088/1361-6560/ab3d07">https://doi.org/10.1088/1361-6560/ab3d07</a></p>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.set_up">
<span class="sig-name descname"><span class="pre">set_up</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampler</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">deprecated_kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/SPDHG/#SPDHG.set_up"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.set_up" title="Link to this definition">#</a></dt>
<dd><p>set-up of the algorithm</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.set_step_sizes_from_ratio">
<span class="sig-name descname"><span class="pre">set_step_sizes_from_ratio</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.99</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/SPDHG/#SPDHG.set_step_sizes_from_ratio"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.set_step_sizes_from_ratio" title="Link to this definition">#</a></dt>
<dd><p>Sets gamma, the step-size ratio for the SPDHG algorithm. Currently gamma takes a scalar value.</p>
<p>The step sizes <cite>sigma</cite> and <cite>tau</cite> are set using the equations:</p>
<div class="math notranslate nohighlight">
\[\sigma_i= \frac{\gamma\rho }{\|K_i\|^2}\]</div>
<div class="math notranslate nohighlight">
\[\tau = \rho\min_i([ \frac{p_i }{\sigma_i  \|K_i\|^2})\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gamma</strong> (<em>Positive float</em>) – parameter controlling the trade-off between the primal and dual step sizes</p></li>
<li><p><strong>rho</strong> (<em>Positive float</em>) – parameter controlling the size of the product :math: sigmatau :math:</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.set_step_sizes">
<span class="sig-name descname"><span class="pre">set_step_sizes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/SPDHG/#SPDHG.set_step_sizes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.set_step_sizes" title="Link to this definition">#</a></dt>
<dd><p>Sets sigma and tau step-sizes for the SPDHG algorithm after the initial set-up. The step sizes can be either scalar or array-objects.</p>
<p>When setting <cite>sigma</cite> and <cite>tau</cite>, there are 4 possible cases considered by setup function:</p>
<ul class="simple">
<li><p>Case 1: If neither <cite>sigma</cite> or <cite>tau</cite> are provided then <cite>sigma</cite> is set using the formula:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\sigma_i= \frac{0.99}{\|K_i\|^2}\]</div>
<p>and <cite>tau</cite> is set as per case 2</p>
<ul class="simple">
<li><p>Case 2: If <cite>sigma</cite> is provided but not <cite>tau</cite> then <cite>tau</cite> is calculated using the formula</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\tau = 0.99\min_i( \frac{p_i}{ (\sigma_i  \|K_i\|^2) })\]</div>
<ul class="simple">
<li><p>Case 3: If <cite>tau</cite> is provided but not <cite>sigma</cite> then <cite>sigma</cite> is calculated using the formula</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\sigma_i= \frac{0.99 p_i}{\tau\|K_i\|^2}\]</div>
<ul class="simple">
<li><p>Case 4: Both <cite>sigma</cite> and <cite>tau</cite> are provided.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sigma</strong> (<em>list</em><em> of </em><em>positive float</em><em>, </em><em>optional</em><em>, </em><em>default= see docstring</em>) – List of Step size parameters for dual problem</p></li>
<li><p><strong>tau</strong> (<em>positive float</em><em>, </em><em>optional</em><em>, </em><em>default= see docstring</em>) – Step size parameter for primal problem</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.check_convergence">
<span class="sig-name descname"><span class="pre">check_convergence</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/SPDHG/#SPDHG.check_convergence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.check_convergence" title="Link to this definition">#</a></dt>
<dd><p>Checks whether convergence criterion for SPDHG is satisfied with the current scalar values of tau and sigma</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if convergence criterion is satisfied. False if not satisfied or convergence is unknown.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Boolean</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Convergence criterion currently can only be checked for scalar values of tau.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This checks the convergence criterion. Numerical errors may mean some sigma and tau values that satisfy the convergence criterion may not converge.
Alternatively, step sizes outside the convergence criterion may still allow (fast) convergence.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/SPDHG/#SPDHG.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.update" title="Link to this definition">#</a></dt>
<dd><p>Runs one iteration of SPDHG</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.update_objective">
<span class="sig-name descname"><span class="pre">update_objective</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/algorithms/SPDHG/#SPDHG.update_objective"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.update_objective" title="Link to this definition">#</a></dt>
<dd><p>calculates the objective with the current solution</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.objective">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">objective</span></span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.objective" title="Link to this definition">#</a></dt>
<dd><p>The saved primal objectives.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The saved primal objectives from <cite>update_objective</cite>. The number of saved values depends on the <cite>update_objective_interval</cite> kwarg.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.dual_objective">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dual_objective</span></span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.dual_objective" title="Link to this definition">#</a></dt>
<dd><p>The saved dual objectives.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The saved dual objectives from <cite>update_objective</cite>. The number of saved values depends on the <cite>update_objective_interval</cite> kwarg.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.primal_dual_gap">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">primal_dual_gap</span></span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.primal_dual_gap" title="Link to this definition">#</a></dt>
<dd><p>The saved primal-dual gap.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The saved primal dual gap from <cite>update_objective</cite>. The number of saved values depends on the <cite>update_objective_interval</cite> kwarg.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.get_last_loss">
<span class="sig-name descname"><span class="pre">get_last_loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.get_last_loss" title="Link to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function. “Loss” is an alias for “objective value”. If <cite>update_objective_interval</cite> is 1 it is the value of the objective at the current iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>return_all</strong> (<em>Boolean</em><em>, </em><em>default is False</em>) – If True, returns all the stored loss functions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Last stored value of the loss function</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.get_last_objective">
<span class="sig-name descname"><span class="pre">get_last_objective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.get_last_objective" title="Link to this definition">#</a></dt>
<dd><p>Returns the last stored value of the loss function. “Loss” is an alias for “objective value”. If <cite>update_objective_interval</cite> is 1 it is the value of the objective at the current iteration. If update_objective_interval &gt; 1 it is the last stored value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>return_all</strong> (<em>Boolean</em><em>, </em><em>default is False</em>) – If True, returns all the stored loss functions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Last stored value of the loss function</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.get_output">
<span class="sig-name descname"><span class="pre">get_output</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.get_output" title="Link to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The current solution</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.is_provably_convergent">
<span class="sig-name descname"><span class="pre">is_provably_convergent</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.is_provably_convergent" title="Link to this definition">#</a></dt>
<dd><p>Check if the algorithm is convergent based on the provable convergence criterion.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Outcome of the convergence check</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.iterations">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">iterations</span></span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.iterations" title="Link to this definition">#</a></dt>
<dd><p>returns the iterations at which the objective has been evaluated</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.loss">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">loss</span></span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.loss" title="Link to this definition">#</a></dt>
<dd><p>returns a list of the values of the objective (alias of loss) during the iteration</p>
<p>The length of this list may be shorter than the number of iterations run when the <cite>update_objective_interval</cite> &gt; 1</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.max_iteration">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_iteration</span></span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.max_iteration" title="Link to this definition">#</a></dt>
<dd><p>gets the maximum number of iterations</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.max_iteration_stop_criterion">
<span class="sig-name descname"><span class="pre">max_iteration_stop_criterion</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.max_iteration_stop_criterion" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.objective_to_dict">
<span class="sig-name descname"><span class="pre">objective_to_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.objective_to_dict" title="Link to this definition">#</a></dt>
<dd><p>Internal function to save and print objective functions</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.objective_to_string">
<span class="sig-name descname"><span class="pre">objective_to_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.objective_to_string" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callbacks</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#cil.optimisation.utilities.callbacks.Callback" title="cil.optimisation.utilities.callbacks.Callback"><span class="pre">Callback</span></a><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.run" title="Link to this definition">#</a></dt>
<dd><p>run upto <code class="code docutils literal notranslate"><span class="pre">iterations</span></code> with callbacks/logging.</p>
<p>For a demonstration of callbacks see <a class="github reference external" href="https://github.com/TomographicImaging/CIL-Demos/blob/main/misc/callback_demonstration.ipynb">TomographicImaging/CIL-Demos</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iterations</strong> (<em>int</em><em>, </em><em>default is None</em>) – Number of iterations to run. If a positive infinity is passed, the algorithm will run indefinitely until a callback raises <cite>StopIteration</cite>.</p></li>
<li><p><strong>callbacks</strong> (list of callables, default is Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>) – List of callables which are passed the current Algorithm object each iteration. Defaults to <code class="code docutils literal notranslate"><span class="pre">[ProgressCallback(verbose)]</span></code>.</p></li>
<li><p><strong>verbose</strong> (<em>0=quiet</em><em>, </em><em>1=info</em><em>, </em><em>2=debug</em>) – Passed to the default callback to determine the verbosity of the printed output.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.should_stop">
<span class="sig-name descname"><span class="pre">should_stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.should_stop" title="Link to this definition">#</a></dt>
<dd><p>default stopping criterion: number of iterations</p>
<p>The user can change this in concrete implementation of iterative algorithms.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.solution">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">solution</span></span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.solution" title="Link to this definition">#</a></dt>
<dd><p>Returns the current solution.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.update_objective_interval">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">update_objective_interval</span></span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.update_objective_interval" title="Link to this definition">#</a></dt>
<dd><p>gets the update_objective_interval</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.verbose_header">
<span class="sig-name descname"><span class="pre">verbose_header</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">__</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.verbose_header" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.algorithms.SPDHG.verbose_output">
<span class="sig-name descname"><span class="pre">verbose_output</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">__</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.algorithms.SPDHG.verbose_output" title="Link to this definition">#</a></dt>
<dd><p>Do not use: this is being deprecated</p>
</dd></dl>

</dd></dl>

</section>
<section id="approximate-gradient-methods">
<h3>Approximate gradient methods<a class="headerlink" href="#approximate-gradient-methods" title="Link to this heading">#</a></h3>
<p>Alternatively, consider that, in addition to the functions <span class="math notranslate nohighlight">\(f_i\)</span> and the regulariser <span class="math notranslate nohighlight">\(g\)</span> being proper, convex and lower semi-continuous, the <span class="math notranslate nohighlight">\(f_i\)</span> are differentiable. In this case we consider stochastic methods that replace a gradient calculation in a deterministic algorithm with a, potentially cheaper to calculate, approximate gradient.
For example, when <span class="math notranslate nohighlight">\(g(x)=0\)</span>, the standard Gradient Descent algorithm utilises iterations of the form</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[x_{k+1}=x_k-\alpha \nabla f(x_k) =x_k-\alpha \sum_{i=0}^{n-1}\nabla f_i(x_k).\]</div>
</div></blockquote>
<p><span class="math notranslate nohighlight">\(\nabla f(x_k)=\sum_{i=0}^{n-1}\nabla f_i(x_k)\)</span> with <span class="math notranslate nohighlight">\(n \nabla f_i(x_k)\)</span>, for an index <span class="math notranslate nohighlight">\(i\)</span> which changes each iteration, leads to the well known stochastic gradient descent algorithm.</p>
<p>Replacing, <span class="math notranslate nohighlight">\(\nabla f(x_k)=\sum_{i=0}^{n-1}\nabla f_i(x_k)\)</span> with <span class="math notranslate nohighlight">\(n \nabla f_i(x_k)\)</span>, for an index <span class="math notranslate nohighlight">\(i\)</span> which changes each iteration, leads to the well known stochastic gradient descent algorithm.</p>
<p>In addition, if <span class="math notranslate nohighlight">\(g(x)\neq 0\)</span> and has a calculable proximal ( need not be differentiable) one can consider ISTA iterations:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[x_{k+1}=prox_{\alpha g}(x_k-\alpha \nabla f(x_k) )=prox_{\alpha g}(x_k-\alpha \sum_{i=0}^{n-1}\nabla f_i(x_k))\]</div>
</div></blockquote>
<p>and again replacing <span class="math notranslate nohighlight">\(\nabla f(x_k)=\sum_{i=0}^{n-1}\nabla f_i(x_k)\)</span> with an approximate gradient.</p>
<p>In a similar way, plugging approximate gradient calculations into deterministic algorithms can lead to a range of stochastic algorithms. In the following table, the left hand column has the approximate gradient function subclass, <span class="xref std std-ref">Approximate Gradient base class</span> the header row has one of CIL’s deterministic optimisation algorithm and the body of the table has the resulting stochastic algorithm.</p>
<p>*In development</p>
<p>The stochastic gradient functions can be found listed under functions in the documentation.</p>
</section>
<section id="stochastic-gradient-descent-example">
<h3>Stochastic Gradient Descent Example<a class="headerlink" href="#stochastic-gradient-descent-example" title="Link to this heading">#</a></h3>
<p>The below is an example of Stochastic Gradient Descent built of the SGFunction and Gradient Descent algorithm:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">cil.optimisation.utilities</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sampler</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cil.optimisation.algorithms</span><span class="w"> </span><span class="kn">import</span> <span class="n">GD</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cil.optimisation.functions</span><span class="w"> </span><span class="kn">import</span> <span class="n">LeastSquares</span><span class="p">,</span> <span class="n">SGFunction</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cil.utilities</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataexample</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cil.plugins.astra.operators</span><span class="w"> </span><span class="kn">import</span> <span class="n">ProjectionOperator</span>

<span class="c1"># get the data</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">dataexample</span><span class="o">.</span><span class="n">SIMULATED_PARALLEL_BEAM_DATA</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="n">data</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="s1">&#39;astra&#39;</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_slice</span><span class="p">(</span><span class="n">vertical</span><span class="o">=</span><span class="s1">&#39;centre&#39;</span><span class="p">)</span>

<span class="c1"># create the geometries</span>
<span class="n">ag</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">geometry</span>
<span class="n">ig</span> <span class="o">=</span> <span class="n">ag</span><span class="o">.</span><span class="n">get_ImageGeometry</span><span class="p">()</span>

<span class="c1"># partition the data and build the projectors</span>
<span class="n">n_subsets</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">partitioned_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">n_subsets</span><span class="p">,</span> <span class="s1">&#39;sequential&#39;</span><span class="p">)</span>
<span class="n">A_partitioned</span> <span class="o">=</span> <span class="n">ProjectionOperator</span><span class="p">(</span><span class="n">ig</span><span class="p">,</span> <span class="n">partitioned_data</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="s2">&quot;cpu&quot;</span><span class="p">)</span>

<span class="c1"># create the list of functions for the stochastic sum</span>
<span class="n">list_of_functions</span> <span class="o">=</span> <span class="p">[</span><span class="n">LeastSquares</span><span class="p">(</span><span class="n">Ai</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">bi</span><span class="p">)</span> <span class="k">for</span> <span class="n">Ai</span><span class="p">,</span><span class="n">bi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">A_partitioned</span><span class="p">,</span> <span class="n">partitioned_data</span><span class="p">)]</span>

<span class="c1">#define the sampler and the stochastic gradient function</span>
<span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">staggered</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">list_of_functions</span><span class="p">),</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">SGFunction</span><span class="p">(</span><span class="n">list_of_functions</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="n">sampler</span><span class="p">)</span>

<span class="c1">#set up and run the gradient descent algorithm</span>
<span class="n">alg</span> <span class="o">=</span> <span class="n">GD</span><span class="p">(</span><span class="n">initial</span><span class="o">=</span><span class="n">ig</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">objective_function</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="n">f</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
<span class="n">alg</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mi">300</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="note">
<h3>Note<a class="headerlink" href="#note" title="Link to this heading">#</a></h3>
<blockquote>
<div><p>All the approximate gradients written in CIL are of a similar order of magnitude to the full gradient calculation. For example, in the <code class="code docutils literal notranslate"><span class="pre">SGFunction</span></code> we approximate the full gradient by <span class="math notranslate nohighlight">\(n\nabla f_i\)</span> for an index <span class="math notranslate nohighlight">\(i\)</span> given by the sampler.
The multiplication by <span class="math notranslate nohighlight">\(n\)</span> is a choice to more easily allow comparisons between stochastic and non-stochastic methods and between stochastic methods with varying numbers of subsets.
The multiplication ensures that the (SAGA, SGD, and SVRG  and LSVRG) approximate gradients are an unbiased estimator of the full gradient ie <span class="math notranslate nohighlight">\(\mathbb{E}\left[\tilde\nabla f(x)\right] =\nabla f(x)\)</span>.</p>
<blockquote>
<div><p>This has an implication when choosing step sizes. For example, a suitable step size for GD with a SGFunction could be
<span class="math notranslate nohighlight">\(\propto 1/(L_{max}*n)\)</span>, where <span class="math notranslate nohighlight">\(L_{max}\)</span> is the largest Lipschitz constant of the list of functions in the SGFunction and the additional factor of  <span class="math notranslate nohighlight">\(n\)</span> reflects this multiplication by  <span class="math notranslate nohighlight">\(n\)</span> in the approximate gradient.</p>
</div></blockquote>
</div></blockquote>
</section>
<section id="memory-requirements">
<h3>Memory requirements<a class="headerlink" href="#memory-requirements" title="Link to this heading">#</a></h3>
<p>Note that the approximate gradient methods have different memory requirements:
+ The <cite>SGFunction</cite> has the same requirements as a <cite>SumFunction</cite>, so no increased memory usage
+ <cite>SAGFunction</cite> and <cite>SAGAFunction</cite> both store <cite>n+3</cite> times the image size in memory to store the last calculated gradient for each function in the sum and for intermediary calculations.
+ <cite>SVRGFunction</cite> and <cite>LSVRGFunction</cite> with the default <cite>store_gradients = False</cite> store 4 times the image size in memory, including the “snapshot” point and gradient. If <cite>store_gradients = True</cite>, some computational effort is saved, at the expensive of stored memory <cite>n+4</cite> times the image size.</p>
</section>
</section>
<section id="operators">
<h2>Operators<a class="headerlink" href="#operators" title="Link to this heading">#</a></h2>
<p>The two most important methods are <code class="code docutils literal notranslate"><span class="pre">direct</span></code> and <code class="code docutils literal notranslate"><span class="pre">adjoint</span></code>
methods that describe the result of applying the operator, and its
adjoint respectively, onto a compatible <code class="code docutils literal notranslate"><span class="pre">DataContainer</span></code> input.
The output is another <code class="code docutils literal notranslate"><span class="pre">DataContainer</span></code> object or subclass
hereof. An important special case is to represent the tomographic
forward and backprojection operations.</p>
<section id="operator-base-classes">
<h3>Operator base classes<a class="headerlink" href="#operator-base-classes" title="Link to this heading">#</a></h3>
<p>All operators extend the <code class="code docutils literal notranslate"><span class="pre">Operator</span></code> class. A special class is the <code class="code docutils literal notranslate"><span class="pre">LinearOperator</span></code>
which represents an operator for which the <code class="code docutils literal notranslate"><span class="pre">adjoint</span></code> operation is defined.
A <code class="code docutils literal notranslate"><span class="pre">ScaledOperator</span></code> represents the multiplication of any operator with a scalar.</p>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.Operator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">Operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#Operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator" title="Link to this definition">#</a></dt>
<dd><p>Operator that maps from a space X -&gt; Y</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> (<a class="reference internal" href="../framework/#cil.framework.ImageGeometry" title="cil.framework.ImageGeometry"><em>ImageGeometry</em></a><em> or </em><a class="reference internal" href="../framework/#cil.framework.AcquisitionGeometry" title="cil.framework.AcquisitionGeometry"><em>AcquisitionGeometry</em></a>) – domain of the operator</p></li>
<li><p><strong>range_geometry</strong> (<a class="reference internal" href="../framework/#cil.framework.ImageGeometry" title="cil.framework.ImageGeometry"><em>ImageGeometry</em></a><em> or </em><a class="reference internal" href="../framework/#cil.framework.AcquisitionGeometry" title="cil.framework.AcquisitionGeometry"><em>AcquisitionGeometry</em></a><em>, </em><em>optional</em><em>, </em><em>default None</em>) – range of the operator</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.Operator.is_linear">
<span class="sig-name descname"><span class="pre">is_linear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#Operator.is_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.is_linear" title="Link to this definition">#</a></dt>
<dd><p>Returns if the operator is linear
:rtype: <cite>Bool</cite></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.Operator.is_orthogonal">
<span class="sig-name descname"><span class="pre">is_orthogonal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#Operator.is_orthogonal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.is_orthogonal" title="Link to this definition">#</a></dt>
<dd><p>Returns if the operator is orthogonal
:rtype: <cite>Bool</cite></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.Operator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#Operator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.direct" title="Link to this definition">#</a></dt>
<dd><p>Calls the operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>) – Element in the domain of the Operator</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>default None</em>) – If out is not None the output of the Operator will be filled in out, otherwise a new object is instantiated and returned.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a> or BlockDataContainer containing the result.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.Operator.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#Operator.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.norm" title="Link to this definition">#</a></dt>
<dd><p>Returns the norm of the Operator. On first call the norm will be calculated using the operator’s calculate_norm
method. Subsequent calls will return the cached norm.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>norm</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>positive:<cite>float</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.Operator.set_norm">
<span class="sig-name descname"><span class="pre">set_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#Operator.set_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.set_norm" title="Link to this definition">#</a></dt>
<dd><p>Sets the norm of the operator to a custom value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>norm</strong> (<em>float</em><em>, </em><em>optional</em>) – Positive real valued number or <cite>None</cite></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The passed values are cached so that when self.norm() is called, the saved value will be returned and not calculated via the power method.
If <cite>None</cite> is passed, the cache is cleared prompting the function to call the power method to calculate the norm the next time self.norm() is called.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.Operator.calculate_norm">
<span class="sig-name descname"><span class="pre">calculate_norm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#Operator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.calculate_norm" title="Link to this definition">#</a></dt>
<dd><p>Returns the norm of the Operator. Note that this gives a NotImplementedError if the SumOperator is not linear.
:returns: <strong>Scalar</strong>
:rtype: the norm of the Operator</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.Operator.range_geometry">
<span class="sig-name descname"><span class="pre">range_geometry</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#Operator.range_geometry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.range_geometry" title="Link to this definition">#</a></dt>
<dd><p>Returns the range of the Operator: Y space</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.Operator.domain_geometry">
<span class="sig-name descname"><span class="pre">domain_geometry</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#Operator.domain_geometry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.Operator.domain_geometry" title="Link to this definition">#</a></dt>
<dd><p>Returns the domain of the Operator: X space</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.LinearOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">LinearOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#LinearOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator" title="Link to this definition">#</a></dt>
<dd><p>Linear operator that maps from a space X &lt;-&gt; Y</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> (<a class="reference internal" href="../framework/#cil.framework.ImageGeometry" title="cil.framework.ImageGeometry"><em>ImageGeometry</em></a><em> or </em><a class="reference internal" href="../framework/#cil.framework.AcquisitionGeometry" title="cil.framework.AcquisitionGeometry"><em>AcquisitionGeometry</em></a>) – domain of the operator</p></li>
<li><p><strong>range_geometry</strong> (<a class="reference internal" href="../framework/#cil.framework.ImageGeometry" title="cil.framework.ImageGeometry"><em>ImageGeometry</em></a><em> or </em><a class="reference internal" href="../framework/#cil.framework.AcquisitionGeometry" title="cil.framework.AcquisitionGeometry"><em>AcquisitionGeometry</em></a><em>, </em><em>optional</em><em>, </em><em>default None</em>) – range of the operator</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.LinearOperator.is_linear">
<span class="sig-name descname"><span class="pre">is_linear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#LinearOperator.is_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator.is_linear" title="Link to this definition">#</a></dt>
<dd><p>Returns if the operator is linear</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.LinearOperator.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#LinearOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator.adjoint" title="Link to this definition">#</a></dt>
<dd><p>Returns the adjoint/inverse operation evaluated at the point <span class="math notranslate nohighlight">\(x\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>) – Element in the domain of the Operator</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>default None</em>) – If out is not None the output of the Operator will be filled in out, otherwise a new object is instantiated and returned.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a> or BlockDataContainer containing the result.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only available to linear operators</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.LinearOperator.PowerMethod">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">PowerMethod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iteration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#LinearOperator.PowerMethod"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator.PowerMethod" title="Link to this definition">#</a></dt>
<dd><p>Power method or Power iteration algorithm</p>
<p>The Power method computes the largest (dominant) eigenvalue of a matrix in magnitude, e.g.,
absolute value in the real case and modulus in the complex case.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> (<a class="reference internal" href="#cil.optimisation.operators.LinearOperator" title="cil.optimisation.operators.LinearOperator"><em>LinearOperator</em></a>)</p></li>
<li><p><strong>max_iteration</strong> (positive:<cite>int</cite>, default=10) – Number of iterations for the Power method algorithm.</p></li>
<li><p><strong>initial</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>default = None</em>) – Starting point for the Power method.</p></li>
<li><p><strong>tolerance</strong> (positive:<cite>float</cite>, default = 1e-5) – Stopping criterion for the Power method. Check if two consecutive eigenvalue evaluations are below the tolerance.</p></li>
<li><p><strong>return_all</strong> (<cite>boolean</cite>, default = False) – Toggles the verbosity of the return</p></li>
<li><p><strong>method</strong> (<cite>string</cite> one of <cite>“auto”</cite>, <cite>“composed_with_adjoint”</cite> and <cite>“direct_only”</cite>, default = <cite>“auto”</cite>) – The default <cite>auto</cite> lets the code choose the method, this can be specified with <cite>“direct_only”</cite> or <cite>“composed_with_adjoint”</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>dominant eigenvalue</strong> (positive:<cite>float</cite>)</p></li>
<li><p><strong>number of iterations</strong> (positive:<cite>int</cite>) – Number of iterations run. Only returned if return_all is True.</p></li>
<li><p><strong>eigenvector</strong> (<em>DataContainer</em>) – Corresponding eigenvector of the dominant eigenvalue. Only returned if return_all is True.</p></li>
<li><p><strong>list of eigenvalues</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code>) – List of eigenvalues. Only returned if return_all is True.</p></li>
<li><p><strong>convergence</strong> (<cite>boolean</cite>) – Check on wether the difference between the last two iterations is less than tolerance. Only returned if return_all is True.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The power method contains two different algorithms chosen by the <cite>method</cite> flag.</p>
<p>In the case <cite>method=”direct_only”</cite>, for operator, <span class="math notranslate nohighlight">\(A\)</span>, the power method computes the iterations
<span class="math notranslate nohighlight">\(x_{k+1} = A (x_k/\|x_{k}\|)\)</span> initialised with a random vector <span class="math notranslate nohighlight">\(x_0\)</span> and returning the largest (dominant) eigenvalue in magnitude given by <span class="math notranslate nohighlight">\(\|x_k\|\)</span>.</p>
<p>In the case <cite>method=”composed_with_adjoint”</cite>, the algorithm computes the largest (dominant) eigenvalue of <span class="math notranslate nohighlight">\(A^{T}A\)</span>
returning the square root of this value, i.e. the iterations:
<span class="math notranslate nohighlight">\(x_{k+1} = A^TA (x_k/\|x_{k}\|)\)</span> and returning  <span class="math notranslate nohighlight">\(\sqrt{\|x_k\|}\)</span>.</p>
<p>The default flag is <cite>method=”auto”</cite>, the algorithm checks to see if the <cite>operator.domain_geometry() == operator.range_geometry()</cite> and if so
uses the method “direct_only” and if not the method “composed_with_adjoint”.</p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Mop</span> <span class="o">=</span> <span class="n">MatrixOperator</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Mop_norm</span> <span class="o">=</span> <span class="n">Mop</span><span class="o">.</span><span class="n">PowerMethod</span><span class="p">(</span><span class="n">Mop</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Mop_norm</span>
<span class="go">2.0000654846240296</span>
</pre></div>
</div>
<p><cite>PowerMethod</cite> is called when we compute the norm of a matrix or a <cite>LinearOperator</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Mop_norm</span> <span class="o">=</span> <span class="n">Mop</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
<span class="go">2.0005647295658866</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.LinearOperator.calculate_norm">
<span class="sig-name descname"><span class="pre">calculate_norm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#LinearOperator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator.calculate_norm" title="Link to this definition">#</a></dt>
<dd><p>Returns the norm of the LinearOperator calculated by the PowerMethod with default values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.LinearOperator.dot_test">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dot_test</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#LinearOperator.dot_test"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.LinearOperator.dot_test" title="Link to this definition">#</a></dt>
<dd><p>Does a dot linearity test on the operator
Evaluates if the following equivalence holds
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ax</span>\<span class="n">times</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> \<span class="n">times</span> <span class="n">A</span><span class="o">^</span><span class="n">Tx</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> – operator to test the dot_test</p></li>
<li><p><strong>range_init</strong> – optional initialisation container in the operator range</p></li>
<li><p><strong>domain_init</strong> – optional initialisation container in the operator domain</p></li>
<li><p><strong>seed</strong> (<em>int</em><em>, </em><em>default = 1</em>) – Seed random generator</p></li>
<li><p><strong>tolerance</strong> (<em>float</em><em>, </em><em>default 1e-6</em>) – Check if the following expression is below the tolerance</p></li>
<li><p><strong>math::</strong> (<em>..</em>) – <a href="#id60"><span class="problematic" id="id61">|Ax\times y - y \times A^Tx|</span></a>/(|A||x||y| + 1e-12) &lt; tolerance</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>boolean, True if the test is passed.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.ScaledOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">ScaledOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalar</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#ScaledOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ScaledOperator" title="Link to this definition">#</a></dt>
<dd><p>A class to represent the scalar multiplication of an Operator with a scalar.
It holds an operator and a scalar. Basically it returns the multiplication
of the result of direct and adjoint of the operator with the scalar.
For the rest it behaves like the operator it holds.</p>
<p>Parameters</p>
<blockquote>
<div><p>a scalar multiplier</p>
</div></blockquote>
<p class="rubric">Example</p>
<p>The scaled operator behaves like the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sop</span> <span class="o">=</span> <span class="n">ScaledOperator</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">scalar</span><span class="p">)</span>
<span class="n">sop</span><span class="o">.</span><span class="n">direct</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">scalar</span> <span class="o">*</span> <span class="n">operator</span><span class="o">.</span><span class="n">direct</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">sop</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">scalar</span> <span class="o">*</span> <span class="n">operator</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">sop</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
<span class="n">sop</span><span class="o">.</span><span class="n">range_geometry</span><span class="p">()</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">range_geometry</span><span class="p">()</span>
<span class="n">sop</span><span class="o">.</span><span class="n">domain_geometry</span><span class="p">()</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">domain_geometry</span><span class="p">()</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.ScaledOperator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#ScaledOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ScaledOperator.direct" title="Link to this definition">#</a></dt>
<dd><p>direct method</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.ScaledOperator.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#ScaledOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ScaledOperator.adjoint" title="Link to this definition">#</a></dt>
<dd><p>adjoint method</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.ScaledOperator.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#ScaledOperator.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ScaledOperator.norm" title="Link to this definition">#</a></dt>
<dd><p>norm of the operator</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.ScaledOperator.is_linear">
<span class="sig-name descname"><span class="pre">is_linear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#ScaledOperator.is_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ScaledOperator.is_linear" title="Link to this definition">#</a></dt>
<dd><p>returns a <cite>boolean</cite> indicating whether the operator is linear</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.CompositionOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">CompositionOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">operators</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#CompositionOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.CompositionOperator" title="Link to this definition">#</a></dt>
<dd><p>Composes one or more operators.
For example, <cite>CompositionOperator(left, right).direct(x)</cite> is equivalent to <cite>left.direct(right.direct(x))</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>args</strong> (<cite>Operator</cite> s) – Operators to be composed. As in mathematical notation, the operators will be applied right to left</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.CompositionOperator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#CompositionOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.CompositionOperator.direct" title="Link to this definition">#</a></dt>
<dd><p>Calls the composition operator at the point <span class="math notranslate nohighlight">\(x\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>) – Element in the domain of the CompositionOperator</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>default None</em>) – If out is not None the output of the CompositionOperator will be filled in out, otherwise a new object is instantiated and returned.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a> or BlockDataContainer containing the result.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.CompositionOperator.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#CompositionOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.CompositionOperator.adjoint" title="Link to this definition">#</a></dt>
<dd><p>Calls the adjoint of the composition operator at the point <span class="math notranslate nohighlight">\(x\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>) – Element in the range of the CompositionOperator</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>default None</em>) – If out is not None the output of the adjoint of the CompositionOperator will be filled in out, otherwise a new object is instantiated and returned.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a> or BlockDataContainer containing the result.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.CompositionOperator.is_linear">
<span class="sig-name descname"><span class="pre">is_linear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#CompositionOperator.is_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.CompositionOperator.is_linear" title="Link to this definition">#</a></dt>
<dd><p>Returns if the operator is linear
:rtype: <cite>Bool</cite></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.DiagonalOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">DiagonalOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diagonal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/DiagonalOperator/#DiagonalOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.DiagonalOperator" title="Link to this definition">#</a></dt>
<dd><p>Performs an element-wise multiplication, i.e., <a class="reference external" href="https://en.wikipedia.org/wiki/Hadamard_product_(matrices)#:~:text=In%20mathematics%2C%20the%20Hadamard%20product,elements%20i%2C%20j%20of%20the">Hadamard Product</a>
of a <code class="xref py py-class docutils literal notranslate"><span class="pre">DataContainer</span></code> <cite>x</cite> and <code class="xref py py-class docutils literal notranslate"><span class="pre">DataContainer</span></code> <cite>diagonal</cite>, <cite>d</cite> .</p>
<div class="math notranslate nohighlight">
\[(D\circ x) = \sum_{i,j}^{M,N} D_{i,j} x_{i, j}\]</div>
<p>In matrix-vector interpretation, if <cite>D</cite> is a <span class="math notranslate nohighlight">\(M\times N\)</span> dense matrix and is flattened, we have a <span class="math notranslate nohighlight">\(M*N \times M*N\)</span> vector.
A sparse diagonal matrix, i.e., <code class="xref py py-class docutils literal notranslate"><span class="pre">DigaonalOperator</span></code> can be created if we add the vector above to the main diagonal.
If the <code class="xref py py-class docutils literal notranslate"><span class="pre">DataContainer</span></code> <cite>x</cite> is also flattened, we have a <span class="math notranslate nohighlight">\(M*N\)</span> vector.
Now, matrix-vector multiplcation is allowed and results to a <span class="math notranslate nohighlight">\((M*N,1)\)</span> vector. After reshaping we recover a <span class="math notranslate nohighlight">\(M\times N\)</span> <code class="xref py py-class docutils literal notranslate"><span class="pre">DataContainer</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>diagonal</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – DataContainer with the same dimensions as the data to be operated on.</p></li>
<li><p><strong>domain_geometry</strong> (<a class="reference internal" href="../framework/#cil.framework.ImageGeometry" title="cil.framework.ImageGeometry"><em>ImageGeometry</em></a>) – Specifies the geometry of the operator domain. If ‘None’ will use the diagonal geometry directly. default=None .</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.DiagonalOperator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/DiagonalOperator/#DiagonalOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.DiagonalOperator.direct" title="Link to this definition">#</a></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(D\circ x\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.DiagonalOperator.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/DiagonalOperator/#DiagonalOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.DiagonalOperator.adjoint" title="Link to this definition">#</a></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(D^*\circ x\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.DiagonalOperator.calculate_norm">
<span class="sig-name descname"><span class="pre">calculate_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/DiagonalOperator/#DiagonalOperator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.DiagonalOperator.calculate_norm" title="Link to this definition">#</a></dt>
<dd><p>Returns the operator norm of DiagonalOperator which is the <span class="math notranslate nohighlight">\(\infty\)</span> norm of <cite>diagonal</cite></p>
<div class="math notranslate nohighlight">
\[\|D\|_{\infty} = \max_{i}\{|D_{i}|\}\]</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.ChannelwiseOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">ChannelwiseOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'prepend'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/ChannelwiseOperator/#ChannelwiseOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ChannelwiseOperator" title="Link to this definition">#</a></dt>
<dd><p>ChannelwiseOperator:  takes in a single-channel operator op and the
number of channels to be used, and creates a new multi-channel
ChannelwiseOperator, which will apply the operator op independently on
each channel for the number of channels specified.</p>
<p>ChannelwiseOperator supports simple operators as input but not
BlockOperators. Typically if such behaviour is desired, it can be achieved
by creating instead a BlockOperator of ChannelwiseOperators.</p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">param op<span class="colon">:</span></dt>
<dd class="field-odd"><p>Single-channel operator</p>
</dd>
<dt class="field-even">param channels<span class="colon">:</span></dt>
<dd class="field-even"><p>Number of channels</p>
</dd>
<dt class="field-odd">param dimension<span class="colon">:</span></dt>
<dd class="field-odd"><p>‘prepend’ (default) or ‘append’ channel dimension onto existing dimensions</p>
</dd>
</dl>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.ChannelwiseOperator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/ChannelwiseOperator/#ChannelwiseOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ChannelwiseOperator.direct" title="Link to this definition">#</a></dt>
<dd><p>Returns D(x)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.ChannelwiseOperator.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/ChannelwiseOperator/#ChannelwiseOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ChannelwiseOperator.adjoint" title="Link to this definition">#</a></dt>
<dd><p>Returns D^{*}(y)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.ChannelwiseOperator.calculate_norm">
<span class="sig-name descname"><span class="pre">calculate_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/ChannelwiseOperator/#ChannelwiseOperator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ChannelwiseOperator.calculate_norm" title="Link to this definition">#</a></dt>
<dd><p>Evaluates operator norm of DiagonalOperator</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.SumOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">SumOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#SumOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SumOperator" title="Link to this definition">#</a></dt>
<dd><p>Sums two operators.
For example, <cite>SumOperator(left, right).direct(x)</cite> is equivalent to  <cite>left.direct(x)+right.direct(x)</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator1</strong> (<cite>Operator</cite>) – The first <cite>Operator</cite> in the sum</p></li>
<li><p><strong>operator2</strong> (<cite>Operator</cite>) – The second <cite>Operator</cite> in the sum</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Both operators must have the same domain and range.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.SumOperator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#SumOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SumOperator.direct" title="Link to this definition">#</a></dt>
<dd><p>Calls the sum operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>) – Element in the domain of the SumOperator</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>default None</em>) – If out is not None the output of the SumOperator will be filled in out, otherwise a new object is instantiated and returned.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a> or BlockDataContainer containing the result.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.SumOperator.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#SumOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SumOperator.adjoint" title="Link to this definition">#</a></dt>
<dd><p>Calls the adjoint of the sum operator, evaluated at the point <span class="math notranslate nohighlight">\(x\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>) – Element in the range of the SumOperator</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>default None</em>) – If out is not None the output of the adjoint of the SumOperator will be filled in out, otherwise a new object is instantiated and returned.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a> or BlockDataContainer containing the result.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.SumOperator.is_linear">
<span class="sig-name descname"><span class="pre">is_linear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/Operator/#SumOperator.is_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SumOperator.is_linear" title="Link to this definition">#</a></dt>
<dd><p>Returns if the operator is linear
:rtype: <cite>Bool</cite></p>
</dd></dl>

</dd></dl>

</section>
<section id="trivial-operators">
<h3>Trivial operators<a class="headerlink" href="#trivial-operators" title="Link to this heading">#</a></h3>
<p>Trivial operators are the following.</p>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.IdentityOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">IdentityOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/IdentityOperator/#IdentityOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.IdentityOperator" title="Link to this definition">#</a></dt>
<dd><p><cite>IdentityOperator</cite>: <span class="math notranslate nohighlight">\(\mathrm{Id}: X \rightarrow Y\)</span>,  <span class="math notranslate nohighlight">\(\mathrm{Id}(x) = x\)</span></p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(X\)</span> : domain
<span class="math notranslate nohighlight">\(Y\)</span> : range ( Default: <span class="math notranslate nohighlight">\(Y = X\)</span> )</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> (<em>CIL Geometry</em>) – domain of the operator</p></li>
<li><p><strong>range_geometry</strong> (<em>CIL Geometry</em><em>, </em><em>optional</em>) – range of the operator, default: same as domain</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.IdentityOperator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/IdentityOperator/#IdentityOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.IdentityOperator.direct" title="Link to this definition">#</a></dt>
<dd><p>Returns the input data <span class="math notranslate nohighlight">\(x\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>) – Input data</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>optional</em>) – If out is not None the output of the Operator will be filled in out, otherwise a new object is instantiated and returned. The default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(\mathrm{Id}(x) = x\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a> or <a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer">BlockDataContainer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.IdentityOperator.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/IdentityOperator/#IdentityOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.IdentityOperator.adjoint" title="Link to this definition">#</a></dt>
<dd><p>Returns the input data, <span class="math notranslate nohighlight">\(x\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>) – Input data</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>optional</em>) – If out is not None the output of the Operator will be filled in out, otherwise a new object is instantiated and returned. The default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(\mathrm{Id}^*(x)=x\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a> or <a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer">BlockDataContainer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.IdentityOperator.calculate_norm">
<span class="sig-name descname"><span class="pre">calculate_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/IdentityOperator/#IdentityOperator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.IdentityOperator.calculate_norm" title="Link to this definition">#</a></dt>
<dd><p>Evaluates operator norm of  <cite>IdentityOperator</cite></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.IdentityOperator.is_orthogonal">
<span class="sig-name descname"><span class="pre">is_orthogonal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/IdentityOperator/#IdentityOperator.is_orthogonal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.IdentityOperator.is_orthogonal" title="Link to this definition">#</a></dt>
<dd><p>Returns if the operator is orthogonal</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Always returns <cite>True</cite> for <cite>IdentityOperator</cite></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>Bool</cite></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.ZeroOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">ZeroOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/ZeroOperator/#ZeroOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ZeroOperator" title="Link to this definition">#</a></dt>
<dd><p><cite>ZeroOperator</cite>:  <span class="math notranslate nohighlight">\(\mathrm{O}: X \rightarrow Y\)</span>,  maps any element of <span class="math notranslate nohighlight">\(x\in X\)</span> into the zero element in the space <span class="math notranslate nohighlight">\(Y\)</span>, so  <span class="math notranslate nohighlight">\(\mathrm{O}(x) = \mathrm{O}_{Y}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> (<em>CIL Geometry</em>) – domain of the operator</p></li>
<li><p><strong>range_geometry</strong> (<em>CIL Geometry</em><em>, </em><em>optional</em>) – range of the operator, default: same as domain</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<div class="math notranslate nohighlight">
\[O^{*}: Y^{*} -&gt; X^{*} \text{(Adjoint)} \quad \text{such that} \quad
\langle O(x), y \rangle = \langle x, O^{*}(y) \rangle\]</div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.ZeroOperator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/ZeroOperator/#ZeroOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ZeroOperator.direct" title="Link to this definition">#</a></dt>
<dd><p>Returns an element of the range space filled with zeros</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>) – Input data</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>optional</em>) – If out is not None the output of the Operator will be filled in out, otherwise a new object is instantiated and returned. The default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(\mathrm{O}(x)\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.ZeroOperator.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/ZeroOperator/#ZeroOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ZeroOperator.adjoint" title="Link to this definition">#</a></dt>
<dd><p>Returns an element of the domain space filled with zeros</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>) – Input data</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>optional</em>) – If out is not None the output of the Operator will be filled in out, otherwise a new object is instantiated and returned. The default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(\mathrm{O}^{*}(y)\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.ZeroOperator.calculate_norm">
<span class="sig-name descname"><span class="pre">calculate_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/ZeroOperator/#ZeroOperator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ZeroOperator.calculate_norm" title="Link to this definition">#</a></dt>
<dd><p>Evaluates operator norm of <cite>ZeroOperator</cite></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.MatrixOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">MatrixOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/MatrixOperator/#MatrixOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.MatrixOperator" title="Link to this definition">#</a></dt>
<dd><p>Matrix wrapped in a CIL Operator to be used in optimisation algorithms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>A</strong> (<em>a numpy matrix</em>) – The matrix to be wrapped into a CIL Operator</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.MatrixOperator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/MatrixOperator/#MatrixOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.MatrixOperator.direct" title="Link to this definition">#</a></dt>
<dd><p>Returns the matrix vector product <span class="math notranslate nohighlight">\(Ax\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – Input data</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>optional</em>) – If out is not None the output of the Operator will be filled in out, otherwise a new object is instantiated and returned. The default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(Ax\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.MatrixOperator.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/MatrixOperator/#MatrixOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.MatrixOperator.adjoint" title="Link to this definition">#</a></dt>
<dd><p>Returns the matrix vector product <span class="math notranslate nohighlight">\(A^{T}x\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – Input data</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>optional</em>) – If out is not None the output of the Operator will be filled in out, otherwise a new object is instantiated and returned. The default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(A^{T}x\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.MatrixOperator.size">
<span class="sig-name descname"><span class="pre">size</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/MatrixOperator/#MatrixOperator.size"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.MatrixOperator.size" title="Link to this definition">#</a></dt>
<dd><p>Returns the shape of the matrix</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.MaskOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">MaskOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/MaskOperator/#MaskOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.MaskOperator" title="Link to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mask</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – Boolean array with the same dimensions as the data to be operated on.</p></li>
<li><p><strong>domain_geometry</strong> (<a class="reference internal" href="../framework/#cil.framework.ImageGeometry" title="cil.framework.ImageGeometry"><em>ImageGeometry</em></a>) – Specifies the geometry of the operator domain. If ‘None’ will use the mask geometry size and spacing as float32. default = None .</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.ProjectionMap">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">ProjectionMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/ProjectionMap/#ProjectionMap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ProjectionMap" title="Link to this definition">#</a></dt>
<dd><p>Projection Map or Canonical Projection (<a class="reference external" href="https://en.wikipedia.org/wiki/Projection_(mathematics">https://en.wikipedia.org/wiki/Projection_(mathematics</a>))</p>
<p>Takes an element <span class="math notranslate nohighlight">\(x = (x_{0},\dots,x_{i},\dots,x_{n})\)</span> from a Cartesian product space <span class="math notranslate nohighlight">\(X_{1}\times\cdots\times X_{n}\rightarrow X_{i}\)</span>
and projects it to element <span class="math notranslate nohighlight">\(x_{i}\)</span> specified by the index <span class="math notranslate nohighlight">\(i\)</span>.</p>
<div class="math notranslate nohighlight">
\[\pi_{i}: X_{1}\times\cdots\times X_{n}\rightarrow X_{i}\]</div>
<div class="math notranslate nohighlight">
\[\pi_{i}(x_{0},\dots,x_{i},\dots,x_{n}) = x_{i}\]</div>
<p>The adjoint operation, is defined as</p>
<div class="math notranslate nohighlight">
\[\pi_{i}^{*}(x_{i}) = (0, \cdots, x_{i}, \cdots, 0)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> (<cite>BlockGeometry</cite>) – The domain of the <cite>ProjectionMap</cite>. A <cite>BlockGeometry</cite> is expected.</p></li>
<li><p><strong>index</strong> (<em>int</em>) – Index to project to the corresponding <cite>ImageGeometry</cite></p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.ProjectionMap.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/ProjectionMap/#ProjectionMap.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ProjectionMap.direct" title="Link to this definition">#</a></dt>
<dd><p>Returns the ith (<cite>index</cite>) element of the Block data container, <span class="math notranslate nohighlight">\(x\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<cite>BlockDataContainer</cite>)</p></li>
<li><p><strong>out</strong> (<cite>DataContainer</cite>, default <cite>None</cite>) – If <cite>out</cite> is not <cite>None</cite> the output of the <cite>ProjectionMap</cite> will be filled in <cite>out</cite>, otherwise a new object is instantiated and returned.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>DataContainer</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.ProjectionMap.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/ProjectionMap/#ProjectionMap.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.ProjectionMap.adjoint" title="Link to this definition">#</a></dt>
<dd><p>Returns a <cite>BlockDataContainer</cite> of zeros with the ith (<cite>index</cite>) filled with the <cite>DataContainer</cite>, <span class="math notranslate nohighlight">\(x\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<cite>DataContainer</cite>)</p></li>
<li><p><strong>out</strong> (<cite>BlockDataContainer</cite>, default <cite>None</cite>) – If <cite>out</cite> is not <cite>None</cite> the output of the adjoint of the <cite>ProjectionMap</cite> will be filled in <cite>out</cite>, otherwise a new object is instantiated and returned.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>BlockDataContainer</cite></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="gradientoperator">
<h3>GradientOperator<a class="headerlink" href="#gradientoperator" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.GradientOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">GradientOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'forward'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bnd_cond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Neumann'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/GradientOperator/#GradientOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.GradientOperator" title="Link to this definition">#</a></dt>
<dd><p>Gradient Operator: Computes first-order forward/backward differences on
2D, 3D, 4D ImageData under Neumann/Periodic boundary conditions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> (<a class="reference internal" href="../framework/#cil.framework.ImageGeometry" title="cil.framework.ImageGeometry"><em>ImageGeometry</em></a>) – Set up the domain of the function</p></li>
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>default 'forward'</em>) – Accepts: ‘forward’, ‘backward’, ‘centered’, note C++ optimised routine only works with ‘forward’</p></li>
<li><p><strong>bnd_cond</strong> (<em>str</em><em>, </em><em>default</em><em>,  </em><em>'Neumann'</em>) – Set the boundary conditions to use ‘Neumann’ or ‘Periodic’</p></li>
<li><p><strong>**kwargs</strong> – <dl class="simple">
<dt>correlation: str, default ‘Space’</dt><dd><p>’Space’ will compute the gradient on only the spatial dimensions, ‘SpaceChannels’ will include the channel dimension direction</p>
</dd>
<dt>backend: str, default ‘c’</dt><dd><p>’c’ or ‘numpy’, defaults to ‘c’ if correlation is ‘SpaceChannels’ or channels = 1</p>
</dd>
<dt>num_threads: int</dt><dd><p>If backend is ‘c’ specify the number of threads to use. Default is number of cpus/2</p>
</dd>
<dt>split: boolean</dt><dd><p>If ‘True’, and backend ‘c’ will return a BlockDataContainer with grouped spatial domains. i.e. [Channel, [Z, Y, X]], otherwise [Channel, Z, Y, X]</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a BlockDataContainer containing images of the derivatives order given by <cite>dimension_labels</cite>
i.e. [‘horizontal_y’,’horizontal_x’] will return [d(‘horizontal_y’), d(‘horizontal_x’)]</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer">BlockDataContainer</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>2D example</p>
<div class="math notranslate nohighlight">
 \begin{eqnarray}
 \nabla : X \rightarrow Y\\
 u \in X, \nabla(u) &amp;=&amp; [\partial_{y} u, \partial_{x} u]\\
 u^{*} \in Y, \nabla^{*}(u^{*}) &amp;=&amp; \partial_{y} v1 + \partial_{x} v2
 \end{eqnarray}</div><dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.GradientOperator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/GradientOperator/#GradientOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.GradientOperator.direct" title="Link to this definition">#</a></dt>
<dd><p>Computes the first-order forward differences</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.ImageData" title="cil.framework.ImageData"><em>ImageData</em></a>)</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>optional</em>) – pre-allocated output memory to store result</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>result data if <cite>out</cite> not specified</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer">BlockDataContainer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.GradientOperator.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/GradientOperator/#GradientOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.GradientOperator.adjoint" title="Link to this definition">#</a></dt>
<dd><p>Computes the first-order backward differences</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>) – Gradient images for each dimension in ImageGeometry domain</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.ImageData" title="cil.framework.ImageData"><em>ImageData</em></a><em>, </em><em>optional</em>) – pre-allocated output memory to store result</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>result data if <cite>out</cite> not specified</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../framework/#cil.framework.ImageData" title="cil.framework.ImageData">ImageData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.GradientOperator.calculate_norm">
<span class="sig-name descname"><span class="pre">calculate_norm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/GradientOperator/#GradientOperator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.GradientOperator.calculate_norm" title="Link to this definition">#</a></dt>
<dd><p>Returns the analytical norm of the GradientOperator.</p>
<div class="math notranslate nohighlight">
\[\begin{split}(\partial_{z}, \partial_{y}, \partial_{x}) &amp;= \sqrt{\|\partial_{z}\|^{2} + \|\partial_{y}\|^{2} + \|\partial_{x}\|^{2} } \\
&amp;=  \sqrt{ \frac{4}{h_{z}^{2}} + \frac{4}{h_{y}^{2}} + \frac{4}{h_{x}^{2}}}\end{split}\]</div>
<p>Where the voxel sizes in each dimension are equal to 1 this simplifies to:</p>
<blockquote>
<div><ul class="simple">
<li><p>2D geometries <span class="math notranslate nohighlight">\(norm = \sqrt{8}\)</span></p></li>
<li><p>3D geometries <span class="math notranslate nohighlight">\(norm = \sqrt{12}\)</span></p></li>
</ul>
</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.FiniteDifferenceOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">FiniteDifferenceOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'forward'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bnd_cond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Neumann'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/FiniteDifferenceOperator/#FiniteDifferenceOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.FiniteDifferenceOperator" title="Link to this definition">#</a></dt>
<dd><p>Computes forward/backward/centered finite differences of a DataContainer
under Neumann/Periodic boundary conditions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> – Domain geometry for the FiniteDifferenceOperator</p></li>
<li><p><strong>direction</strong> (<em>string label from domain geometry</em><em> or </em><em>integer number</em>) – Direction to evaluate finite differences</p></li>
<li><p><strong>method</strong> (<em>'forward'</em><em>, </em><em>'backward'</em><em>, </em><em>'centered'</em>) – Method for finite differences</p></li>
<li><p><strong>bnd_cond</strong> – ‘Neumann’, ‘Periodic’</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.FiniteDifferenceOperator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/FiniteDifferenceOperator/#FiniteDifferenceOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.FiniteDifferenceOperator.direct" title="Link to this definition">#</a></dt>
<dd><p>Calls the operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>) – Element in the domain of the Operator</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>default None</em>) – If out is not None the output of the Operator will be filled in out, otherwise a new object is instantiated and returned.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a> or BlockDataContainer containing the result.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.FiniteDifferenceOperator.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/FiniteDifferenceOperator/#FiniteDifferenceOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.FiniteDifferenceOperator.adjoint" title="Link to this definition">#</a></dt>
<dd><p>Returns the adjoint/inverse operation evaluated at the point <span class="math notranslate nohighlight">\(x\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>) – Element in the domain of the Operator</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>default None</em>) – If out is not None the output of the Operator will be filled in out, otherwise a new object is instantiated and returned.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a> or BlockDataContainer containing the result.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only available to linear operators</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.SparseFiniteDifferenceOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">SparseFiniteDifferenceOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bnd_cond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Neumann'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/SparseFiniteDifferenceOperator/#SparseFiniteDifferenceOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SparseFiniteDifferenceOperator" title="Link to this definition">#</a></dt>
<dd><p>Create Sparse Matrices for the Finite Difference Operator</p>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.SparseFiniteDifferenceOperator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/SparseFiniteDifferenceOperator/#SparseFiniteDifferenceOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SparseFiniteDifferenceOperator.direct" title="Link to this definition">#</a></dt>
<dd><p>Calls the operator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>) – Element in the domain of the Operator</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>default None</em>) – If out is not None the output of the Operator will be filled in out, otherwise a new object is instantiated and returned.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a> or BlockDataContainer containing the result.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.SymmetrisedGradientOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">SymmetrisedGradientOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bnd_cond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Neumann'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/SymmetrisedGradientOperator/#SymmetrisedGradientOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SymmetrisedGradientOperator" title="Link to this definition">#</a></dt>
<dd><p>The symmetrised gradient is the operator, <span class="math notranslate nohighlight">\(E\)</span>, defined by <span class="math notranslate nohighlight">\(E: V \rightarrow W\)</span> where <cite>V</cite> is <cite>BlockGeometry</cite> and  <cite>W</cite> is the range of the Symmetrised Gradient and</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}E(v) = 0.5  ( \nabla v + (\nabla v)^{T} ) \\\end{split}\]</div>
</div></blockquote>
<p>In 2 dimensions, let <span class="math notranslate nohighlight">\(v(x,y)=(v_1(x,y),v_2(x,y))\)</span> which gives</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}\nabla v =\left( \begin{matrix}
    \partial_{x} v_1 &amp; \partial_x v_2\\
    \partial_{y}v_1 &amp; \partial_y v_2
\end{matrix}\right)\end{split}\]</div>
</div></blockquote>
<p>and thus</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}E(v) = 0.5  ( \nabla v + (\nabla v)^{T} )
=\left( \begin{matrix}
    \partial_{x} v_1 &amp; 0.5  (\partial_{y} v_1 + \partial_{x} v_2) \\
    0.5  (\partial_{x} v_1 + \partial_{y} v_2) &amp; \partial_{y} v_2
\end{matrix}\right)\end{split}\]</div>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> (<cite>BlockGeometry</cite> with shape (2,1) or (3,1)) – Set up the domain of the function.</p></li>
<li><p><strong>bnd_cond</strong> (str, optional, default <code class="code docutils literal notranslate"><span class="pre">Neumann</span></code>) – Boundary condition either <code class="code docutils literal notranslate"><span class="pre">Neumann</span></code> or <code class="code docutils literal notranslate"><span class="pre">Periodic</span></code></p></li>
<li><p><strong>correlation</strong> (str, optional, default <code class="code docutils literal notranslate"><span class="pre">Channel</span></code>) – Correlation either <code class="code docutils literal notranslate"><span class="pre">SpaceChannel</span></code> or <code class="code docutils literal notranslate"><span class="pre">Channel</span></code></p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.SymmetrisedGradientOperator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/SymmetrisedGradientOperator/#SymmetrisedGradientOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SymmetrisedGradientOperator.direct" title="Link to this definition">#</a></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(E(v) = 0.5 * ( \nabla v + (\nabla v)^{T} )\)</span></p>
<section id="parameters">
<h4>Parameters:<a class="headerlink" href="#parameters" title="Link to this heading">#</a></h4>
<p>x: BlockDataContainer
out: BlockDataContainer, default None</p>
<blockquote>
<div><p>If out is not None the output of direct will be filled in out, otherwise a new object is instantiated and returned.</p>
</div></blockquote>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.SymmetrisedGradientOperator.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/SymmetrisedGradientOperator/#SymmetrisedGradientOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.SymmetrisedGradientOperator.adjoint" title="Link to this definition">#</a></dt>
<dd><p>Returns the adjoint of the symmetrised gradient operator</p>
<section id="id13">
<h4>Parameters:<a class="headerlink" href="#id13" title="Link to this heading">#</a></h4>
<p>x: BlockDataContainer
out: BlockDataContainer, default None</p>
<blockquote>
<div><p>If out is not None the output of adjoint will be filled in out, otherwise a new object is instantiated and returned.</p>
</div></blockquote>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="waveletoperator">
<h3>WaveletOperator<a class="headerlink" href="#waveletoperator" title="Link to this heading">#</a></h3>
<p>We utilise PyWavelets (<a class="reference external" href="https://pywavelets.readthedocs.io/en/latest/index.html">https://pywavelets.readthedocs.io/en/latest/index.html</a>) to build wavelet operators in CIL:</p>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.WaveletOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">WaveletOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'haar'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/WaveletOperator/#WaveletOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.WaveletOperator" title="Link to this definition">#</a></dt>
<dd><p>Computes forward or inverse (adjoint) discrete wavelet transform (DWT) of the input</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_geometry</strong> (<em>cil geometry</em>) – Domain geometry for the WaveletOperator</p></li>
<li><p><strong>range_geometry</strong> (<em>cil geometry</em><em>, </em><em>optional</em>) – Output geometry for the WaveletOperator. Default = domain_geometry with the right coefficient array size deduced from pywavelets</p></li>
<li><p><strong>level</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>default= log_2</em><em>(</em><em>min</em><em>(</em><em>shape</em><em>(</em><em>axes</em><em>)</em><em>)</em><em>)</em>) – integer for decomposition level. Default = log_2(min(shape(axes))), i.e. the maximum number of accurate downsamplings possible</p></li>
<li><p><strong>wname</strong> (<em>string</em><em>, </em><em>optional</em><em>, </em><em>default='haar'</em>) – label for wavelet used.</p></li>
<li><p><strong>axes</strong> (<em>list</em><em> of </em><em>ints</em><em>, </em><em>optional</em><em>, </em><em>default=`None`</em>) – Defines the dimensions to decompose along. Note that channel is the first dimension: for example, spatial DWT is given by axes=range(1,3) and channelwise DWT is axes=range(1)
Default = <cite>None</cite>, meaning all dimensions are transformed. Same as axes = range(ndim)</p></li>
</ul>
</dd>
</dl>
<section id="kwargs">
<h4><a href="#id14"><span class="problematic" id="id15">**</span></a>kwargs<a class="headerlink" href="#kwargs" title="Link to this heading">#</a></h4>
<dl class="simple">
<dt>correlation: str, default ‘All’. Note: Only applied if <cite>axes = None</cite>!</dt><dd><p>‘All’ will compute the wavelet decomposition on every possible dimension.
‘Space’ will compute the wavelet decomposition on only the spatial dimensions. If there are multiple channels, each channel is decomposed independently.
‘Channels’ will compute the wavelet decomposition on only the channels, independently for every spatial point.</p>
</dd>
<dt>bnd_cond: str, default ‘symmetric’. More commonly known as the padding or extension method used in discrete convolutions. All options supported by PyWavelets are valid.</dt><dd><p>Most common examples are ‘symmetric’ (padding by mirroring edge values), ‘zero’ (padding with zeros), ‘periodic’ (wrapping values around as in circular convolution).
Some padding methods can have unexpected effect on the wavelet coefficients at the edges.
See <a class="reference external" href="https://pywavelets.readthedocs.io/en/latest/ref/signal-extension-modes.html">https://pywavelets.readthedocs.io/en/latest/ref/signal-extension-modes.html</a> for more details and all options.</p>
</dd>
</dl>
<p>true_adjoint: bool, default <cite>True</cite>. For biorthogonal wavelets the true mathematical adjoint should no longer produce perfect reconstructions, setting <cite>true_adjoint`as `False</cite> the reconstruction (using the adjoint) should be (almost) the original input.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default decomposition level is the theoretical maximum: log_2(min(input.shape)).  However, this is not always recommended and pywavelets should give a warning if the coarsest scales are too small to be meaningful.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We currently do not support wavelets that are not orthogonal or bi-orthogonal.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.WaveletOperator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/WaveletOperator/#WaveletOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.WaveletOperator.direct" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the WaveletOperator applied to <span class="math notranslate nohighlight">\(x\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the WaveletOperator applied to <span class="math notranslate nohighlight">\(x\)</span> or <cite>None</cite> if <cite>out</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.WaveletOperator.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Wx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/WaveletOperator/#WaveletOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.WaveletOperator.adjoint" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the adjoint of the WaveletOperator applied to <span class="math notranslate nohighlight">\(x\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the adjoint of the WaveletOperator applied to <span class="math notranslate nohighlight">\(x\)</span> or <cite>None</cite> if <cite>out</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.WaveletOperator.calculate_norm">
<span class="sig-name descname"><span class="pre">calculate_norm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/WaveletOperator/#WaveletOperator.calculate_norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.WaveletOperator.calculate_norm" title="Link to this definition">#</a></dt>
<dd><p>Returns the norm of WaveletOperator, which is equal to 1.0 if the wavelet is orthogonal</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>norm</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.WaveletOperator.is_orthogonal">
<span class="sig-name descname"><span class="pre">is_orthogonal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/WaveletOperator/#WaveletOperator.is_orthogonal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.WaveletOperator.is_orthogonal" title="Link to this definition">#</a></dt>
<dd><p>Returns if the operator is orthogonal</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><cite>Bool</cite></p>
</dd>
</dl>
</dd></dl>

</section>
</dd></dl>

</section>
</section>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Link to this heading">#</a></h2>
<p>A <code class="code docutils literal notranslate"><span class="pre">Function</span></code> represents a mathematical function of one or more inputs
and is intended to accept <code class="code docutils literal notranslate"><span class="pre">DataContainers</span></code> as input as well as any
additional parameters.</p>
<p>Fixed parameters can be passed in during the creation of the function object.
The methods of the function reflect the properties of it, for example, if the function
represented is differentiable the function should contain a method <code class="code docutils literal notranslate"><span class="pre">gradient</span></code>
which should return the gradient of the function evaluated at an input point.
If the function is not differentiable but allows a simple proximal operator,
the method <code class="code docutils literal notranslate"><span class="pre">proximal</span></code> should return the proximal operator evaluated at an
input point. The function value is evaluated by calling the function itself,
e.g. <code class="code docutils literal notranslate"><span class="pre">f(x)</span></code> for a <code class="code docutils literal notranslate"><span class="pre">Function</span> <span class="pre">f</span></code> and input point <code class="code docutils literal notranslate"><span class="pre">x</span></code>.</p>
<section id="base-classes">
<h3>Base classes<a class="headerlink" href="#base-classes" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.Function">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">Function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">L</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#Function"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function" title="Link to this definition">#</a></dt>
<dd><p>Abstract class representing a function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>L</strong> (<em>number</em><em>, </em><em>positive</em><em>, </em><em>default None</em>) – Lipschitz constant of the gradient of the function F(x), when it is differentiable.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Lipschitz of the gradient of the function is a positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L \|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.Function.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#Function.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.gradient" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of function <span class="math notranslate nohighlight">\(F\)</span>  evaluated at <span class="math notranslate nohighlight">\(x\)</span>, if it is differentiable</p>
<div class="math notranslate nohighlight">
\[F'(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a>, the value of the gradient of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.Function.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#Function.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.proximal" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of function <span class="math notranslate nohighlight">\(\tau F\)</span>  evaluated at x</p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F}(x) = \underset{z}{\text{argmin}} \frac{1}{2}\|z - x\|^{2} + \tau F(z)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the proximal operator of the function at x with scalar <span class="math notranslate nohighlight">\(\tau\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.Function.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#Function.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.convex_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Evaluation of the function F* at x, where F* is the convex conjugate of function F,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x}{\sup} \langle x^{*}, x \rangle - F(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the convex conjugate of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.Function.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#Function.proximal_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.proximal_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.Function.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#Function.centered_at"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Function.centered_at" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.Function.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.Function.L" title="Link to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">SumFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">functions</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#SumFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SumFunction" title="Link to this definition">#</a></dt>
<dd><p>SumFunction represents the sum of <span class="math notranslate nohighlight">\(n\geq2\)</span> functions</p>
<div class="math notranslate nohighlight">
\[(F_{1} + F_{2} + ... + F_{n})(\cdot)  = F_{1}(\cdot) + F_{2}(\cdot) + ... + F_{n}(\cdot)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>*functions</strong> (<em>Functions</em>) – Functions to set up a <a class="reference internal" href="#cil.optimisation.functions.SumFunction" title="cil.optimisation.functions.SumFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">SumFunction</span></code></a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the number of function is strictly less than 2.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="math notranslate nohighlight">
\[F(x) = \|x\|^{2} + \frac{1}{2}\|x - 1\|^{2}\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">cil.optimisation.functions</span><span class="w"> </span><span class="kn">import</span> <span class="n">L2NormSquared</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">cil.framework</span><span class="w"> </span><span class="kn">import</span> <span class="n">ImageGeometry</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">L2NormSquared</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">L2NormSquared</span><span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">SumFunction</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">)</span>
</pre></div>
</div>
<div class="math notranslate nohighlight">
\[F(x) = \sum_{i=1}^{50} \|x - i\|^{2}\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">SumFunction</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">L2NormSquared</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">)])</span>
</pre></div>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumFunction.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.SumFunction.L" title="Link to this definition">#</a></dt>
<dd><p>Returns the Lipschitz constant for the SumFunction</p>
<div class="math notranslate nohighlight">
\[L = \sum_{i} L_{i}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{i}\)</span> is the Lipschitz constant of the smooth function <span class="math notranslate nohighlight">\(F_{i}\)</span>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumFunction.Lmax">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Lmax</span></span><a class="headerlink" href="#cil.optimisation.functions.SumFunction.Lmax" title="Link to this definition">#</a></dt>
<dd><p>Returns the maximum Lipschitz constant for the SumFunction</p>
<div class="math notranslate nohighlight">
\[L = \max_{i}\{L_{i}\}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{i}\)</span> is the Lipschitz constant of the smooth function <span class="math notranslate nohighlight">\(F_{i}\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumFunction.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#SumFunction.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SumFunction.gradient" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the sum of the gradient of functions evaluated at <span class="math notranslate nohighlight">\(x\)</span>, if all of them are differentiable.</p>
<div class="math notranslate nohighlight">
\[(F'_{1} + F'_{2} + ... + F'_{n})(x) = F'_{1}(x) + F'_{2}(x) + ... + F'_{n}(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – Point to evaluate the gradient at.</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the sum of the gradients evaluated at point <span class="math notranslate nohighlight">\(x\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumFunction.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SumFunction.centered_at" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumFunction.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SumFunction.convex_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Evaluation of the function F* at x, where F* is the convex conjugate of function F,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x}{\sup} \langle x^{*}, x \rangle - F(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the convex conjugate of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumFunction.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SumFunction.proximal" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of function <span class="math notranslate nohighlight">\(\tau F\)</span>  evaluated at x</p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F}(x) = \underset{z}{\text{argmin}} \frac{1}{2}\|z - x\|^{2} + \tau F(z)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the proximal operator of the function at x with scalar <span class="math notranslate nohighlight">\(\tau\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumFunction.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SumFunction.proximal_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.ScaledFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">ScaledFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scalar</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#ScaledFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction" title="Link to this definition">#</a></dt>
<dd><p>ScaledFunction represents the scalar multiplication with a Function.</p>
<p>Let a function F then and a scalar <span class="math notranslate nohighlight">\(\alpha\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(G(x) = \alpha F(x)\)</span> then:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(G(x) = \alpha  F(x)\)</span> ( __call__ method )</p></li>
<li><p><span class="math notranslate nohighlight">\(G'(x) = \alpha  F'(x)\)</span> ( gradient method )</p></li>
<li><p><span class="math notranslate nohighlight">\(G^{*}(x^{*}) = \alpha  F^{*}(\frac{x^{*}}{\alpha})\)</span> ( convex_conjugate method )</p></li>
<li><p><span class="math notranslate nohighlight">\(\text{prox}_{\tau G}(x) = \text{prox}_{(\tau\alpha) F}(x)\)</span> ( proximal method )</p></li>
</ol>
<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.ScaledFunction.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.L" title="Link to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ScaledFunction.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#ScaledFunction.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.convex_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the convex conjugate of the scaled function.</p>
<div class="math notranslate nohighlight">
\[G^{*}(x^{*}) = \alpha  F^{*}(\frac{x^{*}}{\alpha})\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the convex conjugate of the scaled function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ScaledFunction.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#ScaledFunction.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.gradient" title="Link to this definition">#</a></dt>
<dd><p>Returns the gradient of the scaled function evaluated at <span class="math notranslate nohighlight">\(x\)</span>.</p>
<div class="math notranslate nohighlight">
\[G'(x) = \alpha  F'(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – Point to evaluate the gradient at.</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the gradient of the scaled function evaluated at <span class="math notranslate nohighlight">\(x\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ScaledFunction.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#ScaledFunction.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.proximal" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the scaled function, evaluated at <span class="math notranslate nohighlight">\(x\)</span>.</p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau G}(x) = \text{prox}_{(\tau\alpha) F}(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the proximal operator of the scaled function evaluated at <span class="math notranslate nohighlight">\(x\)</span> with scalar <span class="math notranslate nohighlight">\(\tau\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ScaledFunction.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#ScaledFunction.proximal_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.proximal_conjugate" title="Link to this definition">#</a></dt>
<dd><p>This returns the proximal  conjugate operator for the function at <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(\tau\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the proximal conjugate operator for the function evaluated at <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(\tau\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ScaledFunction.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.ScaledFunction.centered_at" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumScalarFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">SumScalarFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#SumScalarFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction" title="Link to this definition">#</a></dt>
<dd><p>SumScalarFunction represents the sum a function with a scalar.</p>
<div class="math notranslate nohighlight">
\[(F + scalar)(x)  = F(x) + scalar\]</div>
<p>Although SumFunction has no general expressions for</p>
<ol class="lowerroman simple">
<li><p>convex_conjugate</p></li>
<li><p>proximal</p></li>
<li><p>proximal_conjugate</p></li>
</ol>
<p>if the second argument is a ConstantFunction then we can derive the above analytically.</p>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumScalarFunction.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#SumScalarFunction.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction.convex_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the convex conjugate of a <span class="math notranslate nohighlight">\((F+scalar)\)</span>, evaluated at <span class="math notranslate nohighlight">\(x\)</span>.</p>
<div class="math notranslate nohighlight">
\[(F+scalar)^{*}(x^{*}) = F^{*}(x^{*}) - scalar\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the convex conjugate evaluated at <span class="math notranslate nohighlight">\(x\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumScalarFunction.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#SumScalarFunction.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction.proximal" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of <span class="math notranslate nohighlight">\(F+scalar\)</span></p>
<div class="math notranslate nohighlight">
\[ext{prox}_{     au (F+scalar)}(x) =     ext{prox}_{     au F}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the evaluation of the proximal operator evaluated at <span class="math notranslate nohighlight">\(x\)</span> and :math:`       au`.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumScalarFunction.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction.L" title="Link to this definition">#</a></dt>
<dd><p>Returns the Lipschitz constant for the SumFunction</p>
<div class="math notranslate nohighlight">
\[L = \sum_{i} L_{i}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{i}\)</span> is the Lipschitz constant of the smooth function <span class="math notranslate nohighlight">\(F_{i}\)</span>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumScalarFunction.Lmax">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Lmax</span></span><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction.Lmax" title="Link to this definition">#</a></dt>
<dd><p>Returns the maximum Lipschitz constant for the SumFunction</p>
<div class="math notranslate nohighlight">
\[L = \max_{i}\{L_{i}\}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{i}\)</span> is the Lipschitz constant of the smooth function <span class="math notranslate nohighlight">\(F_{i}\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumScalarFunction.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction.centered_at" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumScalarFunction.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction.gradient" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the sum of the gradient of functions evaluated at <span class="math notranslate nohighlight">\(x\)</span>, if all of them are differentiable.</p>
<div class="math notranslate nohighlight">
\[(F'_{1} + F'_{2} + ... + F'_{n})(x) = F'_{1}(x) + F'_{2}(x) + ... + F'_{n}(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – Point to evaluate the gradient at.</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the sum of the gradients evaluated at point <span class="math notranslate nohighlight">\(x\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SumScalarFunction.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SumScalarFunction.proximal_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.TranslateFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">TranslateFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#TranslateFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction" title="Link to this definition">#</a></dt>
<dd><p>TranslateFunction represents the translation of function F with respect to the center b.</p>
<p>Let a function F and consider <span class="math notranslate nohighlight">\(G(x) = F(x - center)\)</span>.</p>
<p>Function F is centered at 0, whereas G is centered at point b.</p>
<p>If <span class="math notranslate nohighlight">\(G(x) = F(x - b)\)</span> then:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(G(x) = F(x - b)\)</span> ( __call__ method )</p></li>
<li><p><span class="math notranslate nohighlight">\(G'(x) = F'(x - b)\)</span> ( gradient method )</p></li>
<li><p><span class="math notranslate nohighlight">\(G^{*}(x^{*}) = F^{*}(x^{*}) + &lt;x^{*}, b &gt;\)</span> ( convex_conjugate method )</p></li>
<li><p><span class="math notranslate nohighlight">\(\text{prox}_{\tau G}(x) = \text{prox}_{\tau F}(x - b)  + b\)</span> ( proximal method )</p></li>
</ol>
<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.TranslateFunction.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction.L" title="Link to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.TranslateFunction.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction.centered_at" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.TranslateFunction.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction.proximal_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.TranslateFunction.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#TranslateFunction.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction.gradient" title="Link to this definition">#</a></dt>
<dd><p>Returns the gradient of the translated function.</p>
<div class="math notranslate nohighlight">
\[G'(x) =  F'(x - b)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – Point to evaluate the gradient at.</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the gradient of the translated function evaluated at <span class="math notranslate nohighlight">\(x\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.TranslateFunction.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#TranslateFunction.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction.proximal" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the translated function.</p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau G}(x) = \text{prox}_{\tau F}(x-b) + b\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the proximal operator of the translated function at <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(\tau\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.TranslateFunction.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#TranslateFunction.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TranslateFunction.convex_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the convex conjugate of the translated function.</p>
<div class="math notranslate nohighlight">
\[G^{*}(x^{*}) = F^{*}(x^{*}) + &lt;x^{*}, b &gt;\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the convex conjugate of the translated function at <span class="math notranslate nohighlight">\(x\)</span>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="simple-functions">
<h3>Simple functions<a class="headerlink" href="#simple-functions" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.ConstantFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">ConstantFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#ConstantFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction" title="Link to this definition">#</a></dt>
<dd><p>ConstantFunction: <span class="math notranslate nohighlight">\(F(x) = constant, constant\in\mathbb{R}\)</span></p>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ConstantFunction.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#ConstantFunction.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.gradient" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of the function, <span class="math notranslate nohighlight">\(F'(x)=0\)</span>
:param x: Point to evaluate the gradient at.
:type x: DataContainer
:param out:
:type out: return DataContainer, if None a new DataContainer is returned, default None.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>A DataContainer of zeros, the same size as <span class="math notranslate nohighlight">\(x\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ConstantFunction.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#ConstantFunction.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.convex_conjugate" title="Link to this definition">#</a></dt>
<dd><p>The convex conjugate of constant function <span class="math notranslate nohighlight">\(F(x) = c\in\mathbb{R}\)</span> is</p>
<div class="math notranslate nohighlight">
\[\begin{split}F(x^{*})
=
\begin{cases}
    -c, &amp; if x^{*} = 0\\
    \infty, &amp; \mbox{otherwise}
\end{cases}\end{split}\]</div>
<p>However, <span class="math notranslate nohighlight">\(x^{*} = 0\)</span> only in the limit of iterations, so in fact this can be infinity.
We do not want to have inf values in the convex conjugate, so we have to penalise this value accordingly.
The following penalisation is useful in the PDHG algorithm, when we compute primal &amp; dual objectives
for convergence purposes.</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \sum \max\{x^{*}, 0\}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The maximum of x and 0, summed over the entries of x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ConstantFunction.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#ConstantFunction.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.proximal" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the constant function, which is the same element, i.e.,</p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F}(x) = x\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, equal to <span class="math notranslate nohighlight">\(x\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.ConstantFunction.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.L" title="Link to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ConstantFunction.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.centered_at" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ConstantFunction.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.ConstantFunction.proximal_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.ZeroFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">ZeroFunction</span></span><a class="reference internal" href="../_modules/cil/optimisation/functions/Function/#ZeroFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ZeroFunction" title="Link to this definition">#</a></dt>
<dd><p>ZeroFunction represents the zero function, <span class="math notranslate nohighlight">\(F(x) = 0\)</span></p>
<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.ZeroFunction.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.ZeroFunction.L" title="Link to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ZeroFunction.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.ZeroFunction.centered_at" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ZeroFunction.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.ZeroFunction.convex_conjugate" title="Link to this definition">#</a></dt>
<dd><p>The convex conjugate of constant function <span class="math notranslate nohighlight">\(F(x) = c\in\mathbb{R}\)</span> is</p>
<div class="math notranslate nohighlight">
\[\begin{split}F(x^{*})
=
\begin{cases}
    -c, &amp; if x^{*} = 0\\
    \infty, &amp; \mbox{otherwise}
\end{cases}\end{split}\]</div>
<p>However, <span class="math notranslate nohighlight">\(x^{*} = 0\)</span> only in the limit of iterations, so in fact this can be infinity.
We do not want to have inf values in the convex conjugate, so we have to penalise this value accordingly.
The following penalisation is useful in the PDHG algorithm, when we compute primal &amp; dual objectives
for convergence purposes.</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \sum \max\{x^{*}, 0\}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The maximum of x and 0, summed over the entries of x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ZeroFunction.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.ZeroFunction.gradient" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of the function, <span class="math notranslate nohighlight">\(F'(x)=0\)</span>
:param x: Point to evaluate the gradient at.
:type x: DataContainer
:param out:
:type out: return DataContainer, if None a new DataContainer is returned, default None.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>A DataContainer of zeros, the same size as <span class="math notranslate nohighlight">\(x\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ZeroFunction.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.ZeroFunction.proximal" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the constant function, which is the same element, i.e.,</p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F}(x) = x\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, equal to <span class="math notranslate nohighlight">\(x\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ZeroFunction.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.ZeroFunction.proximal_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.Rosenbrock">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">Rosenbrock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Rosenbrock/#Rosenbrock"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Rosenbrock" title="Link to this definition">#</a></dt>
<dd><p>Rosenbrock function</p>
<div class="math notranslate nohighlight">
\[\]</div>
<p>F(x,y) = (alpha - x)^2 + beta(y-x^2)^2</p>
<p>The function has a global minimum at .. math:: (x,y)=(alpha, alpha^2)</p>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.Rosenbrock.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/Rosenbrock/#Rosenbrock.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.Rosenbrock.gradient" title="Link to this definition">#</a></dt>
<dd><p>Gradient of the Rosenbrock function</p>
<div class="math notranslate nohighlight">
\[\]</div>
<p>nabla f(x,y) = left[ 2*((x-alpha) - 2beta x(y-x^2)) ; 2beta (y - x^2)  right]</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.Rosenbrock.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.Rosenbrock.L" title="Link to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.Rosenbrock.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.Rosenbrock.centered_at" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.Rosenbrock.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.Rosenbrock.convex_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Evaluation of the function F* at x, where F* is the convex conjugate of function F,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x}{\sup} \langle x^{*}, x \rangle - F(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the convex conjugate of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.Rosenbrock.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.Rosenbrock.proximal" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of function <span class="math notranslate nohighlight">\(\tau F\)</span>  evaluated at x</p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F}(x) = \underset{z}{\text{argmin}} \frac{1}{2}\|z - x\|^{2} + \tau F(z)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the proximal operator of the function at x with scalar <span class="math notranslate nohighlight">\(\tau\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.Rosenbrock.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.Rosenbrock.proximal_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="composition-of-operator-and-a-function">
<h3>Composition of operator and a function<a class="headerlink" href="#composition-of-operator-and-a-function" title="Link to this heading">#</a></h3>
<p>This class allows the user to write a function which does the following:</p>
<div class="math notranslate nohighlight">
\[F ( x ) = G ( Ax )\]</div>
<p>where <span class="math notranslate nohighlight">\(A\)</span> is an operator. For instance the least squares function can
be expressed as</p>
<div class="math notranslate nohighlight">
\[F(x) = || Ax - b ||^2_2 \qquad \text{where} \qquad G(y) = || y - b ||^2_2\]</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">F1</span> <span class="o">=</span> <span class="n">Norm2Sq</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="c1"># or equivalently</span>
<span class="n">F2</span> <span class="o">=</span> <span class="n">OperatorCompositionFunction</span><span class="p">(</span><span class="n">L2NormSquared</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">),</span> <span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.OperatorCompositionFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">OperatorCompositionFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/OperatorCompositionFunction/#OperatorCompositionFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction" title="Link to this definition">#</a></dt>
<dd><p>Composition of a function with an operator as : <span class="math notranslate nohighlight">\((F \circ A)(x) = F(Ax)\)</span></p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">parameter function<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="code docutils literal notranslate"><span class="pre">Function</span></code> F</p>
</dd>
<dt class="field-even">parameter operator<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="code docutils literal notranslate"><span class="pre">Operator</span></code> A</p>
</dd>
</dl>
</div></blockquote>
<p>For general operator, we have no explicit formulas for convex_conjugate,
proximal and proximal_conjugate</p>
<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.OperatorCompositionFunction.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction.L" title="Link to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.OperatorCompositionFunction.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/OperatorCompositionFunction/#OperatorCompositionFunction.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction.gradient" title="Link to this definition">#</a></dt>
<dd><p>Return the gradient of <span class="math notranslate nohighlight">\(F(Ax)\)</span>,</p>
<p><span class="math notranslate nohighlight">\((F(Ax))' = A^{T}F'(Ax)\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.OperatorCompositionFunction.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction.centered_at" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.OperatorCompositionFunction.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction.convex_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Evaluation of the function F* at x, where F* is the convex conjugate of function F,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x}{\sup} \langle x^{*}, x \rangle - F(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the convex conjugate of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.OperatorCompositionFunction.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction.proximal" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of function <span class="math notranslate nohighlight">\(\tau F\)</span>  evaluated at x</p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F}(x) = \underset{z}{\text{argmin}} \frac{1}{2}\|z - x\|^{2} + \tau F(z)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the proximal operator of the function at x with scalar <span class="math notranslate nohighlight">\(\tau\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.OperatorCompositionFunction.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.OperatorCompositionFunction.proximal_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="indicator-box">
<h3>Indicator box<a class="headerlink" href="#indicator-box" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.IndicatorBox">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">IndicatorBox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accelerated</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/IndicatorBox/#IndicatorBox"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox" title="Link to this definition">#</a></dt>
<dd><p>Indicator function for box constraint</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}f(x) = \mathbb{I}_{[a, b]} = \begin{cases}
                                   0, \text{ if } x \in [a, b] \\
                                   \infty, \text{otherwise}
                            \end{cases}\end{split}\]</div>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lower</strong> (<em>float</em><em>, </em><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><em>numpy array</em><em>, </em><em>default None</em>) – Lower bound. If set to None, it is equivalent to <code class="docutils literal notranslate"><span class="pre">-np.inf</span></code>.</p></li>
<li><p><strong>upper</strong> (<em>float</em><em>, </em><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><em>numpy array</em><em>, </em><em>default None</em>) – Upper bound. If set to None, it is equivalent to <code class="docutils literal notranslate"><span class="pre">np.inf</span></code>.</p></li>
<li><p><strong>accelerated</strong> (<em>bool</em><em>, </em><em>default True</em>) – Specifies whether to use the accelerated version or not, using numba or
numpy backends respectively.</p></li>
</ul>
</dd>
</dl>
<p>If <code class="docutils literal notranslate"><span class="pre">lower</span></code> or <code class="docutils literal notranslate"><span class="pre">upper</span></code> are passed a <code class="docutils literal notranslate"><span class="pre">DataContainer</span></code> (or derived class
such as <code class="docutils literal notranslate"><span class="pre">ImageData</span></code> or <code class="docutils literal notranslate"><span class="pre">AcquisitionData</span></code>) or a <code class="docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>, the bounds
can be set to different values for each element.</p>
<p>In order to save computing time it is possible to suppress the evaluation of
the function. This is achieved by setting <code class="docutils literal notranslate"><span class="pre">suppress_evaluation</span></code> to <code class="docutils literal notranslate"><span class="pre">True</span></code>.
<code class="docutils literal notranslate"><span class="pre">IndicatorBox</span></code> evaluated on any input will then return 0.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">accelerated</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> (default), the Numba backend is used.
Otherwise, the Numpy backend is used. An optional parameter to set the number of
threads used by Numba can be set with <code class="docutils literal notranslate"><span class="pre">set_num_threads</span></code>. Setting the number of
threads when <code class="docutils literal notranslate"><span class="pre">accelerate</span></code> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code> will not have any effect.
The default number of threads is defined in the <code class="docutils literal notranslate"><span class="pre">cil.utilities.multiprocessing</span></code>
module, and it is equivalent to half of the CPU cores available.</p>
<section id="example">
<h4>Example:<a class="headerlink" href="#example" title="Link to this heading">#</a></h4>
<p>In order to save computing time it is possible to suppress the evaluation of the
function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ib</span> <span class="o">=</span> <span class="n">IndicatorBox</span><span class="p">(</span><span class="n">lower</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ib</span><span class="o">.</span><span class="n">set_suppress_evaluation</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ib</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># returns 0</span>
</pre></div>
</div>
</section>
<section id="id16">
<h4>Example:<a class="headerlink" href="#id16" title="Link to this heading">#</a></h4>
<p>Set the number of threads used in accelerated mode.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">num_threads</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">ib</span> <span class="o">=</span> <span class="n">IndicatorBox</span><span class="p">(</span><span class="n">lower</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ib</span><span class="o">.</span><span class="n">set_num_threads</span><span class="p">(</span><span class="n">num_threads</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.IndicatorBox.set_suppress_evaluation">
<span class="sig-name descname"><span class="pre">set_suppress_evaluation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/IndicatorBox/#IndicatorBox.set_suppress_evaluation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.set_suppress_evaluation" title="Link to this definition">#</a></dt>
<dd><p>Suppresses the evaluation of the function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>value</strong> (<em>bool</em>) – If True, the function evaluation on any input will return 0, without calculation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.IndicatorBox.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/IndicatorBox/#IndicatorBox.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.proximal" title="Link to this definition">#</a></dt>
<dd><p>Proximal operator of IndicatorBox at x</p>
<div class="math notranslate nohighlight">
\[prox_{\tau * f}(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – Input to the proximal operator</p></li>
<li><p><strong>tau</strong> (<em>float</em>) – Step size. Notice it is ignored in IndicatorBox</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>optional</em>) – Output of the proximal operator. If not provided, a new DataContainer is created.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">tau</span></code> is ignored but it is in the signature of the generic Function class</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.IndicatorBox.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/IndicatorBox/#IndicatorBox.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.gradient" title="Link to this definition">#</a></dt>
<dd><p>IndicatorBox is not differentiable, so calling gradient will raise a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.IndicatorBox.num_threads">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_threads</span></span><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.num_threads" title="Link to this definition">#</a></dt>
<dd><p>Get the optional number of threads parameter to use for the accelerated version.</p>
<p>Defaults to the value set in the CIL multiprocessing module.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.IndicatorBox.set_num_threads">
<span class="sig-name descname"><span class="pre">set_num_threads</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/IndicatorBox/#IndicatorBox.set_num_threads"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.set_num_threads" title="Link to this definition">#</a></dt>
<dd><p>Set the optional number of threads parameter to use for the accelerated version.</p>
<p>This is discarded if <code class="docutils literal notranslate"><span class="pre">accelerated=False</span></code>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.IndicatorBox.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.L" title="Link to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.IndicatorBox.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.centered_at" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.IndicatorBox.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.convex_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Evaluation of the function F* at x, where F* is the convex conjugate of function F,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x}{\sup} \langle x^{*}, x \rangle - F(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the convex conjugate of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.IndicatorBox.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.IndicatorBox.proximal_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</section>
</dd></dl>

</section>
<section id="kullbackleibler">
<h3>KullbackLeibler<a class="headerlink" href="#kullbackleibler" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.KullbackLeibler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">KullbackLeibler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'numba'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/KullbackLeibler/#KullbackLeibler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler" title="Link to this definition">#</a></dt>
<dd><p>Kullback Leibler</p>
<div class="math notranslate nohighlight">
\[\begin{split}F(u, v)
= \begin{cases}
u \log(\frac{u}{v}) - u + v &amp; \mbox{ if } u &gt; 0, v &gt; 0\\
v &amp; \mbox{ if } u = 0, v \ge 0 \\
\infty, &amp; \mbox{otherwise}
\end{cases}\end{split}\]</div>
<p>where the <span class="math notranslate nohighlight">\(0\log0 := 0\)</span> convention is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>b</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>non-negative</em>) – Translates the function at point <cite>b</cite>.</p></li>
<li><p><strong>eta</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>default = 0</em>) – Background noise</p></li>
<li><p><strong>mask</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>default = None</em>) – Mask for the data <cite>b</cite></p></li>
<li><p><strong>backend</strong> (<em>{'numba'</em><em>,</em><em>'numpy'}</em><em>, </em><em>optional</em>) – Backend for the KullbackLeibler methods. Numba is the default backend.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Kullback-Leibler function is used in practice as a fidelity term in minimisation problems where the
acquired data follow Poisson distribution. If we denote the acquired data with <code class="code docutils literal notranslate"><span class="pre">b</span></code>
then, we write</p>
<div class="math notranslate nohighlight">
\[\underset{i}{\sum} F(b_{i}, (v + \eta)_{i})\]</div>
<p>where, <span class="math notranslate nohighlight">\(\eta\)</span> is an additional noise.</p>
<p>In the case of Positron Emission Tomography reconstruction <span class="math notranslate nohighlight">\(\eta\)</span> represents
scatter and random events contribution during the PET acquisition. Hence, in that case the KullbackLeibler
fidelity measures the distance between <span class="math notranslate nohighlight">\(\mathcal{A}v + \eta\)</span> and acquisition data <span class="math notranslate nohighlight">\(b\)</span>, where
<span class="math notranslate nohighlight">\(\mathcal{A}\)</span> is the projection operator. This is related to <a class="reference external" href="http://stir.sourceforge.net/documentation/doxy/html/classstir_1_1PoissonLogLikelihoodWithLinearModelForMean.html">PoissonLogLikelihoodWithLinearModelForMean</a> ,
definition that is used in PET reconstruction in the <a class="reference external" href="https://github.com/SyneRBI/SIRF">SIRF</a> software.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default implementation uses the build-in function <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.kl_div.html">kl_div</a> from scipy.
The methods of the <a class="reference internal" href="#cil.optimisation.functions.KullbackLeibler" title="cil.optimisation.functions.KullbackLeibler.KullbackLeibler"><code class="xref py py-class docutils literal notranslate"><span class="pre">KullbackLeibler</span></code></a> are accelerated provided that <a class="reference external" href="https://numba.pydata.org/">numba</a> library is installed.</p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">cil.optimisation.functions</span><span class="w"> </span><span class="kn">import</span> <span class="n">KullbackLeibler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">cil.framework</span><span class="w"> </span><span class="kn">import</span> <span class="n">ImageGeometry</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ig</span> <span class="o">=</span> <span class="n">ImageGeometry</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s1">&#39;random&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">KullbackLeibler</span><span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.KullbackLeibler.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler.L" title="Link to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.KullbackLeibler.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler.centered_at" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.KullbackLeibler.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler.convex_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Evaluation of the function F* at x, where F* is the convex conjugate of function F,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x}{\sup} \langle x^{*}, x \rangle - F(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the convex conjugate of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.KullbackLeibler.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler.gradient" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of function <span class="math notranslate nohighlight">\(F\)</span>  evaluated at <span class="math notranslate nohighlight">\(x\)</span>, if it is differentiable</p>
<div class="math notranslate nohighlight">
\[F'(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a>, the value of the gradient of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.KullbackLeibler.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler.proximal" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of function <span class="math notranslate nohighlight">\(\tau F\)</span>  evaluated at x</p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F}(x) = \underset{z}{\text{argmin}} \frac{1}{2}\|z - x\|^{2} + \tau F(z)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the proximal operator of the function at x with scalar <span class="math notranslate nohighlight">\(\tau\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.KullbackLeibler.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.KullbackLeibler.proximal_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="l1-norm">
<h3>L1 Norm<a class="headerlink" href="#l1-norm" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.L1Norm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">L1Norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L1Norm/#L1Norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L1Norm" title="Link to this definition">#</a></dt>
<dd><p>L1Norm function</p>
<p>Consider the following cases:</p>
<ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[F(x) = ||x||_{1}\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[F(x) = ||x - b||_{1}\]</div>
</li>
</ol>
<p>In the weighted case, <span class="math notranslate nohighlight">\(w\)</span> is an array of non-negative weights.</p>
<ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[F(x) = ||x||_{L^1(w)}\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[F(x) = ||x - b||_{L^1(w)}\]</div>
</li>
</ol>
<p>with <span class="math notranslate nohighlight">\(||x||_{L^1(w)} = || x  w||_1 = \sum_{i=1}^{n} |x_i| w_i\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weight</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>numpy ndarray</em><em>, </em><em>default None</em>) – Array of non-negative weights. If <code class="code docutils literal notranslate"><span class="pre">None</span></code> returns the L1 Norm.</p></li>
<li><p><strong>b</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>default None</em>) – Translation of the function.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.L1Norm.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L1Norm/#L1Norm.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L1Norm.convex_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the convex conjugate of the L1 Norm function at x.</p>
<p>This is the indicator of the unit <span class="math notranslate nohighlight">\(L^{\infty}\)</span> norm:</p>
<ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \mathbb{I}_{\{\|\cdot\|_{\infty}\leq1\}}(x^{*})\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \mathbb{I}_{\{\|\cdot\|_{\infty}\leq1\}}(x^{*}) + \langle x^{*},b\rangle\]</div>
</li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbb{I}_{\{\|\cdot\|_{\infty}\leq1\}}(x^{*})
= \begin{cases}
0, \mbox{if } \|x^{*}\|_{\infty}\leq1\\
\infty, \mbox{otherwise}
\end{cases}\end{split}\]</div>
<p>In the weighted case the convex conjugate is the indicator of the unit
<span class="math notranslate nohighlight">\(L^{\infty}(w^{-1})\)</span> norm.</p>
<p>See:
<a class="reference external" href="https://math.stackexchange.com/questions/1533217/convex-conjugate-of-l1-norm-function-with-weight">https://math.stackexchange.com/questions/1533217/convex-conjugate-of-l1-norm-function-with-weight</a></p>
<ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \mathbb{I}_{\{\|\cdot\|_{L^\infty(w^{-1})}\leq 1\}}(x^{*})\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \mathbb{I}_{\{\|\cdot\|_{L^\infty(w^{-1})}\leq 1\}}(x^{*}) + \langle x^{*},b\rangle\]</div>
</li>
</ol>
<p>with <span class="math notranslate nohighlight">\(\|x\|_{L^\infty(w^{-1})} = \max_{i} \frac{|x_i|}{w_i}\)</span> and possible cases of 0/0 are defined to be 1..</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – where to evaluate the convex conjugate of the L1 Norm function.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>the value of the convex conjugate of the WeightedL1Norm function at x</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>DataContainer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.L1Norm.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L1Norm/#L1Norm.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L1Norm.proximal" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the proximal operator of the L1 Norm function at x with scaling parameter <cite>tau</cite>.</p>
<p>Consider the following cases:</p>
<ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \mathrm{ShinkOperator}_\tau(x)\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \mathrm{ShinkOperator}_\tau(x - b) + b\]</div>
</li>
</ol>
<p>where,</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \mathrm{ShinkOperator}(x) = sgn(x) * \max\{ |x| - \tau, 0 \}\]</div>
<p>The weighted case follows from Example 6.23 in Chapter 6 of “First-Order Methods in Optimization”
by Amir Beck, SIAM 2017 <a class="reference external" href="https://archive.siam.org/books/mo25/mo25_ch6.pdf">https://archive.siam.org/books/mo25/mo25_ch6.pdf</a></p>
<ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \mathrm{ShinkOperator}_{\tau*w}(x)\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \mathrm{ShinkOperator}_{\tau*w}(x - b) + b\]</div>
</li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>float</em><em>, </em><em>real</em><em>,  </em><em>ndarray</em><em>, </em><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>default None</em>) – If not None, the result will be stored in this object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>The value of the proximal operator of the L1 norm function at x</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>DataContainer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.L1Norm.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.L1Norm.L" title="Link to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.L1Norm.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.L1Norm.centered_at" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.L1Norm.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.L1Norm.gradient" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of function <span class="math notranslate nohighlight">\(F\)</span>  evaluated at <span class="math notranslate nohighlight">\(x\)</span>, if it is differentiable</p>
<div class="math notranslate nohighlight">
\[F'(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a>, the value of the gradient of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.L1Norm.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.L1Norm.proximal_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="l2-norm-squared">
<h3>L2 Norm Squared<a class="headerlink" href="#l2-norm-squared" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.L2NormSquared">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">L2NormSquared</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L2NormSquared/#L2NormSquared"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared" title="Link to this definition">#</a></dt>
<dd><p>L2NormSquared function: <span class="math notranslate nohighlight">\(F(x) = \| x\|^{2}_{2} = \underset{i}{\sum}x_{i}^{2}\)</span></p>
<p>Following cases are considered:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p><span class="math notranslate nohighlight">\(F(x) = \|x\|^{2}_{2}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(F(x) = \|x - b\|^{2}_{2}\)</span></p></li>
</ol>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>b</strong> (<cite>DataContainer</cite>, optional) – Translation of the function</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For case b) we can use <code class="code docutils literal notranslate"><span class="pre">F</span> <span class="pre">=</span> <span class="pre">L2NormSquared().centered_at(b)</span></code>, see <em>TranslateFunction</em>.</p>
</div>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">L2NormSquared</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">L2NormSquared</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">L2NormSquared</span><span class="p">()</span><span class="o">.</span><span class="n">centered_at</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.L2NormSquared.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L2NormSquared/#L2NormSquared.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared.gradient" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of the L2NormSquared function at x.</p>
<p>Following cases are considered:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p><span class="math notranslate nohighlight">\(F'(x) = 2x\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(F'(x) = 2(x-b)\)</span></p></li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.L2NormSquared.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L2NormSquared/#L2NormSquared.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared.convex_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the convex conjugate of the L2NormSquared function at x.</p>
<p>Consider the following cases:</p>
<blockquote>
<div><ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \frac{1}{4}\|x^{*}\|^{2}_{2}\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \frac{1}{4}\|x^{*}\|^{2}_{2} + \langle x^{*}, b\rangle\]</div>
</li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.L2NormSquared.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L2NormSquared/#L2NormSquared.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared.proximal" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the proximal operator of the L2NormSquared function at x.</p>
<p>Consider the following cases:</p>
<blockquote>
<div><ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[\text{prox}_{\tau F}(x) = \frac{x}{1+2\tau}\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[\text{prox}_{\tau F}(x) = \frac{x-b}{1+2\tau} + b\]</div>
</li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.L2NormSquared.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared.L" title="Link to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.L2NormSquared.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared.centered_at" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.L2NormSquared.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.L2NormSquared.proximal_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.WeightedL2NormSquared">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">WeightedL2NormSquared</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L2NormSquared/#WeightedL2NormSquared"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared" title="Link to this definition">#</a></dt>
<dd><p>WeightedL2NormSquared function: <span class="math notranslate nohighlight">\(F(x) = \|x\|_{W,2}^2 = \Sigma_iw_ix_i^2 = \langle x, Wx\rangle = x^TWx\)</span>
where <span class="math notranslate nohighlight">\(W=\text{diag}(weight)\)</span> if <cite>weight</cite> is a <cite>DataContainer</cite> or <span class="math notranslate nohighlight">\(W=\text{weight} I\)</span> if <cite>weight</cite> is a scalar.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>**kwargs</strong></p></li>
<li><p><strong>weight</strong> (a <cite>scalar</cite> or a <cite>DataContainer</cite> with the same shape as the intended domain of this <cite>WeightedL2NormSquared</cite> function)</p></li>
<li><p><strong>b</strong> (a <cite>DataContainer</cite> with the same shape as the intended domain of this <cite>WeightedL2NormSquared</cite> function) – A shift so that the function becomes  <span class="math notranslate nohighlight">\(F(x) = \| x-b\|_{W,2}^2 = \Sigma_iw_i(x_i-b_i)^2 = \langle x-b, W(x-b) \rangle = (x-b)^TW(x-b)\)</span></p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.WeightedL2NormSquared.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L2NormSquared/#WeightedL2NormSquared.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared.gradient" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of <span class="math notranslate nohighlight">\(F'(x) = 2Wx\)</span> or, if <cite>b</cite> is defined,  <span class="math notranslate nohighlight">\(F'(x) = 2W(x-b)\)</span>
where <span class="math notranslate nohighlight">\(W=\text{diag}(weight)\)</span> if <cite>weight</cite> is a <cite>DataContainer</cite> or <span class="math notranslate nohighlight">\(\text{weight}I\)</span> if <cite>weight</cite> is a scalar.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.WeightedL2NormSquared.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L2NormSquared/#WeightedL2NormSquared.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared.convex_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the convex conjugate of the WeightedL2NormSquared function at x.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.WeightedL2NormSquared.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared.L" title="Link to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.WeightedL2NormSquared.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared.centered_at" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.WeightedL2NormSquared.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L2NormSquared/#WeightedL2NormSquared.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared.proximal" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the proximal operator of the WeightedL2NormSquared function at x.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.WeightedL2NormSquared.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.WeightedL2NormSquared.proximal_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="least-squares">
<h3>Least Squares<a class="headerlink" href="#least-squares" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.LeastSquares">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">LeastSquares</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/LeastSquares/#LeastSquares"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.LeastSquares" title="Link to this definition">#</a></dt>
<dd><p>(Weighted) Least Squares function</p>
<div class="math notranslate nohighlight">
\[F(x) = c\|Ax-b\|_2^2\]</div>
<p>or if weighted</p>
<div class="math notranslate nohighlight">
\[F(x) = c\|Ax-b\|_{2,W}^{2}\]</div>
<p>where <span class="math notranslate nohighlight">\(W=\text{diag}(weight)\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<a class="reference internal" href="#cil.optimisation.operators.LinearOperator" title="cil.optimisation.operators.LinearOperator"><em>LinearOperator</em></a>)</p></li>
<li><p><strong>b</strong> (<em>Data</em><em>, </em><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>c</strong> (<em>Scaling Constant</em><em>, </em><em>float</em><em>, </em><em>default 1.0</em>)</p></li>
<li><p><strong>weight</strong> (<em>DataContainer with all positive elements</em><em> of </em><em>size</em><em> of </em><em>the range</em><em> of </em><em>operator A</em><em>, </em><em>default None</em>)</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>L is the  Lipshitz Constant of the gradient of <span class="math notranslate nohighlight">\(F\)</span> which is <span class="math notranslate nohighlight">\(2 c ||A||_2^2 = 2 c \sigma_1(A)^2\)</span>, or <span class="math notranslate nohighlight">\(2 c ||W|| ||A||_2^2 = 2c||W|| \sigma_1(A)^2\)</span>, where <span class="math notranslate nohighlight">\(\sigma_1(A)\)</span> is the largest singular value of <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(W=\text{diag}(weight)\)</span>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.LeastSquares.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/LeastSquares/#LeastSquares.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.LeastSquares.gradient" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of <span class="math notranslate nohighlight">\(F(x)\)</span>:</p>
<div class="math notranslate nohighlight">
\[F'(x) = 2cA^T(Ax-b)\]</div>
<p>or</p>
<div class="math notranslate nohighlight">
\[F'(x) = 2cA^T(W(Ax-b))\]</div>
<p>where <span class="math notranslate nohighlight">\(W=\text{diag}(weight)\)</span>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.LeastSquares.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.LeastSquares.L" title="Link to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.LeastSquares.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.LeastSquares.centered_at" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.LeastSquares.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.LeastSquares.convex_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Evaluation of the function F* at x, where F* is the convex conjugate of function F,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x}{\sup} \langle x^{*}, x \rangle - F(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the convex conjugate of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.LeastSquares.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.LeastSquares.proximal" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of function <span class="math notranslate nohighlight">\(\tau F\)</span>  evaluated at x</p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F}(x) = \underset{z}{\text{argmin}} \frac{1}{2}\|z - x\|^{2} + \tau F(z)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the proximal operator of the function at x with scalar <span class="math notranslate nohighlight">\(\tau\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.LeastSquares.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.LeastSquares.proximal_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="l1-sparsity">
<h3>L1 Sparsity<a class="headerlink" href="#l1-sparsity" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.L1Sparsity">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">L1Sparsity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L1Sparsity/#L1Sparsity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L1Sparsity" title="Link to this definition">#</a></dt>
<dd><p>L1Sparsity function</p>
<p>Calculates the following cases, depending on if the optional parameter <cite>weight</cite>  or data <cite>b</cite> is passed. For <cite>weight=None</cite>:</p>
<ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[F(x) = ||Qx||_{1}\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[F(x) = ||Qx - b||_{1}\]</div>
</li>
</ol>
<p>In the weighted case, <cite>weight</cite> = <span class="math notranslate nohighlight">\(w\)</span> is an array of non-negative weights.</p>
<ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[F(x) = ||Qx||_{L^1(w)}\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[F(x) = ||Qx - b||_{L^1(w)}\]</div>
</li>
</ol>
<p>with <span class="math notranslate nohighlight">\(||x||_{L^1(w)} = || x \cdot w||_1 = \sum_{i=1}^{n} |x_i| w_i\)</span>.</p>
<p>In all cases <span class="math notranslate nohighlight">\(Q\)</span> is an orthogonal operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<em>orthogonal Operator</em>) – Note that for the correct calculation of the proximal the provided operator must be orthogonal</p></li>
<li><p><strong>b</strong> (<em>Data</em><em>, </em><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>default is None</em>)</p></li>
<li><p><strong>weight</strong> (<em>array</em><em>, </em><em>optional</em><em>, </em><em>default=None</em>) – non-negative weight array matching the size of the range of operator <span class="math notranslate nohighlight">\(Q\)</span>.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.L1Sparsity.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L1Sparsity/#L1Sparsity.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L1Sparsity.convex_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the convex conjugate of the L1Sparsity function at x.
Here, we need to use the convex conjugate of L1Sparsity, which is the Indicator of the unit
<span class="math notranslate nohighlight">\(\ell^{\infty}\)</span> norm on the range of the (bijective) operator Q.</p>
<p>Consider the non-weighted case:</p>
<ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \mathbb{I}_{\{\|\cdot\|_{\infty}\leq1\}}(Qx^{*})\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \mathbb{I}_{\{\|\cdot\|_{\infty}\leq1\}}(Qx^{*}) + \langle Qx^{*},b\rangle\]</div>
</li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbb{I}_{\{\|\cdot\|_{\infty}\leq1\}}(x^{*})
= \begin{cases}
0, \mbox{if } \|x^{*}\|_{\infty}\leq1\\
\infty, \mbox{otherwise}
\end{cases}\end{split}\]</div>
<p>In the weighted case the convex conjugate is the indicator of the unit
<span class="math notranslate nohighlight">\(L^{\infty}( w^{-1} )\)</span> norm.</p>
<p>See:
<a class="reference external" href="https://math.stackexchange.com/questions/1533217/convex-conjugate-of-l1-norm-function-with-weight">https://math.stackexchange.com/questions/1533217/convex-conjugate-of-l1-norm-function-with-weight</a></p>
<ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \mathbb{I}_{\{\|\cdot\|_{L^\infty(w^{-1})}\leq 1\}}(Qx^{*})\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \mathbb{I}_{\{\|\cdot\|_{L^\infty(w^{-1})}\leq 1\}}(Qx^{*}) + \langle Qx^{*},b\rangle\]</div>
</li>
</ol>
<p>with <span class="math notranslate nohighlight">\(\|x\|_{L^\infty(w^{-1})} = \max_{i} \frac{|x_i|}{w_i}\)</span> and possible cases of 0 / 0 are defined to be 1.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.L1Sparsity.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L1Sparsity/#L1Sparsity.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.L1Sparsity.proximal" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the proximal operator of the L1 Norm function at x with scaling parameter <cite>tau</cite>.</p>
<p>Consider the following cases:</p>
<ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = Q^T \mathrm{ShinkOperator}_{\tau}(Qx)\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = Q^T \left( \mathrm{ShinkOperator}_\tau(Qx- b) + b \right)\]</div>
</li>
</ol>
<p>where,</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau | \cdot |}(x) = \mathrm{ShinkOperator}(x) = sgn(x) * \max\{ |x| - \tau, 0 \}\]</div>
<p>The weighted case follows from Example 6.23 in Chapter 6 of “First-Order Methods in Optimization”
by Amir Beck, SIAM 2017 <a class="reference external" href="https://archive.siam.org/books/mo25/mo25_ch6.pdf">https://archive.siam.org/books/mo25/mo25_ch6.pdf</a></p>
<ol class="loweralpha">
<li><div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = Q^T \mathrm{ShinkOperator}_{\tau*w}(Qx)\]</div>
</li>
<li><div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = Q^T \left( \mathrm{ShinkOperator}_{\tau*w}(Qx-b) + b \right)\]</div>
</li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>float</em><em>, </em><em>ndarray</em><em>, </em><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>, </em><em>default None</em>) – If not None, the result will be stored in this object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>The value of the proximal operator of the L1 norm function at x</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>DataContainer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.L1Sparsity.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.L1Sparsity.L" title="Link to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.L1Sparsity.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.L1Sparsity.centered_at" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.L1Sparsity.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.L1Sparsity.gradient" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of function <span class="math notranslate nohighlight">\(F\)</span>  evaluated at <span class="math notranslate nohighlight">\(x\)</span>, if it is differentiable</p>
<div class="math notranslate nohighlight">
\[F'(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a>, the value of the gradient of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.L1Sparsity.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.L1Sparsity.proximal_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="mixed-l21-norm">
<h3>Mixed L21 norm<a class="headerlink" href="#mixed-l21-norm" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.MixedL21Norm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">MixedL21Norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/MixedL21Norm/#MixedL21Norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm" title="Link to this definition">#</a></dt>
<dd><p>MixedL21Norm function: <span class="math notranslate nohighlight">\(F(x) = ||x||_{2,1} = \sum |x|_{2} = \sum \sqrt{ (x^{1})^{2} + (x^{2})^{2} + \dots}\)</span></p>
<p>where x is a BlockDataContainer, i.e., <span class="math notranslate nohighlight">\(x=(x^{1}, x^{2}, \dots)\)</span></p>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.MixedL21Norm.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/MixedL21Norm/#MixedL21Norm.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm.convex_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the convex conjugate of the MixedL21Norm function at x.</p>
<p>This is the Indicator function of <span class="math notranslate nohighlight">\(\mathbb{I}_{\{\|\cdot\|_{2,\infty}\leq1\}}(x^{*})\)</span>,</p>
<p>i.e.,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbb{I}_{\{\|\cdot\|_{2, \infty}\leq1\}}(x^{*})
= \begin{cases}
0, \mbox{if } \|x\|_{2, \infty}\leq1\\
\infty, \mbox{otherwise}
\end{cases}\end{split}\]</div>
<p>where,</p>
<div class="math notranslate nohighlight">
\[\|x\|_{2,\infty} = \max\{ \|x\|_{2} \} = \max\{ \sqrt{ (x^{1})^{2} + (x^{2})^{2} + \dots}\}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.MixedL21Norm.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/MixedL21Norm/#MixedL21Norm.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm.proximal" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the proximal operator of the MixedL21Norm function at x.</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \frac{x}{\|x\|_{2}}\max\{ \|x\|_{2} - \tau, 0 \}\]</div>
<p>where the convention 0 · (0/0) = 0 is used.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.MixedL21Norm.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm.L" title="Link to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.MixedL21Norm.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm.centered_at" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.MixedL21Norm.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm.gradient" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of function <span class="math notranslate nohighlight">\(F\)</span>  evaluated at <span class="math notranslate nohighlight">\(x\)</span>, if it is differentiable</p>
<div class="math notranslate nohighlight">
\[F'(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a>, the value of the gradient of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.MixedL21Norm.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.MixedL21Norm.proximal_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="smooth-mixed-l21-norm">
<h3>Smooth Mixed L21 norm<a class="headerlink" href="#smooth-mixed-l21-norm" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.SmoothMixedL21Norm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">SmoothMixedL21Norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">epsilon</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/MixedL21Norm/#SmoothMixedL21Norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SmoothMixedL21Norm" title="Link to this definition">#</a></dt>
<dd><p>SmoothMixedL21Norm function: <span class="math notranslate nohighlight">\(F(x) = ||x||_{2,1} = \sum |x|_{2} = \sum \sqrt{ (x^{1})^{2} + (x^{2})^{2} + \epsilon^2 + \dots}\)</span></p>
<p>where x is a BlockDataContainer, i.e., <span class="math notranslate nohighlight">\(x=(x^{1}, x^{2}, \dots)\)</span></p>
<p>Conjugate, proximal and proximal conjugate methods no closed-form solution</p>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SmoothMixedL21Norm.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/MixedL21Norm/#SmoothMixedL21Norm.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SmoothMixedL21Norm.gradient" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of the SmoothMixedL21Norm function at x.</p>
<p>frac{x}{<a href="#id62"><span class="problematic" id="id63">|x|</span></a>}</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.SmoothMixedL21Norm.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.SmoothMixedL21Norm.L" title="Link to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SmoothMixedL21Norm.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SmoothMixedL21Norm.centered_at" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SmoothMixedL21Norm.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SmoothMixedL21Norm.convex_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Evaluation of the function F* at x, where F* is the convex conjugate of function F,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x}{\sup} \langle x^{*}, x \rangle - F(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the convex conjugate of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SmoothMixedL21Norm.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SmoothMixedL21Norm.proximal" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of function <span class="math notranslate nohighlight">\(\tau F\)</span>  evaluated at x</p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F}(x) = \underset{z}{\text{argmin}} \frac{1}{2}\|z - x\|^{2} + \tau F(z)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the proximal operator of the function at x with scalar <span class="math notranslate nohighlight">\(\tau\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SmoothMixedL21Norm.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SmoothMixedL21Norm.proximal_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="mixed-l11-norm">
<h3>Mixed L11 norm<a class="headerlink" href="#mixed-l11-norm" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.MixedL11Norm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">MixedL11Norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L1Norm/#MixedL11Norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL11Norm" title="Link to this definition">#</a></dt>
<dd><p>MixedL11Norm function</p>
<div class="math notranslate nohighlight">
\[F(x) = ||x||_{1,1} = \sum |x_{1}| + |x_{2}| + \cdots + |x_{n}|\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>MixedL11Norm is a separable function, therefore it can also be defined using the <a class="reference internal" href="#cil.optimisation.functions.BlockFunction" title="cil.optimisation.functions.BlockFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockFunction</span></code></a>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#cil.optimisation.functions.L1Norm" title="cil.optimisation.functions.L1Norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">L1Norm</span></code></a>, <a class="reference internal" href="#cil.optimisation.functions.MixedL21Norm" title="cil.optimisation.functions.MixedL21Norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MixedL21Norm</span></code></a></p>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.MixedL11Norm.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.MixedL11Norm.L" title="Link to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.MixedL11Norm.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.MixedL11Norm.centered_at" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.MixedL11Norm.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.MixedL11Norm.convex_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Evaluation of the function F* at x, where F* is the convex conjugate of function F,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x}{\sup} \langle x^{*}, x \rangle - F(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the convex conjugate of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.MixedL11Norm.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.MixedL11Norm.gradient" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of function <span class="math notranslate nohighlight">\(F\)</span>  evaluated at <span class="math notranslate nohighlight">\(x\)</span>, if it is differentiable</p>
<div class="math notranslate nohighlight">
\[F'(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a>, the value of the gradient of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.MixedL11Norm.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/L1Norm/#MixedL11Norm.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.MixedL11Norm.proximal" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the proximal operator of the MixedL11Norm function at x.</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \mathrm{ShinkOperator}(x)\]</div>
<p>where,</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = \mathrm{ShinkOperator}(x) := sgn(x) * \max\{ |x| - \tau, 0 \}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.MixedL11Norm.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.MixedL11Norm.proximal_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="total-variation">
<h3>Total variation<a class="headerlink" href="#total-variation" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.TotalVariation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">TotalVariation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_iteration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">correlation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Space'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'c'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isotropic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strong_convexity_constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warm_start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/TotalVariation/#TotalVariation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation" title="Link to this definition">#</a></dt>
<dd><p>Total variation Function</p>
<div class="math notranslate nohighlight">
\[\mathrm{TV}(u) := \|\nabla u\|_{2,1} = \sum \|\nabla u\|_{2},\, (\mbox{isotropic})\]</div>
<div class="math notranslate nohighlight">
\[\mathrm{TV}(u) := \|\nabla u\|_{1,1} = \sum \|\nabla u\|_{1}\, (\mbox{anisotropic})\]</div>
<p class="rubric">Notes</p>
<p>The <code class="code docutils literal notranslate"><span class="pre">TotalVariation</span></code> (TV) <code class="code docutils literal notranslate"><span class="pre">Function</span></code> acts as a composite function, i.e.,
the composition of the <a class="reference internal" href="#cil.optimisation.functions.MixedL21Norm" title="cil.optimisation.functions.MixedL21Norm"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedL21Norm</span></code></a> function and the <a class="reference internal" href="#cil.optimisation.operators.GradientOperator" title="cil.optimisation.operators.GradientOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientOperator</span></code></a> operator,</p>
<div class="math notranslate nohighlight">
\[f(u) = \|u\|_{2,1}, \Rightarrow (f\circ\nabla)(u) = f(\nabla x) = \mathrm{TV}(u)\]</div>
<p>In that case, the proximal operator of TV does not have an exact solution and we use an iterative
algorithm to solve:</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau \mathrm{TV}}(b) := \underset{u}{\mathrm{argmin}} \frac{1}{2\tau}\|u - b\|^{2} + \mathrm{TV}(u)\]</div>
<p>The algorithm used for the proximal operator of TV is the Fast Gradient Projection algorithm (or FISTA)
applied to the _dual <a href="#id64"><span class="problematic" id="id65">problem_</span></a> of the above problem, see <span id="id17">[<a class="reference internal" href="#id55" title="Amir Beck and Marc Teboulle. A fast iterative shrinkage-thresholding algorithm for linear inverse problems. SIAM Journal on Imaging Sciences, 2(1):183-202, 2009. URL: https://doi.org/10.1137/080716542, arXiv:https://doi.org/10.1137/080716542, doi:10.1137/080716542.">1</a>]</span>, <span id="id18">[<a class="reference internal" href="#id54" title="Amir Beck and Marc Teboulle. Fast gradient-based algorithms for constrained total variation image denoising and deblurring problems. IEEE Transactions on Image Processing, 18(11):2419-2434, 2009. doi:10.1109/TIP.2009.2028250.">2</a>]</span>, <span id="id19">[<a class="reference internal" href="#id58" title="Mingqiang Zhu, Stephen J. Wright, and Tony F. Chan. Duality-based algorithms for total-variation-regularized image restoration. Computational Optimization and Applications, 47(3):377-400, Nov 2010. URL: https://doi.org/10.1007/s10589-008-9225-2, doi:10.1007/s10589-008-9225-2.">12</a>]</span>.</p>
<p>See also “Multicontrast MRI Reconstruction with Structure-Guided Total Variation”, Ehrhardt, Betcke, 2016.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>max_iteration</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, default = 5) – Maximum number of iterations for the FGP algorithm to solve to solve the dual problem
of the Total Variation Denoising problem (ROF). If warm_start=False, this should be around 100,
or larger, with a set tolerance.</p></li>
<li><p><strong>tolerance</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, default = None) – <p>Stopping criterion for the FGP algorithm used to to solve the dual problem
of the Total Variation Denoising problem (ROF). If the difference between iterates in the FGP algorithm is less than the tolerance
the iterations end before the max_iteration number.</p>
<div class="math notranslate nohighlight">
\[\|x^{k+1} - x^{k}\|_{2} &lt; \mathrm{tolerance}\]</div>
</p></li>
<li><p><strong>correlation</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>, default = <cite>Space</cite>) – Correlation between <cite>Space</cite> and/or <cite>SpaceChannels</cite> for the <a class="reference internal" href="#cil.optimisation.operators.GradientOperator" title="cil.optimisation.operators.GradientOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientOperator</span></code></a>.</p></li>
<li><p><strong>backend</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>, default = <cite>c</cite>) – Backend to compute the <a class="reference internal" href="#cil.optimisation.operators.GradientOperator" title="cil.optimisation.operators.GradientOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientOperator</span></code></a></p></li>
<li><p><strong>lower</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">'float</span></code>, default = None) – A constraint is enforced using the <a class="reference internal" href="#cil.optimisation.functions.IndicatorBox" title="cil.optimisation.functions.IndicatorBox"><code class="xref py py-class docutils literal notranslate"><span class="pre">IndicatorBox</span></code></a> function, e.g., <code class="code docutils literal notranslate"><span class="pre">IndicatorBox(lower,</span> <span class="pre">upper)</span></code>.</p></li>
<li><p><strong>upper</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">'float</span></code>, default = None) – A constraint is enforced using the <a class="reference internal" href="#cil.optimisation.functions.IndicatorBox" title="cil.optimisation.functions.IndicatorBox"><code class="xref py py-class docutils literal notranslate"><span class="pre">IndicatorBox</span></code></a> function, e.g., <code class="code docutils literal notranslate"><span class="pre">IndicatorBox(lower,</span> <span class="pre">upper)</span></code>.</p></li>
<li><p><strong>isotropic</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">boolean</span></code>, default = True) – <p>Use either isotropic or anisotropic definition of TV.</p>
<div class="math notranslate nohighlight">
\[|x|_{2} = \sqrt{x_{1}^{2} + x_{2}^{2}},\, (\mbox{isotropic})\]</div>
<div class="math notranslate nohighlight">
\[|x|_{1} = |x_{1}| + |x_{2}|\, (\mbox{anisotropic})\]</div>
</p></li>
<li><p><strong>split</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">boolean</span></code>, default = False) – Splits the Gradient into spatial gradient and spectral or temporal gradient for multichannel data.</p></li>
<li><p><strong>strong_convexity_constant</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, default = 0) – <p>A strongly convex term weighted by the <code class="code docutils literal notranslate"><span class="pre">strong_convexity_constant</span></code> (<span class="math notranslate nohighlight">\(\gamma\)</span>) parameter is added to the Total variation.
Now the <code class="code docutils literal notranslate"><span class="pre">TotalVariation</span></code> function is <span class="math notranslate nohighlight">\(\gamma\)</span> - strongly convex and the proximal operator is</p>
<div class="math notranslate nohighlight">
\[\underset{u}{\mathrm{argmin}} \frac{1}{2\tau}\|u - b\|^{2} + \mathrm{TV}(u) + \frac{\gamma}{2}\|u\|^{2} \Leftrightarrow\]</div>
<div class="math notranslate nohighlight">
\[\underset{u}{\mathrm{argmin}} \frac{1}{2\frac{\tau}{1+\gamma\tau}}\|u - \frac{b}{1+\gamma\tau}\|^{2} + \mathrm{TV}(u)\]</div>
</p></li>
<li><p><strong>warm_start</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">boolean</span></code>, default = True) – If set to true, the FGP algorithm used to solve the dual problem of the Total Variation Denoising problem (ROF) is initiated by the final value from the previous iteration and not at zero.
This allows the max_iteration value to be reduced to 5-10 iterations.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>With warm_start set to the default, True, the TV function will keep in memory the range of the gradient of the image to be denoised, i.e. N times the dimensionality of the image. This increases the memory requirements.
However, during the evaluation of <cite>proximal</cite> the memory requirements will be unchanged as the same amount of memory will need to be allocated and deallocated.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the case where the Total variation becomes a <span class="math notranslate nohighlight">\(\gamma\)</span> - strongly convex function, i.e.,</p>
<div class="math notranslate nohighlight">
\[\mathrm{TV}(u) + \frac{\gamma}{2}\|u\|^{2}\]</div>
<p><span class="math notranslate nohighlight">\(\gamma\)</span> should be relatively small, so as the second term above will not act as an additional regulariser.
For more information, see <span id="id20">[<a class="reference internal" href="#id56" title="Julian Rasch and Antonin Chambolle. Inexact first-order primal–dual algorithms. Computational Optimization and Applications, 76(2):381-430, Jun 2020. URL: https://doi.org/10.1007/s10589-020-00186-y, doi:10.1007/s10589-020-00186-y.">11</a>]</span>, <span id="id21">[<a class="reference internal" href="#id50" title="Antonin Chambolle and Thomas Pock. A first-order primal-dual algorithm for convex problems with applications to imaging. Journal of Mathematical Imaging and Vision, 40(1):120-145, May 2011. URL: https://doi.org/10.1007/s10851-010-0251-1, doi:10.1007/s10851-010-0251-1.">3</a>]</span>.</p>
</div>
<p class="rubric">Examples</p>
<div class="math notranslate nohighlight">
\[\underset{u}{\mathrm{argmin}} \frac{1}{2}\|u - b\|^{2} + \alpha\|\nabla u\|_{2,1}\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TV</span> <span class="o">=</span> <span class="n">TotalVariation</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">TV</span><span class="o">.</span><span class="n">proximal</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="math notranslate nohighlight">
\[\underset{u}{\mathrm{argmin}} \frac{1}{2}\|u - b\|^{2} + \alpha\|\nabla u\|_{1,1} + \mathbb{I}_{C}(u)\]</div>
<p>where <span class="math notranslate nohighlight">\(C = \{1.0\leq u\leq 2.0\}\)</span>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TV</span> <span class="o">=</span> <span class="n">TotalVariation</span><span class="p">(</span><span class="n">isotropic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">TV</span><span class="o">.</span><span class="n">proximal</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="math notranslate nohighlight">
\[\underset{u}{\mathrm{argmin}} \frac{1}{2}\|u - b\|^{2} + (\alpha\|\nabla u\|_{2,1} + \frac{\gamma}{2}\|u\|^{2})\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gamma</span> <span class="o">=</span> <span class="mf">1e-3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TV</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">TotalVariation</span><span class="p">(</span><span class="n">isotropic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">strong_convexity_constant</span><span class="o">=</span><span class="n">gamma</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">TV</span><span class="o">.</span><span class="n">proximal</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.TotalVariation.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/TotalVariation/#TotalVariation.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.proximal" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the TotalVariation function at <code class="code docutils literal notranslate"><span class="pre">x</span></code> .</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.TotalVariation.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/TotalVariation/#TotalVariation.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.convex_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of convex conjugate of the TotalVariation function at <code class="code docutils literal notranslate"><span class="pre">x</span></code> .</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.TotalVariation.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.L" title="Link to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.TotalVariation.calculate_Lipschitz">
<span class="sig-name descname"><span class="pre">calculate_Lipschitz</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/TotalVariation/#TotalVariation.calculate_Lipschitz"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.calculate_Lipschitz" title="Link to this definition">#</a></dt>
<dd><p>Default value for the Lipschitz constant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.TotalVariation.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.centered_at" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.TotalVariation.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.gradient" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of function <span class="math notranslate nohighlight">\(F\)</span>  evaluated at <span class="math notranslate nohighlight">\(x\)</span>, if it is differentiable</p>
<div class="math notranslate nohighlight">
\[F'(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a>, the value of the gradient of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.TotalVariation.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.proximal_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.TotalVariation.gradient_operator">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">gradient_operator</span></span><a class="headerlink" href="#cil.optimisation.functions.TotalVariation.gradient_operator" title="Link to this definition">#</a></dt>
<dd><p>GradientOperator is created if it is not instantiated yet. The domain of the <cite>_gradient</cite>,
is created in the <cite>__call__</cite> and <cite>proximal</cite> methods.</p>
</dd></dl>

</dd></dl>

</section>
<section id="approximate-gradient-base-class">
<h3>Approximate Gradient base class<a class="headerlink" href="#approximate-gradient-base-class" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.ApproximateGradientSumFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">ApproximateGradientSumFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">functions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampler</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/ApproximateGradientSumFunction/#ApproximateGradientSumFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ApproximateGradientSumFunction" title="Link to this definition">#</a></dt>
<dd><p>ApproximateGradientSumFunction represents the following sum</p>
<div class="math notranslate nohighlight">
\[\sum_{i=0}^{n-1} f_{i} = (f_{0} + f_{2} + ... + f_{n-1})\]</div>
<p>where there are <span class="math notranslate nohighlight">\(n\)</span> functions. This function class has two ways of calling gradient</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>full_gradient</cite> calculates the gradient of the sum <span class="math notranslate nohighlight">\(\sum_{i=0}^{n-1} \nabla f_{i}\)</span></p></li>
<li><p><cite>gradient</cite> calls an <cite>approximate_gradient</cite> function which may be less computationally expensive to calculate than the full gradient</p></li>
</ul>
</div></blockquote>
<p>This class is an abstract class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>functions</strong> (<cite>list</cite>  of functions) – A list of functions: <span class="math notranslate nohighlight">\([f_{0}, f_{2}, ..., f_{n-1}]\)</span>. Each function is assumed to be smooth with an implemented <a class="reference internal" href="#cil.optimisation.functions.Function.gradient" title="cil.optimisation.functions.Function.gradient"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient()</span></code></a> method. All functions must have the same domain. The number of functions (equivalently the length of the list) must be strictly greater than 1.</p></li>
<li><p><strong>sampler</strong> (An instance of a CIL Sampler class ( <code class="xref py py-meth docutils literal notranslate"><span class="pre">sampler()</span></code>) or of another class which has a <code class="code docutils literal notranslate"><span class="pre">__next__</span></code> function implemented to output integers in <span class="math notranslate nohighlight">\({0,...,n-1}\)</span>.) – This sampler is called each time <code class="code docutils literal notranslate"><span class="pre">gradient</span></code> is called and sets the internal <code class="code docutils literal notranslate"><span class="pre">function_num</span></code> passed to the <code class="code docutils literal notranslate"><span class="pre">approximate_gradient</span></code> function.  Default is <code class="code docutils literal notranslate"><span class="pre">Sampler.random_with_replacement(len(functions))</span></code>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We ensure that the approximate gradient is of a similar order of magnitude to the full gradient calculation. For example, in the <code class="code docutils literal notranslate"><span class="pre">SGFunction</span></code> we approximate the full gradient by <span class="math notranslate nohighlight">\(n\nabla f_i\)</span> for an index <span class="math notranslate nohighlight">\(i\)</span> given by the sampler.
The multiplication by <span class="math notranslate nohighlight">\(n\)</span> is a choice to more easily allow comparisons between stochastic and non-stochastic methods and between stochastic methods with varying numbers of subsets.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Each time <code class="code docutils literal notranslate"><span class="pre">gradient</span></code> is called the class keeps track of which functions have been used to calculate the gradient. This may be useful for debugging or plotting after using this function in an iterative algorithm.</p>
<blockquote>
<div><ul class="simple">
<li><p>The property <code class="code docutils literal notranslate"><span class="pre">data_passes_indices</span></code> is a list of lists holding the indices of the functions that are processed in each call of <cite>gradient</cite>. This list is updated each time <cite>gradient</cite> is called by appending a list of the indices of the functions used to calculate the gradient.</p></li>
<li><p>The property <code class="code docutils literal notranslate"><span class="pre">data_passes</span></code> is a list of floats that holds the amount of data that has been processed up until each call of <cite>gradient</cite>. This list is updated each time <cite>gradient</cite> is called by appending the proportion of the data used when calculating the approximate gradient since the class was initialised (a full gradient calculation would be 1 full data pass). Warning: if your functions do not contain an equal <cite>amount</cite> of data, for example your data was not partitioned into equal batches, then you must first use the <a href="#id22"><span class="problematic" id="id23">`</span></a>set_data_partition_weights” function for this to be accurate.</p></li>
</ul>
</div></blockquote>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <a class="reference internal" href="#cil.optimisation.functions.ApproximateGradientSumFunction.gradient" title="cil.optimisation.functions.ApproximateGradientSumFunction.gradient"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gradient()</span></code></a> returns the approximate gradient depending on an index provided by the  <code class="code docutils literal notranslate"><span class="pre">sampler</span></code> method.</p>
</div>
<p class="rubric">Example</p>
<p>This class is an abstract base class, so we give an example using the SGFunction child class.</p>
<p>Consider the objective is to minimise:</p>
<div class="math notranslate nohighlight">
\[\sum_{i=0}^{n-1} f_{i}(x) = \sum_{i=0}^{n-1}\|A_{i} x - b_{i}\|^{2}\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">list_of_functions</span> <span class="o">=</span> <span class="p">[</span><span class="n">LeastSquares</span><span class="p">(</span><span class="n">Ai</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">bi</span><span class="p">)]</span> <span class="k">for</span> <span class="n">Ai</span><span class="p">,</span><span class="n">bi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">A_subsets</span><span class="p">,</span> <span class="n">b_subsets</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">ApproximateGradientSumFunction</span><span class="p">(</span><span class="n">list_of_functions</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">list_of_functions</span> <span class="o">=</span> <span class="p">[</span><span class="n">LeastSquares</span><span class="p">(</span><span class="n">Ai</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">bi</span><span class="p">)]</span> <span class="k">for</span> <span class="n">Ai</span><span class="p">,</span><span class="n">bi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">A_subsets</span><span class="p">,</span> <span class="n">b_subsets</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">sequential</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">list_of_functions</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">SGFunction</span><span class="p">(</span><span class="n">list_of_functions</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span><span class="n">sampler</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">full_gradient</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">This will return :math:`\sum_{i=0}^{n-1} \nabla f_{i}(x)`</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">As per the approximate gradient implementation in the SGFunction this will return :math:`\nabla f_{0}`. The choice of the `0` index is because we chose a `sequential` sampler and this is the first time we called `gradient`.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">This will return :math:`\nabla f_{1}` because we chose  a `sequential` sampler and this is the second time we called `gradient`.</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ApproximateGradientSumFunction.full_gradient">
<span class="sig-name descname"><span class="pre">full_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/ApproximateGradientSumFunction/#ApproximateGradientSumFunction.full_gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ApproximateGradientSumFunction.full_gradient" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the  full gradient of the sum of functions at <span class="math notranslate nohighlight">\(x\)</span>.</p>
<div class="math notranslate nohighlight">
\[\nabla_x(f_{0} + f_{1} + ... + f_{n-1})(x) = \nabla_xf_{0}(x) + \nabla_xf_{1}(x) + ... + \nabla_xf_{n-1}(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (return DataContainer, if <cite>None</cite> a new DataContainer is returned, default <cite>None</cite>.)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the gradient of the sum function at x or nothing if <cite>out</cite></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ApproximateGradientSumFunction.approximate_gradient">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">approximate_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function_num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/ApproximateGradientSumFunction/#ApproximateGradientSumFunction.approximate_gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ApproximateGradientSumFunction.approximate_gradient" title="Link to this definition">#</a></dt>
<dd><p>Returns the approximate gradient at a given point <code class="code docutils literal notranslate"><span class="pre">x</span></code> given a <cite>function_number</cite> in {0,…,len(functions)-1}.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (return DataContainer, if <cite>None</cite> a new DataContainer is returned, default <cite>None</cite>.)</p></li>
<li><p><strong>function_num</strong> (<cite>int</cite>) – Between 0 and the number of functions in the list</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the value of the approximate gradient of the sum function at <code class="code docutils literal notranslate"><span class="pre">x</span></code> given a <cite>function_number</cite> in {0,…,len(functions)-1}</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ApproximateGradientSumFunction.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/ApproximateGradientSumFunction/#ApproximateGradientSumFunction.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ApproximateGradientSumFunction.gradient" title="Link to this definition">#</a></dt>
<dd><p>Selects a random function using the <cite>sampler</cite> and then calls the approximate gradient at <code class="code docutils literal notranslate"><span class="pre">x</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (return DataContainer, if <cite>None</cite> a new DataContainer is returned, default <cite>None</cite>.)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the value of the approximate gradient of the sum function at <code class="code docutils literal notranslate"><span class="pre">x</span></code></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ApproximateGradientSumFunction.set_data_partition_weights">
<span class="sig-name descname"><span class="pre">set_data_partition_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/ApproximateGradientSumFunction/#ApproximateGradientSumFunction.set_data_partition_weights"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.ApproximateGradientSumFunction.set_data_partition_weights" title="Link to this definition">#</a></dt>
<dd><p>Setter for the partition weights used to calculate the data passes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>weights</strong> (<em>list</em><em> of </em><em>positive floats that sum to one.</em>) – The proportion of the data held in each function. Equivalent to the proportions that you partitioned your data into.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.ApproximateGradientSumFunction.data_passes_indices">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">data_passes_indices</span></span><a class="headerlink" href="#cil.optimisation.functions.ApproximateGradientSumFunction.data_passes_indices" title="Link to this definition">#</a></dt>
<dd><p>The property <code class="code docutils literal notranslate"><span class="pre">data_passes_indices</span></code> is a list of lists holding the indices of the functions that are processed in each call of <cite>gradient</cite>. This list is updated each time <cite>gradient</cite> is called by appending a list of the indices of the functions used to calculate the gradient.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.ApproximateGradientSumFunction.data_passes">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">data_passes</span></span><a class="headerlink" href="#cil.optimisation.functions.ApproximateGradientSumFunction.data_passes" title="Link to this definition">#</a></dt>
<dd><p>The property <code class="code docutils literal notranslate"><span class="pre">data_passes</span></code> is a list of floats that holds the amount of data that has been processed up until each call of <cite>gradient</cite>.
This list is updated each time <cite>gradient</cite> is called by appending the proportion of the data used when calculating the approximate gradient since the class was initialised (a full gradient calculation would be 1 full data pass).
Note that if your functions do not contain an equal <cite>amount</cite> of data, for example your data was not partitioned into equal batches, then you must first use the <cite>set_data_partition_weights</cite> function for this to be accurate.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.ApproximateGradientSumFunction.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.ApproximateGradientSumFunction.L" title="Link to this definition">#</a></dt>
<dd><p>Returns the Lipschitz constant for the SumFunction</p>
<div class="math notranslate nohighlight">
\[L = \sum_{i} L_{i}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{i}\)</span> is the Lipschitz constant of the smooth function <span class="math notranslate nohighlight">\(F_{i}\)</span>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.ApproximateGradientSumFunction.Lmax">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Lmax</span></span><a class="headerlink" href="#cil.optimisation.functions.ApproximateGradientSumFunction.Lmax" title="Link to this definition">#</a></dt>
<dd><p>Returns the maximum Lipschitz constant for the SumFunction</p>
<div class="math notranslate nohighlight">
\[L = \max_{i}\{L_{i}\}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{i}\)</span> is the Lipschitz constant of the smooth function <span class="math notranslate nohighlight">\(F_{i}\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ApproximateGradientSumFunction.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.ApproximateGradientSumFunction.centered_at" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ApproximateGradientSumFunction.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.ApproximateGradientSumFunction.convex_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Evaluation of the function F* at x, where F* is the convex conjugate of function F,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x}{\sup} \langle x^{*}, x \rangle - F(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the convex conjugate of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ApproximateGradientSumFunction.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.ApproximateGradientSumFunction.proximal" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of function <span class="math notranslate nohighlight">\(\tau F\)</span>  evaluated at x</p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F}(x) = \underset{z}{\text{argmin}} \frac{1}{2}\|z - x\|^{2} + \tau F(z)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the proximal operator of the function at x with scalar <span class="math notranslate nohighlight">\(\tau\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.ApproximateGradientSumFunction.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.ApproximateGradientSumFunction.proximal_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="stochastic-gradient-function">
<h3>Stochastic Gradient function<a class="headerlink" href="#stochastic-gradient-function" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.SGFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">SGFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">functions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampler</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/SGFunction/#SGFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SGFunction" title="Link to this definition">#</a></dt>
<dd><p>Stochastic gradient function, a child class of <code class="code docutils literal notranslate"><span class="pre">ApproximateGradientSumFunction</span></code>, which defines from a list of functions, <span class="math notranslate nohighlight">\({f_0,...,f_{n-1}}\)</span> a <cite>SumFunction</cite>, <span class="math notranslate nohighlight">\(f_0+...+f_{n-1}\)</span> where each time the <cite>gradient</cite> is called, the <code class="code docutils literal notranslate"><span class="pre">sampler</span></code> provides an index, <span class="math notranslate nohighlight">\(i \in {0,...,n-1}\)</span>
and the <code class="code docutils literal notranslate"><span class="pre">gradient</span></code> method returns the approximate gradient <span class="math notranslate nohighlight">\(n \nabla_x f_i(x)\)</span>. This can be used with the <code class="code docutils literal notranslate"><span class="pre">cil.optimisation.algorithms</span></code> algorithm <code class="code docutils literal notranslate"><span class="pre">GD</span></code> to give a stochastic gradient descent algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>functions</strong> (<cite>list</cite>  of functions) – A list of functions: <code class="code docutils literal notranslate"><span class="pre">[f_{0},</span> <span class="pre">f_{1},</span> <span class="pre">...,</span> <span class="pre">f_{n-1}]</span></code>. Each function is assumed to be smooth with an implemented <a class="reference internal" href="#cil.optimisation.functions.Function.gradient" title="cil.optimisation.functions.Function.gradient"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient()</span></code></a> method. Although CIL does not define a domain of a <code class="code docutils literal notranslate"><span class="pre">Function</span></code>, all functions are supposed to have the same domain. The number of functions must be strictly greater than 1.</p></li>
<li><p><strong>sampler</strong> (An instance of a CIL Sampler class ( <code class="xref py py-meth docutils literal notranslate"><span class="pre">sampler()</span></code>) or of another class which has a <code class="code docutils literal notranslate"><span class="pre">__next__</span></code> function implemented to output integers in {0,…,n-1}.) – This sampler is called each time gradient is called and  sets the internal <code class="code docutils literal notranslate"><span class="pre">function_num</span></code> passed to the <code class="code docutils literal notranslate"><span class="pre">approximate_gradient</span></code> function.  Default is <code class="code docutils literal notranslate"><span class="pre">Sampler.random_with_replacement(len(functions))</span></code>.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SGFunction.approximate_gradient">
<span class="sig-name descname"><span class="pre">approximate_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function_num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/SGFunction/#SGFunction.approximate_gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SGFunction.approximate_gradient" title="Link to this definition">#</a></dt>
<dd><p>Returns the gradient of the function at index <cite>function_num</cite> at <code class="code docutils literal notranslate"><span class="pre">x</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (return DataContainer, if <cite>None</cite> a new DataContainer is returned, default <cite>None</cite>.)</p></li>
<li><p><strong>function_num</strong> (<cite>int</cite>) – Between 0 and the number of functions in the list</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the value of the approximate gradient of the sum function at <code class="code docutils literal notranslate"><span class="pre">x</span></code> given a <cite>function_number</cite> in {0,…,len(functions)-1}</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.SGFunction.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.SGFunction.L" title="Link to this definition">#</a></dt>
<dd><p>Returns the Lipschitz constant for the SumFunction</p>
<div class="math notranslate nohighlight">
\[L = \sum_{i} L_{i}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{i}\)</span> is the Lipschitz constant of the smooth function <span class="math notranslate nohighlight">\(F_{i}\)</span>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.SGFunction.Lmax">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Lmax</span></span><a class="headerlink" href="#cil.optimisation.functions.SGFunction.Lmax" title="Link to this definition">#</a></dt>
<dd><p>Returns the maximum Lipschitz constant for the SumFunction</p>
<div class="math notranslate nohighlight">
\[L = \max_{i}\{L_{i}\}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{i}\)</span> is the Lipschitz constant of the smooth function <span class="math notranslate nohighlight">\(F_{i}\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SGFunction.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SGFunction.centered_at" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SGFunction.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SGFunction.convex_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Evaluation of the function F* at x, where F* is the convex conjugate of function F,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x}{\sup} \langle x^{*}, x \rangle - F(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the convex conjugate of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.SGFunction.data_passes">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">data_passes</span></span><a class="headerlink" href="#cil.optimisation.functions.SGFunction.data_passes" title="Link to this definition">#</a></dt>
<dd><p>The property <code class="code docutils literal notranslate"><span class="pre">data_passes</span></code> is a list of floats that holds the amount of data that has been processed up until each call of <cite>gradient</cite>.
This list is updated each time <cite>gradient</cite> is called by appending the proportion of the data used when calculating the approximate gradient since the class was initialised (a full gradient calculation would be 1 full data pass).
Note that if your functions do not contain an equal <cite>amount</cite> of data, for example your data was not partitioned into equal batches, then you must first use the <cite>set_data_partition_weights</cite> function for this to be accurate.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.SGFunction.data_passes_indices">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">data_passes_indices</span></span><a class="headerlink" href="#cil.optimisation.functions.SGFunction.data_passes_indices" title="Link to this definition">#</a></dt>
<dd><p>The property <code class="code docutils literal notranslate"><span class="pre">data_passes_indices</span></code> is a list of lists holding the indices of the functions that are processed in each call of <cite>gradient</cite>. This list is updated each time <cite>gradient</cite> is called by appending a list of the indices of the functions used to calculate the gradient.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SGFunction.full_gradient">
<span class="sig-name descname"><span class="pre">full_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SGFunction.full_gradient" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the  full gradient of the sum of functions at <span class="math notranslate nohighlight">\(x\)</span>.</p>
<div class="math notranslate nohighlight">
\[\nabla_x(f_{0} + f_{1} + ... + f_{n-1})(x) = \nabla_xf_{0}(x) + \nabla_xf_{1}(x) + ... + \nabla_xf_{n-1}(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (return DataContainer, if <cite>None</cite> a new DataContainer is returned, default <cite>None</cite>.)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the gradient of the sum function at x or nothing if <cite>out</cite></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SGFunction.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SGFunction.gradient" title="Link to this definition">#</a></dt>
<dd><p>Selects a random function using the <cite>sampler</cite> and then calls the approximate gradient at <code class="code docutils literal notranslate"><span class="pre">x</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (return DataContainer, if <cite>None</cite> a new DataContainer is returned, default <cite>None</cite>.)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the value of the approximate gradient of the sum function at <code class="code docutils literal notranslate"><span class="pre">x</span></code></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SGFunction.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SGFunction.proximal" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of function <span class="math notranslate nohighlight">\(\tau F\)</span>  evaluated at x</p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F}(x) = \underset{z}{\text{argmin}} \frac{1}{2}\|z - x\|^{2} + \tau F(z)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the proximal operator of the function at x with scalar <span class="math notranslate nohighlight">\(\tau\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SGFunction.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SGFunction.proximal_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SGFunction.set_data_partition_weights">
<span class="sig-name descname"><span class="pre">set_data_partition_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SGFunction.set_data_partition_weights" title="Link to this definition">#</a></dt>
<dd><p>Setter for the partition weights used to calculate the data passes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>weights</strong> (<em>list</em><em> of </em><em>positive floats that sum to one.</em>) – The proportion of the data held in each function. Equivalent to the proportions that you partitioned your data into.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="sag-function">
<h3>SAG function<a class="headerlink" href="#sag-function" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.SAGFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">SAGFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">functions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampler</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/SAGFunction/#SAGFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SAGFunction" title="Link to this definition">#</a></dt>
<dd><p>The stochastic average gradient (SAG) function takes a index <span class="math notranslate nohighlight">\(i_k\)</span> and calculates the approximate gradient of <span class="math notranslate nohighlight">\(\sum_{i=0}^{n-1}f_i\)</span> at iteration <span class="math notranslate nohighlight">\(x_k\)</span> as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\sum_{i=0}^{n-1} g_i^k \qquad \text{where} \qquad g_i^k= \begin{cases}
                                                            \nabla f_i(x_k), \text{ if } i=i_k\\
                                                            g_i^{k-1},\text{ otherwise }
                                                            \end{cases}\end{split}\]</div>
<p>The idea is that by incorporating a memory of previous gradient values the SAG method can achieve a faster convergence rate than black-box stochastic gradient methods.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Compared with the literature, we do not divide by <span class="math notranslate nohighlight">\(n\)</span>, the number of functions, so that we return an approximate gradient of the whole sum function and not an average gradient.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Reference: Schmidt, M., Le Roux, N. and Bach, F., 2017. Minimizing finite sums with the stochastic average gradient. Mathematical Programming, 162, pp.83-112. <a class="reference external" href="https://doi.org/10.1007/s10107-016-1030-6">https://doi.org/10.1007/s10107-016-1030-6</a>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>functions</strong> (<cite>list</cite>  of functions) – A list of functions: <span class="math notranslate nohighlight">\(f_{0}, f_{1}, ..., f_{n-1}\)</span>. Each function is assumed to be smooth with an implemented <a class="reference internal" href="#cil.optimisation.functions.Function.gradient" title="cil.optimisation.functions.Function.gradient"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient()</span></code></a> method. All functions must have the same domain. The number of functions (equivalently the length of the list <cite>n</cite>) must be strictly greater than 1.</p></li>
<li><p><strong>sampler</strong> (An instance of a CIL Sampler class ( <code class="xref py py-meth docutils literal notranslate"><span class="pre">sampler()</span></code>) or of another class which has a <cite>next</cite> function implemented to output integers in <span class="math notranslate nohighlight">\({0,...,n-1}\)</span>.) – This sampler is called each time <cite>gradient</cite> is called and sets the internal <cite>function_num</cite> passed to the <cite>approximate_gradient</cite> function.  Default is <cite>Sampler.random_with_replacement(len(functions))</cite>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The user has the option of calling the class method <cite>warm_start_approximate_gradients</cite> after initialising this class. This will compute and store the gradient for each function at an initial point, equivalently setting <span class="math notranslate nohighlight">\(g_i^0=\nabla f_i(x_0)\)</span> for initial point <span class="math notranslate nohighlight">\(x_0\)</span>.  If this method is not called, the gradients are initialised with zeros.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function’s memory requirements are <cite>n + 3</cite> times the image space, that is with 100 subsets the memory requirement is 103 images, which is huge.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SAGFunction.approximate_gradient">
<span class="sig-name descname"><span class="pre">approximate_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function_num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/SAGFunction/#SAGFunction.approximate_gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SAGFunction.approximate_gradient" title="Link to this definition">#</a></dt>
<dd><p>SAG approximate gradient, calculated at the point <span class="math notranslate nohighlight">\(x\)</span> and updated using the function index given by <cite>function_num</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> (</em><em>e.g. ImageData object</em><em>)</em>) – Element in the domain of the <cite>functions</cite></p></li>
<li><p><strong>function_num</strong> (<cite>int</cite>) – Between 0 and the number of functions in the list</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SAGFunction.warm_start_approximate_gradients">
<span class="sig-name descname"><span class="pre">warm_start_approximate_gradients</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/SAGFunction/#SAGFunction.warm_start_approximate_gradients"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SAGFunction.warm_start_approximate_gradients" title="Link to this definition">#</a></dt>
<dd><p>A function to warm start SAG or SAGA algorithms by initialising all the gradients at an initial point. Equivalently setting <span class="math notranslate nohighlight">\(g_i^0 = \nabla f_i(x_0)\)</span> for initial point <span class="math notranslate nohighlight">\(x_0\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>initial</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>,</em>) – The initial point to warmstart the calculation</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When using SAG or SAGA with a deterministic algorithm, you should warm start the SAG-SAGA Function with the same initial point that you initialise the algorithm</p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.SAGFunction.data_passes_indices">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">data_passes_indices</span></span><a class="headerlink" href="#cil.optimisation.functions.SAGFunction.data_passes_indices" title="Link to this definition">#</a></dt>
<dd><p>The property <code class="code docutils literal notranslate"><span class="pre">data_passes_indices</span></code> is a list of lists holding the indices of the functions that are processed in each call of <cite>gradient</cite>. This list is updated each time <cite>gradient</cite> is called by appending a list of the indices of the functions used to calculate the gradient.
This is overwritten from the base class to first check to see if the approximate gradient was warm started and, if it was, ensure that the first element of <cite>data_passes_indices</cite> contains each index used to warm start and the index used in the first call to <cite>gradient</cite>. Thus the length of <cite>data_passes_indices</cite> is always equal to the number of calls to <cite>gradient</cite>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.SAGFunction.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.SAGFunction.L" title="Link to this definition">#</a></dt>
<dd><p>Returns the Lipschitz constant for the SumFunction</p>
<div class="math notranslate nohighlight">
\[L = \sum_{i} L_{i}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{i}\)</span> is the Lipschitz constant of the smooth function <span class="math notranslate nohighlight">\(F_{i}\)</span>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.SAGFunction.Lmax">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Lmax</span></span><a class="headerlink" href="#cil.optimisation.functions.SAGFunction.Lmax" title="Link to this definition">#</a></dt>
<dd><p>Returns the maximum Lipschitz constant for the SumFunction</p>
<div class="math notranslate nohighlight">
\[L = \max_{i}\{L_{i}\}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{i}\)</span> is the Lipschitz constant of the smooth function <span class="math notranslate nohighlight">\(F_{i}\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SAGFunction.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SAGFunction.centered_at" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SAGFunction.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SAGFunction.convex_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Evaluation of the function F* at x, where F* is the convex conjugate of function F,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x}{\sup} \langle x^{*}, x \rangle - F(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the convex conjugate of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.SAGFunction.data_passes">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">data_passes</span></span><a class="headerlink" href="#cil.optimisation.functions.SAGFunction.data_passes" title="Link to this definition">#</a></dt>
<dd><p>The property <code class="code docutils literal notranslate"><span class="pre">data_passes</span></code> is a list of floats that holds the amount of data that has been processed up until each call of <cite>gradient</cite>.
This list is updated each time <cite>gradient</cite> is called by appending the proportion of the data used when calculating the approximate gradient since the class was initialised (a full gradient calculation would be 1 full data pass).
Note that if your functions do not contain an equal <cite>amount</cite> of data, for example your data was not partitioned into equal batches, then you must first use the <cite>set_data_partition_weights</cite> function for this to be accurate.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SAGFunction.full_gradient">
<span class="sig-name descname"><span class="pre">full_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SAGFunction.full_gradient" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the  full gradient of the sum of functions at <span class="math notranslate nohighlight">\(x\)</span>.</p>
<div class="math notranslate nohighlight">
\[\nabla_x(f_{0} + f_{1} + ... + f_{n-1})(x) = \nabla_xf_{0}(x) + \nabla_xf_{1}(x) + ... + \nabla_xf_{n-1}(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (return DataContainer, if <cite>None</cite> a new DataContainer is returned, default <cite>None</cite>.)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the gradient of the sum function at x or nothing if <cite>out</cite></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SAGFunction.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SAGFunction.gradient" title="Link to this definition">#</a></dt>
<dd><p>Selects a random function using the <cite>sampler</cite> and then calls the approximate gradient at <code class="code docutils literal notranslate"><span class="pre">x</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (return DataContainer, if <cite>None</cite> a new DataContainer is returned, default <cite>None</cite>.)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the value of the approximate gradient of the sum function at <code class="code docutils literal notranslate"><span class="pre">x</span></code></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SAGFunction.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SAGFunction.proximal" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of function <span class="math notranslate nohighlight">\(\tau F\)</span>  evaluated at x</p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F}(x) = \underset{z}{\text{argmin}} \frac{1}{2}\|z - x\|^{2} + \tau F(z)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the proximal operator of the function at x with scalar <span class="math notranslate nohighlight">\(\tau\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SAGFunction.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SAGFunction.proximal_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SAGFunction.set_data_partition_weights">
<span class="sig-name descname"><span class="pre">set_data_partition_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SAGFunction.set_data_partition_weights" title="Link to this definition">#</a></dt>
<dd><p>Setter for the partition weights used to calculate the data passes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>weights</strong> (<em>list</em><em> of </em><em>positive floats that sum to one.</em>) – The proportion of the data held in each function. Equivalent to the proportions that you partitioned your data into.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="saga-function">
<h3>SAGA function<a class="headerlink" href="#saga-function" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.SAGAFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">SAGAFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">functions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampler</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/SAGFunction/#SAGAFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SAGAFunction" title="Link to this definition">#</a></dt>
<dd><p>SAGA (SAG-Ameliore) is an accelerated version of the stochastic average gradient (SAG) function which takes a index <span class="math notranslate nohighlight">\(i_k\)</span> and calculates the approximate gradient of <span class="math notranslate nohighlight">\(\sum_{i=0}^{n-1}f_i\)</span> at iteration <span class="math notranslate nohighlight">\(x_k\)</span> as</p>
<div class="math notranslate nohighlight">
\[\begin{split}n\left(g_{i_k}^{k}-g_{i_k}^{k-1}\right)+\sum_{i=0}^{n-1} g_i^{k-1} \qquad \text{where} \qquad g_i^k= \begin{cases}
                                                           \nabla f_i(x_k), \text{ if } i=i_k\\
                                                           g_i^{k-1},\text{ otherwise}
                                                           \end{cases}\end{split}\]</div>
<p>SAGA improves on the theory behind SAG and SVRG, with better theoretical convergence rates. Compared to SAG it is an unbiased estimator.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Compared with the literature, we do not divide by <span class="math notranslate nohighlight">\(n\)</span>, the number of functions, so that we return an approximate gradient of the whole sum function and not an average gradient.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function’s memory requirements are <cite>n + 3</cite> times the image space, that is with 100 subsets the memory requirement is 103 images, which is huge.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Reference: Defazio, A., Bach, F. and Lacoste-Julien, S., 2014. SAGA: A fast incremental gradient method with support for non-strongly convex composite objectives. Advances in neural information processing systems, 27. <a class="reference external" href="https://proceedings.neurips.cc/paper_files/paper/2014/file/ede7e2b6d13a41ddf9f4bdef84fdc737-Paper.pdf">https://proceedings.neurips.cc/paper_files/paper/2014/file/ede7e2b6d13a41ddf9f4bdef84fdc737-Paper.pdf</a></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>functions</strong> (<cite>list</cite>  of functions) – A list of functions: <code class="code docutils literal notranslate"><span class="pre">[f_{0},</span> <span class="pre">f_{1},</span> <span class="pre">...,</span> <span class="pre">f_{n-1}]</span></code>. Each function is assumed to be smooth function with an implemented <a class="reference internal" href="#cil.optimisation.functions.Function.gradient" title="cil.optimisation.functions.Function.gradient"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient()</span></code></a> method. Each function must have the same domain. The number of functions must be strictly greater than 1.</p></li>
<li><p><strong>sampler</strong> (An instance of one of the <code class="xref py py-meth docutils literal notranslate"><span class="pre">sampler()</span></code> classes which has a <cite>next</cite> function implemented and a <cite>num_indices</cite> property.) – This sampler is called each time gradient is called and  sets the internal <cite>function_num</cite> passed to the <cite>approximate_gradient</cite> function.  The <cite>num_indices</cite> must match the number of functions provided. Default is <cite>Sampler.random_with_replacement(len(functions))</cite>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The user has the option of calling the class method <cite>warm_start_approximate_gradients</cite> after initialising this class. This will compute and store the gradient for each function at an initial point, equivalently setting <span class="math notranslate nohighlight">\(g_i^0=\nabla f_i(x_0)\)</span> for initial point <span class="math notranslate nohighlight">\(x_0\)</span>. If this method is not called, the gradients are initialised with zeros.</p>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.SAGAFunction.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.SAGAFunction.L" title="Link to this definition">#</a></dt>
<dd><p>Returns the Lipschitz constant for the SumFunction</p>
<div class="math notranslate nohighlight">
\[L = \sum_{i} L_{i}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{i}\)</span> is the Lipschitz constant of the smooth function <span class="math notranslate nohighlight">\(F_{i}\)</span>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.SAGAFunction.Lmax">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Lmax</span></span><a class="headerlink" href="#cil.optimisation.functions.SAGAFunction.Lmax" title="Link to this definition">#</a></dt>
<dd><p>Returns the maximum Lipschitz constant for the SumFunction</p>
<div class="math notranslate nohighlight">
\[L = \max_{i}\{L_{i}\}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{i}\)</span> is the Lipschitz constant of the smooth function <span class="math notranslate nohighlight">\(F_{i}\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SAGAFunction.approximate_gradient">
<span class="sig-name descname"><span class="pre">approximate_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function_num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SAGAFunction.approximate_gradient" title="Link to this definition">#</a></dt>
<dd><p>SAG approximate gradient, calculated at the point <span class="math notranslate nohighlight">\(x\)</span> and updated using the function index given by <cite>function_num</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> (</em><em>e.g. ImageData object</em><em>)</em>) – Element in the domain of the <cite>functions</cite></p></li>
<li><p><strong>function_num</strong> (<cite>int</cite>) – Between 0 and the number of functions in the list</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SAGAFunction.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SAGAFunction.centered_at" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SAGAFunction.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SAGAFunction.convex_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Evaluation of the function F* at x, where F* is the convex conjugate of function F,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x}{\sup} \langle x^{*}, x \rangle - F(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the convex conjugate of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.SAGAFunction.data_passes">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">data_passes</span></span><a class="headerlink" href="#cil.optimisation.functions.SAGAFunction.data_passes" title="Link to this definition">#</a></dt>
<dd><p>The property <code class="code docutils literal notranslate"><span class="pre">data_passes</span></code> is a list of floats that holds the amount of data that has been processed up until each call of <cite>gradient</cite>.
This list is updated each time <cite>gradient</cite> is called by appending the proportion of the data used when calculating the approximate gradient since the class was initialised (a full gradient calculation would be 1 full data pass).
Note that if your functions do not contain an equal <cite>amount</cite> of data, for example your data was not partitioned into equal batches, then you must first use the <cite>set_data_partition_weights</cite> function for this to be accurate.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.SAGAFunction.data_passes_indices">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">data_passes_indices</span></span><a class="headerlink" href="#cil.optimisation.functions.SAGAFunction.data_passes_indices" title="Link to this definition">#</a></dt>
<dd><p>The property <code class="code docutils literal notranslate"><span class="pre">data_passes_indices</span></code> is a list of lists holding the indices of the functions that are processed in each call of <cite>gradient</cite>. This list is updated each time <cite>gradient</cite> is called by appending a list of the indices of the functions used to calculate the gradient.
This is overwritten from the base class to first check to see if the approximate gradient was warm started and, if it was, ensure that the first element of <cite>data_passes_indices</cite> contains each index used to warm start and the index used in the first call to <cite>gradient</cite>. Thus the length of <cite>data_passes_indices</cite> is always equal to the number of calls to <cite>gradient</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SAGAFunction.full_gradient">
<span class="sig-name descname"><span class="pre">full_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SAGAFunction.full_gradient" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the  full gradient of the sum of functions at <span class="math notranslate nohighlight">\(x\)</span>.</p>
<div class="math notranslate nohighlight">
\[\nabla_x(f_{0} + f_{1} + ... + f_{n-1})(x) = \nabla_xf_{0}(x) + \nabla_xf_{1}(x) + ... + \nabla_xf_{n-1}(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (return DataContainer, if <cite>None</cite> a new DataContainer is returned, default <cite>None</cite>.)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the gradient of the sum function at x or nothing if <cite>out</cite></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SAGAFunction.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SAGAFunction.gradient" title="Link to this definition">#</a></dt>
<dd><p>Selects a random function using the <cite>sampler</cite> and then calls the approximate gradient at <code class="code docutils literal notranslate"><span class="pre">x</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (return DataContainer, if <cite>None</cite> a new DataContainer is returned, default <cite>None</cite>.)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the value of the approximate gradient of the sum function at <code class="code docutils literal notranslate"><span class="pre">x</span></code></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SAGAFunction.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SAGAFunction.proximal" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of function <span class="math notranslate nohighlight">\(\tau F\)</span>  evaluated at x</p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F}(x) = \underset{z}{\text{argmin}} \frac{1}{2}\|z - x\|^{2} + \tau F(z)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the proximal operator of the function at x with scalar <span class="math notranslate nohighlight">\(\tau\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SAGAFunction.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SAGAFunction.proximal_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SAGAFunction.set_data_partition_weights">
<span class="sig-name descname"><span class="pre">set_data_partition_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SAGAFunction.set_data_partition_weights" title="Link to this definition">#</a></dt>
<dd><p>Setter for the partition weights used to calculate the data passes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>weights</strong> (<em>list</em><em> of </em><em>positive floats that sum to one.</em>) – The proportion of the data held in each function. Equivalent to the proportions that you partitioned your data into.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SAGAFunction.warm_start_approximate_gradients">
<span class="sig-name descname"><span class="pre">warm_start_approximate_gradients</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SAGAFunction.warm_start_approximate_gradients" title="Link to this definition">#</a></dt>
<dd><p>A function to warm start SAG or SAGA algorithms by initialising all the gradients at an initial point. Equivalently setting <span class="math notranslate nohighlight">\(g_i^0 = \nabla f_i(x_0)\)</span> for initial point <span class="math notranslate nohighlight">\(x_0\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>initial</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>,</em>) – The initial point to warmstart the calculation</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When using SAG or SAGA with a deterministic algorithm, you should warm start the SAG-SAGA Function with the same initial point that you initialise the algorithm</p>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="stochastic-variance-reduced-gradient-function">
<h3>Stochastic Variance Reduced Gradient Function<a class="headerlink" href="#stochastic-variance-reduced-gradient-function" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.SVRGFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">SVRGFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">functions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampler</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snapshot_update_interval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">store_gradients</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/SVRGFunction/#SVRGFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SVRGFunction" title="Link to this definition">#</a></dt>
<dd><p>The Stochastic Variance Reduced Gradient (SVRG) function calculates the approximate gradient of <span class="math notranslate nohighlight">\(\sum_{i=1}^{n-1}f_i\)</span>.  For this approximation, every <cite>snapshot_update_interval</cite> number of iterations, a full gradient calculation is made at this “snapshot” point. Intermediate gradient calculations update this snapshot by taking a index <span class="math notranslate nohighlight">\(i_k\)</span> and calculating the gradient of :math:<a href="#id24"><span class="problematic" id="id25">`</span></a>f_{i_k}`s at the current iterate and the snapshot, updating the approximate gradient to be:</p>
<div class="math notranslate nohighlight">
\[n*\nabla f_{i_k}(x_k) - n*\nabla f_{i_k}(\tilde{x}) + \nabla \sum_{i=0}^{n-1}f_i(\tilde{x}),\]</div>
<p>where <span class="math notranslate nohighlight">\(\tilde{x}\)</span> is the latest “snapshot” point and <span class="math notranslate nohighlight">\(x_k\)</span> is the value at the current iteration.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Compared with the literature, we multiply by <span class="math notranslate nohighlight">\(n\)</span>, the number of functions, so that we return an approximate gradient of the whole sum function and not an average gradient.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the case where <cite>store_gradients=False</cite> the memory requirements are 4 times the image size (1 stored full gradient at the “snapshot”, one stored “snapshot” point and two lots of intermediary calculations). Alternatively, if  <cite>store_gradients=True</cite>  the memory requirement is <cite>n+4</cite> (<cite>n</cite> gradients at the snapshot for each function in the sum, one stored full gradient at the “snapshot”, one stored “snapshot” point and two lots of intermediary calculations).</p>
<p>Johnson, R. and Zhang, T., 2013. Accelerating stochastic gradient descent using predictive variance reduction. Advances in neural information processing systems, 26.https://proceedings.neurips.cc/paper_files/paper/2013/file/ac1dd209cbcc5e5d1c6e28598e8cbbe8-Paper.pdf</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>functions</strong> (<cite>list</cite>  of functions) – A list of functions: <code class="code docutils literal notranslate"><span class="pre">[f_{0},</span> <span class="pre">f_{1},</span> <span class="pre">...,</span> <span class="pre">f_{n-1}]</span></code>. Each function is assumed to be smooth with an implemented <a class="reference internal" href="#cil.optimisation.functions.Function.gradient" title="cil.optimisation.functions.Function.gradient"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient()</span></code></a> method. All functions must have the same domain. The number of functions must be strictly greater than 1.</p></li>
<li><p><strong>sampler</strong> (An instance of a CIL Sampler class ( <code class="xref py py-meth docutils literal notranslate"><span class="pre">sampler()</span></code>) or of another class which has a <cite>next</cite> function implemented to output integers in {0, 1, …, n-1}.) – This sampler is called each time gradient is called and  sets the internal <cite>function_num</cite> passed to the <cite>approximate_gradient</cite> function.  Default is <cite>Sampler.random_with_replacement(len(functions))</cite>.</p></li>
<li><p><strong>snapshot_update_interval</strong> (<em>positive int</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – The interval for updating the full gradient (taking a snapshot). The default is 2*len(functions) so a “snapshot” is taken every 2*len(functions) iterations. If the user passes <cite>0</cite> then no full gradient snapshots will be taken.</p></li>
<li><p><strong>store_gradients</strong> (bool, default: <cite>False</cite>) – Flag indicating whether to store an update a list of gradients for each function <span class="math notranslate nohighlight">\(f_i\)</span> or just to store the snapshot point :math:` tilde{x}` and its gradient <span class="math notranslate nohighlight">\(\nabla \sum_{i=0}^{n-1}f_i(\tilde{x})\)</span>.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SVRGFunction.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/SVRGFunction/#SVRGFunction.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SVRGFunction.gradient" title="Link to this definition">#</a></dt>
<dd><p>Selects a random function using the <cite>sampler</cite> and then calls the approximate gradient at <code class="code docutils literal notranslate"><span class="pre">x</span></code> or calculates a full gradient depending on the update frequency</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> (</em><em>e.g. ImageData object</em><em>)</em>)</p></li>
<li><p><strong>out</strong> (return DataContainer, if <cite>None</cite> a new DataContainer is returned, default <cite>None</cite>.)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the value of the approximate gradient of the sum function at <code class="code docutils literal notranslate"><span class="pre">x</span></code></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a> (e.g. ImageData object)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SVRGFunction.approximate_gradient">
<span class="sig-name descname"><span class="pre">approximate_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function_num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/SVRGFunction/#SVRGFunction.approximate_gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.SVRGFunction.approximate_gradient" title="Link to this definition">#</a></dt>
<dd><p>Calculates the stochastic gradient at the point <span class="math notranslate nohighlight">\(x\)</span> by using the gradient of the selected function, indexed by <span class="math notranslate nohighlight">\(i_k\)</span>, the <cite>function_number</cite> in {0,…,len(functions)-1}, and the full gradient at the snapshot <span class="math notranslate nohighlight">\(\tilde{x}\)</span></p>
<div class="math notranslate nohighlight">
\[n*\nabla f_{i_k}(x_k) - n*\nabla f_{i_k}(\tilde{x}) + \nabla \sum_{i=0}^{n-1}f_i(\tilde{x})\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Compared with the literature, we multiply by <span class="math notranslate nohighlight">\(n\)</span>, the number of functions, so that we return an approximate gradient of the whole sum function and not an average gradient.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> (</em><em>e.g. ImageData object</em><em>)</em>)</p></li>
<li><p><strong>out</strong> (return DataContainer, if <cite>None</cite> a new DataContainer is returned, default <cite>None</cite>.)</p></li>
<li><p><strong>function_num</strong> (<cite>int</cite>) – Between 0 and n-1, where n is the number of functions in the list</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the value of the approximate gradient of the sum function at <code class="code docutils literal notranslate"><span class="pre">x</span></code> given a <cite>function_number</cite> in {0,…,len(functions)-1}</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a> (e.g. ImageData object)</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.SVRGFunction.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.SVRGFunction.L" title="Link to this definition">#</a></dt>
<dd><p>Returns the Lipschitz constant for the SumFunction</p>
<div class="math notranslate nohighlight">
\[L = \sum_{i} L_{i}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{i}\)</span> is the Lipschitz constant of the smooth function <span class="math notranslate nohighlight">\(F_{i}\)</span>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.SVRGFunction.Lmax">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Lmax</span></span><a class="headerlink" href="#cil.optimisation.functions.SVRGFunction.Lmax" title="Link to this definition">#</a></dt>
<dd><p>Returns the maximum Lipschitz constant for the SumFunction</p>
<div class="math notranslate nohighlight">
\[L = \max_{i}\{L_{i}\}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{i}\)</span> is the Lipschitz constant of the smooth function <span class="math notranslate nohighlight">\(F_{i}\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SVRGFunction.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SVRGFunction.centered_at" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SVRGFunction.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SVRGFunction.convex_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Evaluation of the function F* at x, where F* is the convex conjugate of function F,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x}{\sup} \langle x^{*}, x \rangle - F(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the convex conjugate of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.SVRGFunction.data_passes">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">data_passes</span></span><a class="headerlink" href="#cil.optimisation.functions.SVRGFunction.data_passes" title="Link to this definition">#</a></dt>
<dd><p>The property <code class="code docutils literal notranslate"><span class="pre">data_passes</span></code> is a list of floats that holds the amount of data that has been processed up until each call of <cite>gradient</cite>.
This list is updated each time <cite>gradient</cite> is called by appending the proportion of the data used when calculating the approximate gradient since the class was initialised (a full gradient calculation would be 1 full data pass).
Note that if your functions do not contain an equal <cite>amount</cite> of data, for example your data was not partitioned into equal batches, then you must first use the <cite>set_data_partition_weights</cite> function for this to be accurate.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.SVRGFunction.data_passes_indices">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">data_passes_indices</span></span><a class="headerlink" href="#cil.optimisation.functions.SVRGFunction.data_passes_indices" title="Link to this definition">#</a></dt>
<dd><p>The property <code class="code docutils literal notranslate"><span class="pre">data_passes_indices</span></code> is a list of lists holding the indices of the functions that are processed in each call of <cite>gradient</cite>. This list is updated each time <cite>gradient</cite> is called by appending a list of the indices of the functions used to calculate the gradient.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SVRGFunction.full_gradient">
<span class="sig-name descname"><span class="pre">full_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SVRGFunction.full_gradient" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the  full gradient of the sum of functions at <span class="math notranslate nohighlight">\(x\)</span>.</p>
<div class="math notranslate nohighlight">
\[\nabla_x(f_{0} + f_{1} + ... + f_{n-1})(x) = \nabla_xf_{0}(x) + \nabla_xf_{1}(x) + ... + \nabla_xf_{n-1}(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (return DataContainer, if <cite>None</cite> a new DataContainer is returned, default <cite>None</cite>.)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the gradient of the sum function at x or nothing if <cite>out</cite></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SVRGFunction.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SVRGFunction.proximal" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of function <span class="math notranslate nohighlight">\(\tau F\)</span>  evaluated at x</p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F}(x) = \underset{z}{\text{argmin}} \frac{1}{2}\|z - x\|^{2} + \tau F(z)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the proximal operator of the function at x with scalar <span class="math notranslate nohighlight">\(\tau\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SVRGFunction.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SVRGFunction.proximal_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.SVRGFunction.set_data_partition_weights">
<span class="sig-name descname"><span class="pre">set_data_partition_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.SVRGFunction.set_data_partition_weights" title="Link to this definition">#</a></dt>
<dd><p>Setter for the partition weights used to calculate the data passes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>weights</strong> (<em>list</em><em> of </em><em>positive floats that sum to one.</em>) – The proportion of the data held in each function. Equivalent to the proportions that you partitioned your data into.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="loopless-stochastic-variance-reduced-gradient-function">
<h3>Loopless Stochastic Variance Reduced Gradient Function<a class="headerlink" href="#loopless-stochastic-variance-reduced-gradient-function" title="Link to this heading">#</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.LSVRGFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">LSVRGFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">functions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampler</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snapshot_update_probability</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">store_gradients</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/SVRGFunction/#LSVRGFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.LSVRGFunction" title="Link to this definition">#</a></dt>
<dd><dl>
<dt>“”</dt><dd><p>A class representing a function for Loopless Stochastic Variance Reduced Gradient (SVRG) approximation. This is similar to SVRG, except the full gradient at a “snapshot”  is calculated at random intervals rather than at fixed numbers of iterations.</p>
<p>Kovalev, D., Horváth, S. &amp;; Richtárik, P.. (2020). Don’t Jump Through Hoops and Remove Those Loops:  SVRG and Katyusha are Better Without the Outer Loop. Proceedings of the 31st International Conference  on Algorithmic Learning Theory, in Proceedings of Machine Learning Research 117:451-467 Available from <a class="reference external" href="https://proceedings.mlr.press/v117/kovalev20a.html">https://proceedings.mlr.press/v117/kovalev20a.html</a>.</p>
<blockquote>
<div><dl>
<dt>functions<span class="classifier"><cite>list</cite>  of functions</span></dt><dd><p>A list of functions: <code class="code docutils literal notranslate"><span class="pre">[f_{0},</span> <span class="pre">f_{1},</span> <span class="pre">...,</span> <span class="pre">f_{n-1}]</span></code>. Each function is assumed to be smooth with an implemented <a class="reference internal" href="#cil.optimisation.functions.Function.gradient" title="cil.optimisation.functions.Function.gradient"><code class="xref py py-func docutils literal notranslate"><span class="pre">gradient()</span></code></a> method. All functions must have the same domain. The number of functions <cite>n</cite> must be strictly greater than 1.</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>sampler: An instance of a CIL Sampler class ( <code class="xref py py-meth docutils literal notranslate"><span class="pre">sampler()</span></code>) or of another class which has a <cite>next</cite> function implemented to output integers in {0,…,n-1}.</dt><dd><p>This sampler is called each time gradient is called and  sets the internal <cite>function_num</cite> passed to the <cite>approximate_gradient</cite> function.  Default is <cite>Sampler.random_with_replacement(len(functions))</cite>.</p>
</dd>
<dt>snapshot_update_probability: positive float, default: 1/n</dt><dd><p>The probability of updating the full gradient (taking a snapshot) at each iteration. The default is <span class="math notranslate nohighlight">\(1./n\)</span> so, in expectation, a snapshot will be taken every <span class="math notranslate nohighlight">\(n\)</span> iterations.</p>
</dd>
<dt>store_gradients<span class="classifier">bool, default: <cite>False</cite></span></dt><dd><p>Flag indicating whether to store an update a list of gradients for each function <span class="math notranslate nohighlight">\(f_i\)</span> or just to store the snapshot point :math:`        ilde{x}` and it’s gradient :math:<a href="#id26"><span class="problematic" id="id27">`</span></a></p>
</dd>
</dl>
</dd>
</dl>
<p>abla sum_{i=0}^{n-1}f_i(       ilde{x})`.</p>
<blockquote>
<div><p>In the case where <cite>store_gradients=False</cite> the memory requirements are 4 times the image size (1 stored full gradient at the “snapshot”, one stored “snapshot” point and two lots of intermediary calculations). Alternatively, if  <cite>store_gradients=True</cite>  the memory requirement is <cite>n+4</cite> (<cite>n</cite> gradients at the snapshot for each function in the sum, one stored full gradient at the “snapshot”, one stored “snapshot” point and two lots of intermediary calculations).</p>
</div></blockquote>
<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.LSVRGFunction.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.LSVRGFunction.L" title="Link to this definition">#</a></dt>
<dd><p>Returns the Lipschitz constant for the SumFunction</p>
<div class="math notranslate nohighlight">
\[L = \sum_{i} L_{i}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{i}\)</span> is the Lipschitz constant of the smooth function <span class="math notranslate nohighlight">\(F_{i}\)</span>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.LSVRGFunction.Lmax">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Lmax</span></span><a class="headerlink" href="#cil.optimisation.functions.LSVRGFunction.Lmax" title="Link to this definition">#</a></dt>
<dd><p>Returns the maximum Lipschitz constant for the SumFunction</p>
<div class="math notranslate nohighlight">
\[L = \max_{i}\{L_{i}\}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_{i}\)</span> is the Lipschitz constant of the smooth function <span class="math notranslate nohighlight">\(F_{i}\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.LSVRGFunction.approximate_gradient">
<span class="sig-name descname"><span class="pre">approximate_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function_num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.LSVRGFunction.approximate_gradient" title="Link to this definition">#</a></dt>
<dd><p>Calculates the stochastic gradient at the point <span class="math notranslate nohighlight">\(x\)</span> by using the gradient of the selected function, indexed by <span class="math notranslate nohighlight">\(i_k\)</span>, the <cite>function_number</cite> in {0,…,len(functions)-1}, and the full gradient at the snapshot <span class="math notranslate nohighlight">\(\tilde{x}\)</span></p>
<div class="math notranslate nohighlight">
\[n*\nabla f_{i_k}(x_k) - n*\nabla f_{i_k}(\tilde{x}) + \nabla \sum_{i=0}^{n-1}f_i(\tilde{x})\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Compared with the literature, we multiply by <span class="math notranslate nohighlight">\(n\)</span>, the number of functions, so that we return an approximate gradient of the whole sum function and not an average gradient.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> (</em><em>e.g. ImageData object</em><em>)</em>)</p></li>
<li><p><strong>out</strong> (return DataContainer, if <cite>None</cite> a new DataContainer is returned, default <cite>None</cite>.)</p></li>
<li><p><strong>function_num</strong> (<cite>int</cite>) – Between 0 and n-1, where n is the number of functions in the list</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the value of the approximate gradient of the sum function at <code class="code docutils literal notranslate"><span class="pre">x</span></code> given a <cite>function_number</cite> in {0,…,len(functions)-1}</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a> (e.g. ImageData object)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.LSVRGFunction.centered_at">
<span class="sig-name descname"><span class="pre">centered_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.LSVRGFunction.centered_at" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Returns a translated function, namely if we have a function <span class="math notranslate nohighlight">\(F(x)\)</span> the center is at the origin.</dt><dd><p>TranslateFunction is <span class="math notranslate nohighlight">\(F(x - b)\)</span> and the center is at point b.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>center</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The point to center the function at.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The translated function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.LSVRGFunction.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.LSVRGFunction.convex_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Evaluation of the function F* at x, where F* is the convex conjugate of function F,</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \underset{x}{\sup} \langle x^{*}, x \rangle - F(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the convex conjugate of the function at x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.LSVRGFunction.data_passes">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">data_passes</span></span><a class="headerlink" href="#cil.optimisation.functions.LSVRGFunction.data_passes" title="Link to this definition">#</a></dt>
<dd><p>The property <code class="code docutils literal notranslate"><span class="pre">data_passes</span></code> is a list of floats that holds the amount of data that has been processed up until each call of <cite>gradient</cite>.
This list is updated each time <cite>gradient</cite> is called by appending the proportion of the data used when calculating the approximate gradient since the class was initialised (a full gradient calculation would be 1 full data pass).
Note that if your functions do not contain an equal <cite>amount</cite> of data, for example your data was not partitioned into equal batches, then you must first use the <cite>set_data_partition_weights</cite> function for this to be accurate.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.LSVRGFunction.data_passes_indices">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">data_passes_indices</span></span><a class="headerlink" href="#cil.optimisation.functions.LSVRGFunction.data_passes_indices" title="Link to this definition">#</a></dt>
<dd><p>The property <code class="code docutils literal notranslate"><span class="pre">data_passes_indices</span></code> is a list of lists holding the indices of the functions that are processed in each call of <cite>gradient</cite>. This list is updated each time <cite>gradient</cite> is called by appending a list of the indices of the functions used to calculate the gradient.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.LSVRGFunction.full_gradient">
<span class="sig-name descname"><span class="pre">full_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.LSVRGFunction.full_gradient" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the  full gradient of the sum of functions at <span class="math notranslate nohighlight">\(x\)</span>.</p>
<div class="math notranslate nohighlight">
\[\nabla_x(f_{0} + f_{1} + ... + f_{n-1})(x) = \nabla_xf_{0}(x) + \nabla_xf_{1}(x) + ... + \nabla_xf_{n-1}(x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (return DataContainer, if <cite>None</cite> a new DataContainer is returned, default <cite>None</cite>.)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the gradient of the sum function at x or nothing if <cite>out</cite></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.LSVRGFunction.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.LSVRGFunction.proximal" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of function <span class="math notranslate nohighlight">\(\tau F\)</span>  evaluated at x</p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F}(x) = \underset{z}{\text{argmin}} \frac{1}{2}\|z - x\|^{2} + \tau F(z)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the proximal operator of the function at x with scalar <span class="math notranslate nohighlight">\(\tau\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.LSVRGFunction.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.LSVRGFunction.proximal_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the proximal operator of the convex conjugate of function <span class="math notranslate nohighlight">\(\tau F\)</span> evaluated at <span class="math notranslate nohighlight">\(x^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x^{*}) = \underset{z^{*}}{\text{argmin}} \frac{1}{2}\|z^{*} - x^{*}\|^{2} + \tau F^{*}(z^{*})\]</div>
<p>Due to Moreau’s identity, we have an analytic formula to compute the proximal operator of the convex conjugate <span class="math notranslate nohighlight">\(F^{*}\)</span></p>
<div class="math notranslate nohighlight">
\[\text{prox}_{\tau F^{*}}(x) = x - \tau\text{prox}_{\tau^{-1} F}(\tau^{-1}x)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>tau</strong> (<em>scalar</em>)</p></li>
<li><p><strong>out</strong> (<em>return DataContainer</em><em>, </em><em>if None a new DataContainer is returned</em><em>, </em><em>default None.</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>DataContainer, the value of the proximal operator of the convex conjugate at point <span class="math notranslate nohighlight">\(x\)</span> for scalar <span class="math notranslate nohighlight">\(\tau\)</span> or None if <cite>out</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.LSVRGFunction.set_data_partition_weights">
<span class="sig-name descname"><span class="pre">set_data_partition_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cil.optimisation.functions.LSVRGFunction.set_data_partition_weights" title="Link to this definition">#</a></dt>
<dd><p>Setter for the partition weights used to calculate the data passes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>weights</strong> (<em>list</em><em> of </em><em>positive floats that sum to one.</em>) – The proportion of the data held in each function. Equivalent to the proportions that you partitioned your data into.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.LSVRGFunction.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/SVRGFunction/#LSVRGFunction.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.LSVRGFunction.gradient" title="Link to this definition">#</a></dt>
<dd><p>Selects a random function using the <cite>sampler</cite> and then calls the approximate gradient at <code class="code docutils literal notranslate"><span class="pre">x</span></code> or calculates a full gradient depending on the update probability.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> (</em><em>e.g. ImageData objects</em><em>)</em>)</p></li>
<li><p><strong>out</strong> (return DataContainer, if <cite>None</cite> a new DataContainer is returned, default <cite>None</cite>.)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the value of the approximate gradient of the sum function at <code class="code docutils literal notranslate"><span class="pre">x</span></code></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a> (e.g. ImageData object)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="utilities">
<h2>Utilities<a class="headerlink" href="#utilities" title="Link to this heading">#</a></h2>
<p>Contains utilities for the CIL optimisation framework.</p>
<section id="samplers">
<h3>Samplers<a class="headerlink" href="#samplers" title="Link to this heading">#</a></h3>
<p>Here, we define samplers that select from a list of indices {0, 1, …, N-1} either randomly or by some deterministic pattern.
The <code class="code docutils literal notranslate"><span class="pre">cil.optimisation.utilities.sampler</span></code> class defines a function <code class="code docutils literal notranslate"><span class="pre">next()</span></code> which gives the next sample. It also has utility to <code class="code docutils literal notranslate"><span class="pre">get_samples</span></code> to access which samples have or will be drawn.</p>
<p>For ease of use we provide the following static methods in <cite>cil.optimisation.utilities.sampler</cite> that allow you to configure your sampler object rather than initialising the classes directly:</p>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.utilities.Sampler.from_function">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Sampler.</span></span><span class="sig-name descname"><span class="pre">from_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler.from_function"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.Sampler.from_function" title="Link to this definition">#</a></dt>
<dd><blockquote>
<div><p>Instantiate a sampler that wraps a function for index selection.</p>
<dl class="simple">
<dt>num_indices: int</dt><dd><p>The sampler will select from a range of indices 0 to num_indices.</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>function<span class="classifier">callable</span></dt><dd><p>A deterministic function that takes an integer as an argument, representing the iteration number, and returns an integer between 0 and num_indices. The function signature should be function(iteration_number: int) -&gt; int</p>
<dl class="simple">
<dt>prob_weights: list of floats of length num_indices that sum to 1. Default is [1 / num_indices] * num_indices</dt><dd><p>Consider that the sampler is incremented a large number of times this argument holds the expected number of times each index would be outputted,  normalised to 1.</p>
</dd>
</dl>
<dl class="simple">
<dt>Sampler</dt><dd><p>An instance of the Sampler class which samples from a function.</p>
</dd>
</dl>
<p>This example creates a sampler that always outputs 2.  The probability weights are passed to the sampler as they are not uniform.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">num_indices</span><span class="o">=</span><span class="mi">3</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">my_sampling_function</span><span class="p">(</span><span class="n">iteration_number</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">from_function</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="n">num_indices</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">my_sampling_function</span><span class="p">,</span> <span class="n">prob_weights</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">12</span><span class="p">)))</span>
<span class="go">[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]</span>
</pre></div>
</div>
<p>This example creates a sampler that outputs sequential indices, starting from 1.  The probability weights are not passed to the sampler as they are uniform.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">num_indices</span><span class="o">=</span><span class="mi">10</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">my_sampling_function</span><span class="p">(</span><span class="n">iteration_number</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="p">(</span><span class="n">iteration_number</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">10</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">from_function</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="n">num_indices</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">my_sampling_function</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">25</span><span class="p">)))</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5]</span>
</pre></div>
</div>
<p>This example creates a sampler that samples in order from a custom list. The num_indices  is 6, although note that the index 5 is never output by the sampler. The number of indices must be at least one greater than any of the elements in the custom_list.
The probability weights are passed to the sampler as they are not uniform.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">custom_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">num_indices</span> <span class="o">=</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">my_sampling_function</span><span class="p">(</span><span class="n">iteration_number</span><span class="p">,</span> <span class="n">custom_list</span><span class="o">=</span><span class="n">custom_list</span><span class="p">]):</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="k">return</span><span class="p">(</span><span class="n">custom_list</span><span class="p">[</span><span class="n">iteration_number</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">custom_list</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">from_function</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="n">num_indices</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">my_sampling_function</span><span class="p">,</span> <span class="n">prob_weights</span><span class="o">=</span><span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">25</span><span class="p">)))</span>
<span class="go">[0, 0, 0, 0, 0, 0, 3, 2, 1, 4, 0, 0, 0, 0, 0, 0, 3, 2, 1, 4, 0, 0, 0, 0, 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="p">)</span>
<span class="go">Sampler that wraps a function that takes an iteration number and selects from a list of indices {0, 1, …, N-1}, where N is the number of indices.</span>
<span class="go">Type : from_function</span>
<span class="go">Current iteration number : 0</span>
<span class="go">number of indices : 6</span>
<span class="go">Probability weights : [0.6, 0.1, 0.1, 0.1, 0.1, 0.0]</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.utilities.Sampler.sequential">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Sampler.</span></span><span class="sig-name descname"><span class="pre">sequential</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_indices</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler.sequential"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.Sampler.sequential" title="Link to this definition">#</a></dt>
<dd><p>Instantiates a sampler that outputs sequential indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>num_indices</strong> (<em>int</em>) – The sampler will select from a range of indices 0 to num_indices.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of the Sampler class that will generate indices sequentially.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#cil.optimisation.utilities.Sampler" title="cil.optimisation.utilities.Sampler">Sampler</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">sequential</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">sampler</span><span class="p">))</span>
<span class="go">0</span>
<span class="go">[0 1 2 3 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">next</span><span class="p">())</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.utilities.Sampler.staggered">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Sampler.</span></span><span class="sig-name descname"><span class="pre">staggered</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stride</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler.staggered"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.Sampler.staggered" title="Link to this definition">#</a></dt>
<dd><p>Instantiates a sampler which outputs in a staggered order.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_indices</strong> (<em>int</em>) – The sampler will select from a range of indices 0 to num_indices.</p></li>
<li><p><strong>stride</strong> (<em>int</em>) – The stride between returned indices. The stride should be less than the num_indices.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of the Sampler class that will generate indices in a staggered pattern.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#cil.optimisation.utilities.Sampler" title="cil.optimisation.utilities.Sampler">Sampler</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">staggered</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="mi">21</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">sampler</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">next</span><span class="p">())</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">[ 0  4  8 12 16]</span>
</pre></div>
</div>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">staggered</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="mi">17</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">sampler</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">next</span><span class="p">())</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">[ 0  8  16 1 9 2 10 3 11 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.utilities.Sampler.herman_meyer">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Sampler.</span></span><span class="sig-name descname"><span class="pre">herman_meyer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_indices</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler.herman_meyer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.Sampler.herman_meyer" title="Link to this definition">#</a></dt>
<dd><p>Instantiates a sampler which outputs in a Herman Meyer order.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>num_indices</strong> (<em>int</em>) – The sampler will select from a range of indices 0 to num_indices. For Herman-Meyer sampling this number should not be prime.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of the Sampler class which outputs in a Herman Meyer order.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#cil.optimisation.utilities.Sampler" title="cil.optimisation.utilities.Sampler">Sampler</a></p>
</dd>
</dl>
<section id="id28">
<h4>Reference<a class="headerlink" href="#id28" title="Link to this heading">#</a></h4>
<p>With thanks to Imraj Singh and Zeljko Kereta for their help with the initial implementation of the Herman Meyer sampling. Their implementation was used in:</p>
<p>Singh I, et al. Deep Image Prior PET Reconstruction using a SIRF-Based Objective - IEEE MIC, NSS &amp; RTSD 2022. <a class="reference external" href="https://discovery.ucl.ac.uk/id/eprint/10176077/1/MIC_Conference_Record.pdf">https://discovery.ucl.ac.uk/id/eprint/10176077/1/MIC_Conference_Record.pdf</a></p>
<p>The sampling method was introduced in:</p>
<p>Herman GT, Meyer LB. Algebraic reconstruction techniques can be made computationally efficient. IEEE Trans Med Imaging.  doi: 10.1109/42.241889.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span><span class="o">=</span><span class="n">Sampler</span><span class="o">.</span><span class="n">herman_meyer</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
<span class="go">[ 0  6  3  9  1  7  4 10  2  8  5 11  0  6  3  9]</span>
</pre></div>
</div>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.utilities.Sampler.random_with_replacement">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Sampler.</span></span><span class="sig-name descname"><span class="pre">random_with_replacement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler.random_with_replacement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.Sampler.random_with_replacement" title="Link to this definition">#</a></dt>
<dd><p>Instantiates a sampler which outputs an index between 0 - num_indices with a given probability.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_indices</strong> (<em>int</em>) – The sampler will select from a range of indices 0 to num_indices</p></li>
<li><p><strong>prob</strong> (<em>list</em><em> of </em><em>floats</em><em>, </em><em>optional</em>) – The probability for each index to be selected by the ‘next’ operation. If not provided, the indices will be sampled uniformly. The list should have a length equal to num_indices, and the values should sum to 1</p></li>
<li><p><strong>seed</strong> (<em>int</em><em>, </em><em>optional</em>) – Used to initialise the random number generator where repeatability is required.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of the <cite>RandomSampler</cite> class that will generate indices randomly with replacement</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><cite>RandomSampler</cite></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">random_with_replacement</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">[3 4 0 0 2 3 3 2 2 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">sampler</span><span class="p">))</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">next</span><span class="p">())</span>
<span class="go">4</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">random_with_replacement</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="p">[</span><span class="mf">0.7</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">[0 1 3 0 0 3 0 0 0 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.utilities.Sampler.random_without_replacement">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Sampler.</span></span><span class="sig-name descname"><span class="pre">random_without_replacement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler.random_without_replacement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.Sampler.random_without_replacement" title="Link to this definition">#</a></dt>
<dd><p>Instantiates a sampler which outputs an index between 0 - num_indices. Once sampled the index will not be sampled again until all indices have been returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_indices</strong> (<em>int</em>) – The sampler will select from a range of indices 0 to num_indices.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em>, </em><em>optional</em>) – Used to initialise the random number generator where repeatability is required.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of the <cite>RandomSampler</cite> class that will generate indices randomly without replacement</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><cite>RandomSampler</cite></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span><span class="o">=</span><span class="n">Sampler</span><span class="o">.</span><span class="n">randomWithoutReplacement</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
<span class="go">[6 2 1 0 4 3 5 1 0 4 2 5 6 3 3 2]</span>
</pre></div>
</div>
</dd></dl>

<p>They will all instantiate a Sampler defined in the following class:</p>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.utilities.Sampler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.utilities.</span></span><span class="sig-name descname"><span class="pre">Sampler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.Sampler" title="Link to this definition">#</a></dt>
<dd><p>Initialises a sampler that returns and then increments indices from a sequence defined by a function.</p>
<p>Static methods to easily configure several samplers are provided, such as sequential, staggered, Herman-Mayer, random with and without replacement.</p>
<p>Custom deterministic samplers can be created by using the <cite>from_function</cite> static method or by subclassing this sampler class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>Callable</em><em>[</em><em>[</em><em>int</em><em>]</em><em>, </em><em>int</em><em>]</em>) – A function that takes an integer iteration number and returns an integer between 0 and num_indices.</p></li>
<li><p><strong>num_indices</strong> (<em>int</em>) – The sampler will select from a range of indices 0 to num_indices.</p></li>
<li><p><strong>sampling_type</strong> (<em>str</em><em>, </em><em>optional</em><em>,  </em><em>default = None</em>) – The sampling type used. This is recorded for reference and printed when <cite>print</cite> is called.</p></li>
<li><p><strong>prob_weights</strong> (<em>list</em><em> of </em><em>floats</em><em> of </em><em>length num_indices that sum to 1.  Default is</em><em> [</em><em>1 / num_indices</em><em>] </em><em>* num_indices</em>) – Consider that the sampler is incremented a large number of times this argument holds the expected number of times each index would be outputted,  normalised to 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of the Sampler class representing the desired configuration.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#cil.optimisation.utilities.Sampler" title="cil.optimisation.utilities.Sampler">Sampler</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">random_with_replacement</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="go">[3 4 0 0 2 3 3 2 2 1 1 4 4 3 0 2 4 4 2 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">sampler</span><span class="p">))</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">next</span><span class="p">())</span>
<span class="go">4</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">staggered</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="mi">21</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">sampler</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">next</span><span class="p">())</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">[ 0  4  8 12 16]</span>
</pre></div>
</div>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">sequential</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">sampler</span><span class="p">))</span>
<span class="go">0</span>
<span class="go">[0 1 2 3 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">next</span><span class="p">())</span>
<span class="go">1</span>
</pre></div>
</div>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">herman_meyer</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
<span class="go">[ 0  6  3  9  1  7  4 10  2  8  5 11  0  6  3  9]</span>
</pre></div>
</div>
<p class="rubric">Example</p>
<p>This example creates a sampler that outputs sequential indices, starting from 1.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">num_indices</span><span class="o">=</span><span class="mi">10</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">my_sampling_function</span><span class="p">(</span><span class="n">iteration_number</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="p">(</span><span class="n">iteration_number</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">10</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">from_function</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="n">num_indices</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">my_sampling_function</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">25</span><span class="p">)))</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The optimal choice of sampler depends on the data and the number of calls to the sampler.  Note that a low number of calls to a random sampler won’t give an even distribution.
For a small number of samples (e.g. <cite>&lt;5*num_indices</cite>) the user may wish to consider another sampling method e.g. random without replacement, which, when calling <cite>num_indices</cite> samples is guaranteed to draw each index exactly once.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.utilities.Sampler.next">
<span class="sig-name descname"><span class="pre">next</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler.next"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.Sampler.next" title="Link to this definition">#</a></dt>
<dd><p>Returns a sample from the list of indices <a href="#id29"><span class="problematic" id="id30">`</span></a>{0, 1, …, N-1}, where N is the number of indices and increments the sampler.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.utilities.Sampler.get_samples">
<span class="sig-name descname"><span class="pre">get_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_samples</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler.get_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.Sampler.get_samples" title="Link to this definition">#</a></dt>
<dd><p>Generates a list of the first num_samples output by the sampler. Calling this does not increment the sampler index or affect the behaviour of the sampler .</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>num_samples</strong> (<em>int</em>) – The number of samples to return.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The first <a href="#id31"><span class="problematic" id="id32">`</span></a>num_samples” output by the sampler.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>List</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id0">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sequential</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_indices</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler.sequential"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id0" title="Link to this definition">#</a></dt>
<dd><p>Instantiates a sampler that outputs sequential indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>num_indices</strong> (<em>int</em>) – The sampler will select from a range of indices 0 to num_indices.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of the Sampler class that will generate indices sequentially.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#cil.optimisation.utilities.Sampler" title="cil.optimisation.utilities.Sampler">Sampler</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">sequential</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">sampler</span><span class="p">))</span>
<span class="go">0</span>
<span class="go">[0 1 2 3 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">next</span><span class="p">())</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id33">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">staggered</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stride</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler.staggered"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id33" title="Link to this definition">#</a></dt>
<dd><p>Instantiates a sampler which outputs in a staggered order.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_indices</strong> (<em>int</em>) – The sampler will select from a range of indices 0 to num_indices.</p></li>
<li><p><strong>stride</strong> (<em>int</em>) – The stride between returned indices. The stride should be less than the num_indices.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of the Sampler class that will generate indices in a staggered pattern.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#cil.optimisation.utilities.Sampler" title="cil.optimisation.utilities.Sampler">Sampler</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">staggered</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="mi">21</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">sampler</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">next</span><span class="p">())</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">[ 0  4  8 12 16]</span>
</pre></div>
</div>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">staggered</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="mi">17</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">sampler</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">next</span><span class="p">())</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">[ 0  8  16 1 9 2 10 3 11 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id34">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">random_with_replacement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler.random_with_replacement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id34" title="Link to this definition">#</a></dt>
<dd><p>Instantiates a sampler which outputs an index between 0 - num_indices with a given probability.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_indices</strong> (<em>int</em>) – The sampler will select from a range of indices 0 to num_indices</p></li>
<li><p><strong>prob</strong> (<em>list</em><em> of </em><em>floats</em><em>, </em><em>optional</em>) – The probability for each index to be selected by the ‘next’ operation. If not provided, the indices will be sampled uniformly. The list should have a length equal to num_indices, and the values should sum to 1</p></li>
<li><p><strong>seed</strong> (<em>int</em><em>, </em><em>optional</em>) – Used to initialise the random number generator where repeatability is required.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of the <cite>RandomSampler</cite> class that will generate indices randomly with replacement</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><cite>RandomSampler</cite></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">random_with_replacement</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">[3 4 0 0 2 3 3 2 2 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">sampler</span><span class="p">))</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">next</span><span class="p">())</span>
<span class="go">4</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">random_with_replacement</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="p">[</span><span class="mf">0.7</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">[0 1 3 0 0 3 0 0 0 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id35">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">random_without_replacement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler.random_without_replacement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id35" title="Link to this definition">#</a></dt>
<dd><p>Instantiates a sampler which outputs an index between 0 - num_indices. Once sampled the index will not be sampled again until all indices have been returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_indices</strong> (<em>int</em>) – The sampler will select from a range of indices 0 to num_indices.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em>, </em><em>optional</em>) – Used to initialise the random number generator where repeatability is required.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of the <cite>RandomSampler</cite> class that will generate indices randomly without replacement</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><cite>RandomSampler</cite></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span><span class="o">=</span><span class="n">Sampler</span><span class="o">.</span><span class="n">randomWithoutReplacement</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
<span class="go">[6 2 1 0 4 3 5 1 0 4 2 5 6 3 3 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id36">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler.from_function"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id36" title="Link to this definition">#</a></dt>
<dd><blockquote>
<div><p>Instantiate a sampler that wraps a function for index selection.</p>
<dl class="simple">
<dt>num_indices: int</dt><dd><p>The sampler will select from a range of indices 0 to num_indices.</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>function<span class="classifier">callable</span></dt><dd><p>A deterministic function that takes an integer as an argument, representing the iteration number, and returns an integer between 0 and num_indices. The function signature should be function(iteration_number: int) -&gt; int</p>
<dl class="simple">
<dt>prob_weights: list of floats of length num_indices that sum to 1. Default is [1 / num_indices] * num_indices</dt><dd><p>Consider that the sampler is incremented a large number of times this argument holds the expected number of times each index would be outputted,  normalised to 1.</p>
</dd>
</dl>
<dl class="simple">
<dt>Sampler</dt><dd><p>An instance of the Sampler class which samples from a function.</p>
</dd>
</dl>
<p>This example creates a sampler that always outputs 2.  The probability weights are passed to the sampler as they are not uniform.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">num_indices</span><span class="o">=</span><span class="mi">3</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">my_sampling_function</span><span class="p">(</span><span class="n">iteration_number</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">from_function</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="n">num_indices</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">my_sampling_function</span><span class="p">,</span> <span class="n">prob_weights</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">12</span><span class="p">)))</span>
<span class="go">[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]</span>
</pre></div>
</div>
<p>This example creates a sampler that outputs sequential indices, starting from 1.  The probability weights are not passed to the sampler as they are uniform.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">num_indices</span><span class="o">=</span><span class="mi">10</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">my_sampling_function</span><span class="p">(</span><span class="n">iteration_number</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="p">(</span><span class="n">iteration_number</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">10</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">from_function</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="n">num_indices</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">my_sampling_function</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">25</span><span class="p">)))</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5]</span>
</pre></div>
</div>
<p>This example creates a sampler that samples in order from a custom list. The num_indices  is 6, although note that the index 5 is never output by the sampler. The number of indices must be at least one greater than any of the elements in the custom_list.
The probability weights are passed to the sampler as they are not uniform.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">custom_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">num_indices</span> <span class="o">=</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">my_sampling_function</span><span class="p">(</span><span class="n">iteration_number</span><span class="p">,</span> <span class="n">custom_list</span><span class="o">=</span><span class="n">custom_list</span><span class="p">]):</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="k">return</span><span class="p">(</span><span class="n">custom_list</span><span class="p">[</span><span class="n">iteration_number</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">custom_list</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">from_function</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="n">num_indices</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="n">my_sampling_function</span><span class="p">,</span> <span class="n">prob_weights</span><span class="o">=</span><span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">25</span><span class="p">)))</span>
<span class="go">[0, 0, 0, 0, 0, 0, 3, 2, 1, 4, 0, 0, 0, 0, 0, 0, 3, 2, 1, 4, 0, 0, 0, 0, 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="p">)</span>
<span class="go">Sampler that wraps a function that takes an iteration number and selects from a list of indices {0, 1, …, N-1}, where N is the number of indices.</span>
<span class="go">Type : from_function</span>
<span class="go">Current iteration number : 0</span>
<span class="go">number of indices : 6</span>
<span class="go">Probability weights : [0.6, 0.1, 0.1, 0.1, 0.1, 0.0]</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id37">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">herman_meyer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_indices</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#Sampler.herman_meyer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id37" title="Link to this definition">#</a></dt>
<dd><p>Instantiates a sampler which outputs in a Herman Meyer order.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>num_indices</strong> (<em>int</em>) – The sampler will select from a range of indices 0 to num_indices. For Herman-Meyer sampling this number should not be prime.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of the Sampler class which outputs in a Herman Meyer order.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#cil.optimisation.utilities.Sampler" title="cil.optimisation.utilities.Sampler">Sampler</a></p>
</dd>
</dl>
<section id="id38">
<h4>Reference<a class="headerlink" href="#id38" title="Link to this heading">#</a></h4>
<p>With thanks to Imraj Singh and Zeljko Kereta for their help with the initial implementation of the Herman Meyer sampling. Their implementation was used in:</p>
<p>Singh I, et al. Deep Image Prior PET Reconstruction using a SIRF-Based Objective - IEEE MIC, NSS &amp; RTSD 2022. <a class="reference external" href="https://discovery.ucl.ac.uk/id/eprint/10176077/1/MIC_Conference_Record.pdf">https://discovery.ucl.ac.uk/id/eprint/10176077/1/MIC_Conference_Record.pdf</a></p>
<p>The sampling method was introduced in:</p>
<p>Herman GT, Meyer LB. Algebraic reconstruction techniques can be made computationally efficient. IEEE Trans Med Imaging.  doi: 10.1109/42.241889.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span><span class="o">=</span><span class="n">Sampler</span><span class="o">.</span><span class="n">herman_meyer</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
<span class="go">[ 0  6  3  9  1  7  4 10  2  8  5 11  0  6  3  9]</span>
</pre></div>
</div>
</section>
</dd></dl>

</dd></dl>

<p>In addition, we provide a random sampling class which is a child class of  <cite>cil.optimisation.utilities.sampler</cite> and provides options for sampling with and without replacement:</p>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.utilities.SamplerRandom">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.utilities.</span></span><span class="sig-name descname"><span class="pre">SamplerRandom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'random_with_replacement'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#SamplerRandom"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.SamplerRandom" title="Link to this definition">#</a></dt>
<dd><p>The user is recommended to not instantiate this class  directly but instead use one of the static methods  in the parent Sampler class that will return instances of different samplers.</p>
<p>This class produces Samplers that output random samples with and without replacement from the set {0, 1, …, N-1} where N=num_indices.</p>
<p>Custom random samplers can be created by subclassing this sampler class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_indices</strong> (<em>int</em>) – The sampler will select from a range of indices 0 to num_indices.</p></li>
<li><p><strong>sampling_type</strong> (<em>str</em><em>, </em><em>optional</em><em>,  </em><em>default = 'random_with_replacement&quot;</em>) – The sampling type used. This is recorded for reference and printed when <cite>print</cite> is called.</p></li>
<li><p><strong>prob_weights</strong> (<em>list</em><em> of </em><em>floats</em><em> of </em><em>length num_indices that sum to 1.  Default is</em><em> [</em><em>1 / num_indices</em><em>] </em><em>* num_indices</em>) – Consider that the sampler is incremented a large number of times this argument holds the expected number of times each index would be outputted,  normalised to 1.</p></li>
<li><p><strong>replace</strong> (<em>bool</em><em>, </em><em>default is True</em>) – If True, sample with replace, otherwise sample without replacement</p></li>
<li><p><strong>seed</strong> (<em>int</em><em>, </em><em>optional</em>) – Used to initialise the random number generator where repeatability is required.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of the Sampler class representing the desired configuration.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#cil.optimisation.utilities.Sampler" title="cil.optimisation.utilities.Sampler">Sampler</a></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span> <span class="o">=</span> <span class="n">Sampler</span><span class="o">.</span><span class="n">random_with_replacement</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="go">[3 4 0 0 2 3 3 2 2 1 1 4 4 3 0 2 4 4 2 4]</span>
</pre></div>
</div>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sampler</span><span class="o">=</span><span class="n">Sampler</span><span class="o">.</span><span class="n">randomWithoutReplacement</span><span class="p">(</span><span class="n">num_indices</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
<span class="go">[6 2 1 0 4 3 5 1 0 4 2 5 6 3 3 2]</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.utilities.SamplerRandom.get_samples">
<span class="sig-name descname"><span class="pre">get_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_samples</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/sampler/#SamplerRandom.get_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.SamplerRandom.get_samples" title="Link to this definition">#</a></dt>
<dd><p>Generates a list of the first num_samples output by the sampler. Calling this does not increment the sampler index or affect the behaviour of the sampler .</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>num_samples</strong> (<em>int</em>) – The number of samples to return.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The first <cite>num_samples</cite> produced by the sampler</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="callbacks">
<h3>Callbacks<a class="headerlink" href="#callbacks" title="Link to this heading">#</a></h3>
<p>A list of <code class="code docutils literal notranslate"><span class="pre">Callback</span></code> s to be executed each iteration can be passed to <a href="#id66"><span class="problematic" id="id67">`Algorithms`_</span></a> <code class="code docutils literal notranslate"><span class="pre">run</span></code> method.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">cil.optimisation.utilities.callbacks</span><span class="w"> </span><span class="kn">import</span> <span class="n">LogfileCallback</span>
<span class="o">...</span>
<span class="n">algorithm</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">callbacks</span><span class="o">=</span><span class="p">[</span><span class="n">LogfileCallback</span><span class="p">(</span><span class="s2">&quot;log.txt&quot;</span><span class="p">)])</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.utilities.callbacks.Callback">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.utilities.callbacks.</span></span><span class="sig-name descname"><span class="pre">Callback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/callbacks/#Callback"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.callbacks.Callback" title="Link to this definition">#</a></dt>
<dd><p>Base Callback to inherit from for use in <code class="code docutils literal notranslate"><span class="pre">Algorithm.run(callbacks:</span> <span class="pre">list[Callback])</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>verbose</strong> (<em>int</em><em>, </em><em>choice</em><em> of </em><em>0</em><em>,</em><em>1</em><em>,</em><em>2</em><em>, </em><em>default 1</em>) – 0=quiet, 1=info, 2=debug.</p>
</dd>
</dl>
</dd></dl>

<p>Built-in callbacks include:</p>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.utilities.callbacks.ProgressCallback">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.utilities.callbacks.</span></span><span class="sig-name descname"><span class="pre">ProgressCallback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tqdm_class=&lt;class</span> <span class="pre">'tqdm.asyncio.tqdm_asyncio'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**tqdm_kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/callbacks/#ProgressCallback"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.callbacks.ProgressCallback" title="Link to this definition">#</a></dt>
<dd><p><code class="code docutils literal notranslate"><span class="pre">tqdm</span></code>-based progress bar.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tqdm_class</strong> (default <code class="code docutils literal notranslate"><span class="pre">tqdm.auto.tqdm</span></code>)</p></li>
<li><p><strong>**tqdm_kwargs</strong> – Passed to <code class="code docutils literal notranslate"><span class="pre">tqdm_class</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.utilities.callbacks.TextProgressCallback">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.utilities.callbacks.</span></span><span class="sig-name descname"><span class="pre">TextProgressCallback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tqdm_class=&lt;class</span> <span class="pre">'cil.optimisation.utilities.callbacks._TqdmText'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**tqdm_kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/callbacks/#TextProgressCallback"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.callbacks.TextProgressCallback" title="Link to this definition">#</a></dt>
<dd><p><code class="code docutils literal notranslate"><span class="pre">ProgressCallback</span></code> but printed on separate lines to screen.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>miniters</strong> (int, default <code class="code docutils literal notranslate"><span class="pre">Algorithm.update_objective_interval</span></code>) – Number of algorithm iterations between screen prints.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.utilities.callbacks.LogfileCallback">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.utilities.callbacks.</span></span><span class="sig-name descname"><span class="pre">LogfileCallback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">log_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'a'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/callbacks/#LogfileCallback"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.callbacks.LogfileCallback" title="Link to this definition">#</a></dt>
<dd><p><code class="code docutils literal notranslate"><span class="pre">TextProgressCallback</span></code> but to a file instead of screen.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>log_file</strong> (<em>FileDescriptorOrPath</em>) – Passed to <code class="code docutils literal notranslate"><span class="pre">open()</span></code>.</p></li>
<li><p><strong>mode</strong> (<em>str</em>) – Passed to <code class="code docutils literal notranslate"><span class="pre">open()</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<p>Users can also write custom callbacks.</p>
<p>Below is an example of a custom callback implementing early stopping.
In each iteration of the <code class="code docutils literal notranslate"><span class="pre">TestAlgo</span></code>, the objective <span class="math notranslate nohighlight">\(x\)</span> is reduced by <span class="math notranslate nohighlight">\(5\)</span>. The <code class="code docutils literal notranslate"><span class="pre">EarlyStopping</span></code> callback terminates the algorithm when <span class="math notranslate nohighlight">\(x \le -15\)</span>. The algorithm thus terminates after <span class="math notranslate nohighlight">\(3\)</span> iterations.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">cil.optimisation.algorithms</span><span class="w"> </span><span class="kn">import</span> <span class="n">Algorithm</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cil.optimisation.utilities</span><span class="w"> </span><span class="kn">import</span> <span class="n">callbacks</span>

<span class="k">class</span><span class="w"> </span><span class="nc">TestAlgo</span><span class="p">(</span><span class="n">Algorithm</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">configured</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">-=</span> <span class="mi">5</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">update_objective</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">EarlyStopping</span><span class="p">(</span><span class="n">callbacks</span><span class="o">.</span><span class="n">Callback</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">algorithm</span><span class="p">:</span> <span class="n">Algorithm</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">algorithm</span><span class="o">.</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mi">15</span><span class="p">:</span>  <span class="c1"># arbitrary stopping criterion</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>

<span class="n">algo</span> <span class="o">=</span> <span class="n">TestAlgo</span><span class="p">()</span>
<span class="n">algo</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">callbacks</span><span class="o">=</span><span class="p">[</span><span class="n">callbacks</span><span class="o">.</span><span class="n">ProgressCallback</span><span class="p">(),</span> <span class="n">EarlyStopping</span><span class="p">()])</span>
</pre></div>
</div>
<div class="highlight-raw notranslate"><div class="highlight"><pre><span></span>Output:
 15%|███                 | 3/20 [00:00&lt;00:00, 11770.73it/s, objective=3.05e-5]
</pre></div>
</div>
</section>
<section id="step-size-methods">
<h3>Step size methods<a class="headerlink" href="#step-size-methods" title="Link to this heading">#</a></h3>
<p>A step size method is a class which acts on an algorithm and can be passed to  <cite>cil.optimisation.algorithm.GD</cite>, <cite>cil.optimisation.algorithm.ISTA</cite>  <cite>cil.optimisation.algorithm.FISTA</cite> and it’s method <cite>get_step_size</cite> is called after the calculation of the gradient before the gradient descent step is taken. It outputs a float value to be used as the step-size.</p>
<p>Currently in CIL we have a base class:</p>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.utilities.StepSizeMethods.StepSizeRule">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.utilities.StepSizeMethods.</span></span><span class="sig-name descname"><span class="pre">StepSizeRule</span></span><a class="reference internal" href="../_modules/cil/optimisation/utilities/StepSizeMethods/#StepSizeRule"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.StepSizeMethods.StepSizeRule" title="Link to this definition">#</a></dt>
<dd><p>Abstract base class for a step size rule. The abstract method, <cite>get_step_size</cite> takes in an algorithm and thus can access all parts of the algorithm (e.g. current iterate, current gradient, objective functions etc) and from this  should return a float as a step size.</p>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.utilities.StepSizeMethods.StepSizeRule.get_step_size">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_step_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/StepSizeMethods/#StepSizeRule.get_step_size"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.StepSizeMethods.StepSizeRule.get_step_size" title="Link to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>the calculated step size</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<p>We also have a number of example classes:</p>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.utilities.StepSizeMethods.ConstantStepSize">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.utilities.StepSizeMethods.</span></span><span class="sig-name descname"><span class="pre">ConstantStepSize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">step_size</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/StepSizeMethods/#ConstantStepSize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.StepSizeMethods.ConstantStepSize" title="Link to this definition">#</a></dt>
<dd><p>Step-size rule that always returns a constant step-size.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>step_size</strong> (<em>float</em>) – The step-size to be returned with each call.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.utilities.StepSizeMethods.ConstantStepSize.get_step_size">
<span class="sig-name descname"><span class="pre">get_step_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/StepSizeMethods/#ConstantStepSize.get_step_size"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.StepSizeMethods.ConstantStepSize.get_step_size" title="Link to this definition">#</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>the calculated step size</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.utilities.StepSizeMethods.ArmijoStepSizeRule">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.utilities.StepSizeMethods.</span></span><span class="sig-name descname"><span class="pre">ArmijoStepSizeRule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warmstart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/StepSizeMethods/#ArmijoStepSizeRule"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.StepSizeMethods.ArmijoStepSizeRule" title="Link to this definition">#</a></dt>
<dd><p>Applies the Armijo rule to calculate the step size (step_size).</p>
<p>The Armijo rule runs a while loop to find the appropriate step_size by starting from a very large number (<cite>alpha</cite>). The step_size is found by reducing the step size (by a factor <cite>beta</cite>) in an iterative way until a certain criterion is met. To avoid infinite loops, we add a maximum number of times (<cite>max_iterations</cite>) the while loop is run.</p>
<section id="id39">
<h4>Reference<a class="headerlink" href="#id39" title="Link to this heading">#</a></h4>
<ul class="simple">
<li><p>Algorithm 3.1 in Nocedal, J. and Wright, S.J. eds., 1999. Numerical optimization. New York, NY: Springer New York. <a class="reference external" href="https://www.math.uci.edu/~qnie/Publications/NumericalOptimization.pdf">https://www.math.uci.edu/~qnie/Publications/NumericalOptimization.pdf</a>)</p></li>
<li><p><a class="reference external" href="https://projecteuclid.org/download/pdf_1/euclid.pjm/1102995080">https://projecteuclid.org/download/pdf_1/euclid.pjm/1102995080</a></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">param alpha<span class="colon">:</span></dt>
<dd class="field-odd"><p>The starting point for the step size iterations</p>
</dd>
<dt class="field-even">type alpha<span class="colon">:</span></dt>
<dd class="field-even"><p>float, optional, default=1e6</p>
</dd>
<dt class="field-odd">param beta<span class="colon">:</span></dt>
<dd class="field-odd"><p>The amount the step_size is reduced if the criterion is not met</p>
</dd>
<dt class="field-even">type beta<span class="colon">:</span></dt>
<dd class="field-even"><p>float between 0 and 1, optional, default=0.5</p>
</dd>
<dt class="field-odd">param max_iterations<span class="colon">:</span></dt>
<dd class="field-odd"><p>The maximum number of iterations to find a suitable step size</p>
</dd>
<dt class="field-even">type max_iterations<span class="colon">:</span></dt>
<dd class="field-even"><p>integer, optional, default is numpy.ceil (2 * numpy.log10(alpha) / numpy.log10(2))</p>
</dd>
<dt class="field-odd">param warmstart<span class="colon">:</span></dt>
<dd class="field-odd"><p>If <cite>warmstart = True</cite> the initial step size at each Armijo iteration is the calculated step size from the last iteration. If <cite>warmstart = False</cite> at each  Armijo iteration, the initial step size is reset to the original, large <cite>alpha</cite>.
In the case of <em>well-behaved</em> convex functions, <cite>warmstart = True</cite> is likely to be computationally less expensive. In the case of non-convex functions, or particularly tricky functions, setting <cite>warmstart = False</cite> may be beneficial.</p>
</dd>
<dt class="field-even">type warmstart<span class="colon">:</span></dt>
<dd class="field-even"><p>Boolean, default is True</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.utilities.StepSizeMethods.ArmijoStepSizeRule.get_step_size">
<span class="sig-name descname"><span class="pre">get_step_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/StepSizeMethods/#ArmijoStepSizeRule.get_step_size"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.StepSizeMethods.ArmijoStepSizeRule.get_step_size" title="Link to this definition">#</a></dt>
<dd><p>Applies the Armijo rule to calculate the step size (<cite>step_size</cite>)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>the calculated step size</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

</section>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.utilities.StepSizeMethods.BarzilaiBorweinStepSizeRule">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.utilities.StepSizeMethods.</span></span><span class="sig-name descname"><span class="pre">BarzilaiBorweinStepSizeRule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'short'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stabilisation_param</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/StepSizeMethods/#BarzilaiBorweinStepSizeRule"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.StepSizeMethods.BarzilaiBorweinStepSizeRule" title="Link to this definition">#</a></dt>
<dd><p>Applies the Barzilai- Borwein rule to calculate the step size (step_size).</p>
<p>Let <span class="math notranslate nohighlight">\(\Delta x=x_k-x_{k-1}\)</span> and <span class="math notranslate nohighlight">\(\Delta g=g_k-g_{k-1}\)</span>. Where <span class="math notranslate nohighlight">\(x_k\)</span> is the <span class="math notranslate nohighlight">\(k\)</span> th iterate (current solution after iteration <span class="math notranslate nohighlight">\(k\)</span> ) and <span class="math notranslate nohighlight">\(g_k\)</span> is the gradient calculation in the <span class="math notranslate nohighlight">\(k\)</span> th iterate, found in <code class="code docutils literal notranslate"><span class="pre">algorithm.gradient_update</span></code>.  A Barzilai-Borwein (BB) iteration is <span class="math notranslate nohighlight">\(x_{k+1}=x_k-\alpha_kg_k\)</span> where the step size <span class="math notranslate nohighlight">\(\alpha _k\)</span> is either</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\alpha_k^{LONG}=\frac{\Delta x\cdot\Delta x}{\Delta x\cdot\Delta g}\)</span>, or</p></li>
<li><p><span class="math notranslate nohighlight">\(\alpha_k^{SHORT}=\frac{\Delta x \cdot\Delta g}{\Delta g \cdot\Delta g}\)</span>.</p></li>
</ul>
<p>Where the operator <span class="math notranslate nohighlight">\(\cdot\)</span> is the standard inner product between two vectors.</p>
<p>This is suitable for use with gradient based iterative methods where the calculated gradient is stored as <cite>algorithm.gradient_update</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial</strong> (<em>float</em><em>, </em><em>greater than zero</em>) – The step-size for the first iteration. We recommend something of the order <span class="math notranslate nohighlight">\(1/f.L\)</span> where <span class="math notranslate nohighlight">\(f\)</span> is the (differentiable part of) the objective you wish to minimise.</p></li>
<li><p><strong>mode</strong> (<em>One</em><em> of </em><em>'long'</em><em>, </em><em>'short'</em><em> or </em><em>'alternate'</em><em>, </em><em>default is 'short'.</em>) – This calculates the step-size based on the LONG, SHORT or alternating between the two, starting with short.</p></li>
<li><p><strong>stabilisation_param</strong> (<em>'auto'</em><em>, </em><em>float</em><em> or </em><em>'off'</em><em>, </em><em>default is 'auto'</em>) – In order to add stability the step-size has an upper limit of <span class="math notranslate nohighlight">\(\Delta/\|g_k\|\)</span> where by ‘default’, the <cite>stabilisation_param</cite>, <span class="math notranslate nohighlight">\(\Delta\)</span> is  determined automatically to be the minimium of <span class="math notranslate nohighlight">\(\Delta x\)</span> from the first 3 iterations. The user can also pass a fixed constant or turn “off” the stabilisation, equivalently passing <cite>np.inf</cite>.</p></li>
</ul>
</dd>
</dl>
<section id="id40">
<h4>Reference<a class="headerlink" href="#id40" title="Link to this heading">#</a></h4>
<ul class="simple">
<li><p>Barzilai, Jonathan; Borwein, Jonathan M. (1988). “Two-Point Step Size Gradient Methods”. IMA Journal of Numerical Analysis. 8: 141–148, <a class="reference external" href="https://doi.org/10.1093/imanum/8.1.141">https://doi.org/10.1093/imanum/8.1.141</a></p></li>
<li><p>Burdakov, O., Dai, Y. and Huang, N., 2019. STABILIZED BARZILAI-BORWEIN METHOD. Journal of Computational Mathematics, 37(6). <a class="reference external" href="https://doi.org/10.4208/jcm.1911-m2019-0171">https://doi.org/10.4208/jcm.1911-m2019-0171</a></p></li>
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Barzilai-Borwein_method">https://en.wikipedia.org/wiki/Barzilai-Borwein_method</a></p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.utilities.StepSizeMethods.BarzilaiBorweinStepSizeRule.get_step_size">
<span class="sig-name descname"><span class="pre">get_step_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/StepSizeMethods/#BarzilaiBorweinStepSizeRule.get_step_size"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.StepSizeMethods.BarzilaiBorweinStepSizeRule.get_step_size" title="Link to this definition">#</a></dt>
<dd><p>Applies the B-B rule to calculate the step size (<cite>step_size</cite>)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>the calculated step size</strong></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

</section>
</dd></dl>

</section>
<section id="preconditioners">
<h3>Preconditioners<a class="headerlink" href="#preconditioners" title="Link to this heading">#</a></h3>
<p>A preconditioner is a class which acts on an algorithm and can be passed to  <cite>cil.optimisation.algorithm.GD</cite>, <cite>cil.optimisation.algorithm.ISTA</cite> or <cite>cil.optimisation.algorithm.FISTA</cite> and it’s method <cite>apply</cite> is called after the calculation of the gradient before the gradient descent step is taken. It modifies and returns a passed <cite>gradient</cite>.</p>
<p>Currently in CIL we have a base class:</p>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.utilities.preconditioner.Preconditioner">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.utilities.preconditioner.</span></span><span class="sig-name descname"><span class="pre">Preconditioner</span></span><a class="reference internal" href="../_modules/cil/optimisation/utilities/preconditioner/#Preconditioner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.preconditioner.Preconditioner" title="Link to this definition">#</a></dt>
<dd><p>Abstract base class for Preconditioner objects. The <cite>apply</cite> method of this class takes an initialised CIL function as an argument and modifies a provided  <cite>gradient</cite>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.utilities.preconditioner.Preconditioner.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/preconditioner/#Preconditioner.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.preconditioner.Preconditioner.apply" title="Link to this definition">#</a></dt>
<dd><p>Abstract method to call the preconditioner.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id41">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/preconditioner/#Preconditioner.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id41" title="Link to this definition">#</a></dt>
<dd><p>Abstract method to apply the preconditioner.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>algorithm</strong> (<a class="reference internal" href="#cil.optimisation.algorithms.Algorithm" title="cil.optimisation.algorithms.Algorithm"><em>Algorithm</em></a>) – The algorithm object.</p></li>
<li><p><strong>gradient</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The calculated gradient to modify</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>,</em>) – Container to fill with the modified gradient.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In CIL algorithms, the preconditioners are used in-place. Make sure this method is safe to use in place.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The modified gradient</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<p>We also have a number of already provided pre-conditioners</p>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.utilities.preconditioner.Sensitivity">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.utilities.preconditioner.</span></span><span class="sig-name descname"><span class="pre">Sensitivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/preconditioner/#Sensitivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.preconditioner.Sensitivity" title="Link to this definition">#</a></dt>
<dd><p>Sensitivity preconditioner class.</p>
<p>In each call to the preconditioner the <cite>gradient</cite> is multiplied by <span class="math notranslate nohighlight">\(1/(A^T \mathbf{1})\)</span> where <span class="math notranslate nohighlight">\(A\)</span> is an operator, <span class="math notranslate nohighlight">\(\mathbf{1}\)</span> is an object in the range of the operator filled with ones.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>operator</strong> (<em>CIL Operator</em>) – The operator used for sensitivity computation.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.utilities.preconditioner.Sensitivity.compute_preconditioner_matrix">
<span class="sig-name descname"><span class="pre">compute_preconditioner_matrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/preconditioner/#Sensitivity.compute_preconditioner_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.preconditioner.Sensitivity.compute_preconditioner_matrix" title="Link to this definition">#</a></dt>
<dd><p>Compute the sensitivity. <span class="math notranslate nohighlight">\(A^T \mathbf{1}\)</span> where <span class="math notranslate nohighlight">\(A\)</span> is the operator and <span class="math notranslate nohighlight">\(\mathbf{1}\)</span> is an object in the range of the operator filled with ones.
Then perform safe division by the sensitivity to store the preconditioner array <span class="math notranslate nohighlight">\(1/(A^T \mathbf{1})\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.utilities.preconditioner.Sensitivity.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/preconditioner/#Sensitivity.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.preconditioner.Sensitivity.apply" title="Link to this definition">#</a></dt>
<dd><p>Update the preconditioner.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>algorithm</strong> (<em>object</em>) – The algorithm object.</p></li>
<li><p><strong>gradient</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The calculated gradient to modify</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>,</em>) – Container to fill with the modified gradient</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The modified gradient</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.utilities.preconditioner.AdaptiveSensitivity">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.utilities.preconditioner.</span></span><span class="sig-name descname"><span class="pre">AdaptiveSensitivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/preconditioner/#AdaptiveSensitivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.preconditioner.AdaptiveSensitivity" title="Link to this definition">#</a></dt>
<dd><p>Adaptive Sensitivity preconditioner class.</p>
<p>In each call to the preconditioner the <cite>gradient</cite> is multiplied by <span class="math notranslate nohighlight">\((x+\delta) /(A^T \mathbf{1})\)</span> where <span class="math notranslate nohighlight">\(A\)</span> is an operator,  <span class="math notranslate nohighlight">\(\mathbf{1}\)</span> is an object in the range of the operator filled with ones.
The point <span class="math notranslate nohighlight">\(x\)</span> is the current iteration, or a reference image,  and <span class="math notranslate nohighlight">\(\delta\)</span> is a small positive float.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operator</strong> (<em>CIL object</em>) – The operator used for sensitivity computation.</p></li>
<li><p><strong>delta</strong> (<em>float</em><em>, </em><em>optional</em>) – The delta value for the preconditioner.</p></li>
<li><p><strong>reference</strong> (<em>DataContainer e.g. ImageData</em><em>, </em><em>default is None</em>) – Reference data, an object in the domain of the operator. Recommended to be a best guess reconstruction. If reference data is passed the preconditioner is always fixed.</p></li>
<li><p><strong>max_iterations</strong> (<em>int</em><em>,  </em><em>default = 100</em>) – The maximum number of iterations before the preconditoner is frozen and no-longer updates. Note that if reference data is passed the preconditioner is always frozen and <cite>iterations</cite> is set to -1.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A reference for the freezing of the preconditioner can be found: Twyman R., Arridge S., Kereta Z., Jin B., Brusaferri L., Ahn S., Stearns CW., Hutton B.F., Burger I.A., Kotasidis F., Thielemans K.. An Investigation of Stochastic Variance Reduction Algorithms for Relative Difference Penalized 3D PET Image Reconstruction. IEEE Trans Med Imaging. 2023 Jan;42(1):29-41. doi: 10.1109/TMI.2022.3203237. Epub 2022 Dec 29. PMID: 36044488.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.utilities.preconditioner.AdaptiveSensitivity.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algorithm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/utilities/preconditioner/#AdaptiveSensitivity.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.utilities.preconditioner.AdaptiveSensitivity.apply" title="Link to this definition">#</a></dt>
<dd><p>Update the preconditioner.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>algorithm</strong> (<em>object</em>) – The algorithm object.</p></li>
<li><p><strong>gradient</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>) – The calculated gradient to modify</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em>,</em>) – Container to fill with the modified gradient</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The modified gradient</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer">DataContainer</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>
</section>
<section id="block-framework">
<h1>Block Framework<a class="headerlink" href="#block-framework" title="Link to this heading">#</a></h1>
<p>To be able to express more advanced optimisation problems we developed the
<a class="reference internal" href="#block-framework">Block Framework</a>, which provides a generic strategy to treat variational
problems in the following form:</p>
<div class="math notranslate nohighlight">
\[\min \text{Regulariser} + \text{Fidelity}\]</div>
<p>The block framework consists of:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#blockdatacontainer"><span class="std std-ref">BlockDataContainer</span></a></p></li>
<li><p><a class="reference internal" href="#block-function"><span class="std std-ref">BlockFunction</span></a></p></li>
<li><p><a class="reference internal" href="#block-operator"><span class="std std-ref">BlockOperator</span></a></p></li>
</ul>
<p>The block framework allows writing more advanced optimisation problems. Consider the typical
<a class="reference external" href="https://en.wikipedia.org/wiki/Tikhonov_regularization">Tikhonov regularisation</a>:</p>
<div class="math notranslate nohighlight">
\[\underset{u}{\mathrm{argmin}}\begin{Vmatrix}A u - b \end{Vmatrix}^2_2 + \alpha^2\|Lu\|^2_2\]</div>
<p>where,</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(A\)</span> is the projection operator</p></li>
<li><p><span class="math notranslate nohighlight">\(b\)</span> is the acquired data</p></li>
<li><p><span class="math notranslate nohighlight">\(u\)</span> is the unknown image to be solved for</p></li>
<li><p><span class="math notranslate nohighlight">\(\alpha\)</span> is the regularisation parameter</p></li>
<li><p><span class="math notranslate nohighlight">\(L\)</span> is a regularisation operator</p></li>
</ul>
<p>The first term measures the fidelity of the solution to the data. The second term measures the
fidelity to the prior knowledge we have imposed on the system, operator <span class="math notranslate nohighlight">\(L\)</span>.</p>
<p>This can be re-written equivalently in the block matrix form:</p>
<div class="math notranslate nohighlight">
\[\underset{u}{\mathrm{argmin}}\begin{Vmatrix}\binom{A}{\alpha L} u - \binom{b}{0}\end{Vmatrix}^2_2\]</div>
<p>With the definitions:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\tilde{A} = \binom{A}{\alpha L}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\tilde{b} = \binom{b}{0}\)</span></p></li>
</ul>
<p>this can now be recognised as a least squares problem which can be solved by any algorithm in the <code class="code docutils literal notranslate"><span class="pre">cil.optimisation</span></code>
which can solve least squares problem, e.g. CGLS.</p>
<div class="math notranslate nohighlight">
\[\underset{u}{\mathrm{argmin}}\begin{Vmatrix}\tilde{A} u - \tilde{b}\end{Vmatrix}^2_2\]</div>
<p>To be able to express our optimisation problems in the matrix form above, we developed the so-called,
Block Framework comprising 4 main actors: <code class="code docutils literal notranslate"><span class="pre">BlockGeometry</span></code>, <code class="code docutils literal notranslate"><span class="pre">BlockDataContainer</span></code>,
<code class="code docutils literal notranslate"><span class="pre">BlockFunction</span></code> and <code class="code docutils literal notranslate"><span class="pre">BlockOperator</span></code>.</p>
<section id="blockdatacontainer">
<h2>BlockDataContainer<a class="headerlink" href="#blockdatacontainer" title="Link to this heading">#</a></h2>
<p><a class="reference internal" href="#blockdatacontainer"><span class="std std-ref">BlockDataContainer</span></a> holds <a class="reference external" href="../framework/#datacontainer">DataContainer</a> as column vector. It is possible to
do basic algebra between <a class="reference internal" href="#blockdatacontainer"><span class="std std-ref">BlockDataContainer</span></a> s and with numbers, list or numpy arrays.</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}x = [x_{1}, x_{2} ]\in (X_{1}\times X_{2})\\y = [y_{1}, y_{2}, y_{3} ]\in(Y_{1}\times Y_{2} \times Y_{3})\end{aligned}\end{align} \]</div>
<dl class="py class">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.framework.</span></span><span class="sig-name descname"><span class="pre">BlockDataContainer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/block/#BlockDataContainer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer" title="Link to this definition">#</a></dt>
<dd><p>Class to hold DataContainers as column vector</p>
<p>Provides basic algebra between BlockDataContainer’s, DataContainer’s and
subclasses and Numbers</p>
<ol class="arabic simple">
<li><p>algebra between <a href="#id42"><span class="problematic" id="id43">`</span></a>BlockDataContainer`s will be element-wise, only if
the shape of the 2 <a href="#id44"><span class="problematic" id="id45">`</span></a>BlockDataContainer`s is the same, otherwise it
will fail</p></li>
<li><p>algebra between <cite>BlockDataContainer`s and `list</cite> or <cite>numpy array</cite> will
work as long as the number of <cite>rows</cite> and element of the arrays match,
independently on the fact that the <cite>BlockDataContainer</cite> could be nested</p></li>
<li><p>algebra between <cite>BlockDataContainer</cite> and one <cite>DataContainer</cite> is possible.
It will require all the <cite>DataContainers</cite> in the block to be
compatible with the <cite>DataContainer</cite> we want to operate with.</p></li>
<li><p>algebra between <cite>BlockDataContainer</cite> and a <cite>Number</cite> is possible and it
will be done with each element of the <cite>BlockDataContainer</cite> even if nested</p></li>
</ol>
<p>A = [ [B,C] , D]
A * 3 = [ 3 * [B,C] , 3* D] = [ [ 3*B, 3*C]  , 3*D ]</p>
<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.__iter__">
<span class="sig-name descname"><span class="pre">__iter__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/block/#BlockDataContainer.__iter__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__iter__" title="Link to this definition">#</a></dt>
<dd><p>BlockDataContainer is Iterable</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.next">
<span class="sig-name descname"><span class="pre">next</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/block/#BlockDataContainer.next"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.next" title="Link to this definition">#</a></dt>
<dd><p>python2 backwards compatibility</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.is_compatible">
<span class="sig-name descname"><span class="pre">is_compatible</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/block/#BlockDataContainer.is_compatible"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.is_compatible" title="Link to this definition">#</a></dt>
<dd><p>basic check if the size of the 2 objects fit</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/block/#BlockDataContainer.add"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.add" title="Link to this definition">#</a></dt>
<dd><p>Algebra: add method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other</strong> (<em>number</em><em>, </em><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><em>subclasses</em><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>optional</em>) – Provides a placeholder for the result</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.subtract">
<span class="sig-name descname"><span class="pre">subtract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/block/#BlockDataContainer.subtract"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.subtract" title="Link to this definition">#</a></dt>
<dd><p>Algebra: subtract method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other</strong> (<em>number</em><em>, </em><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><em>subclasses</em><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>optional</em>) – Provides a placeholder for the result</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.multiply">
<span class="sig-name descname"><span class="pre">multiply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/block/#BlockDataContainer.multiply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.multiply" title="Link to this definition">#</a></dt>
<dd><p>Algebra: multiply method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other</strong> (<em>number</em><em>, </em><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><em>subclasses</em><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>optional</em>) – Provides a placeholder for the result</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.divide">
<span class="sig-name descname"><span class="pre">divide</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/block/#BlockDataContainer.divide"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.divide" title="Link to this definition">#</a></dt>
<dd><p>Algebra: divide method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other</strong> (<em>number</em><em>, </em><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><em>subclasses</em><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>optional</em>) – Provides a placeholder for the result</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.power">
<span class="sig-name descname"><span class="pre">power</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/block/#BlockDataContainer.power"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.power" title="Link to this definition">#</a></dt>
<dd><p>Algebra: power method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other</strong> (<em>number</em><em>, </em><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><em>subclasses</em><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>optional</em>) – Provides a placeholder for the result</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.maximum">
<span class="sig-name descname"><span class="pre">maximum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/block/#BlockDataContainer.maximum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.maximum" title="Link to this definition">#</a></dt>
<dd><p>Algebra: maximum method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other</strong> (<em>number</em><em>, </em><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><em>subclasses</em><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>optional</em>) – Provides a placeholder for the result</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.minimum">
<span class="sig-name descname"><span class="pre">minimum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/block/#BlockDataContainer.minimum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.minimum" title="Link to this definition">#</a></dt>
<dd><p>Algebra: minimum method of BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other</strong> (<em>number</em><em>, </em><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a><em> or </em><em>subclasses</em><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>optional</em>) – Provides a placeholder for the result</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.sapyb">
<span class="sig-name descname"><span class="pre">sapyb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/block/#BlockDataContainer.sapyb"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.sapyb" title="Link to this definition">#</a></dt>
<dd><p>performs axpby element-wise on the BlockDataContainer containers</p>
<p>Does the operation .. math:: a*x+b*y and stores the result in out, where x is self</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>)</p></li>
<li><p><strong>b</strong> (<em>scalar</em><em> or </em><a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>)</p></li>
<li><p><strong>y</strong> (<em>compatible</em><em> (</em><em>Block</em><em>)</em><a class="reference internal" href="../framework/#cil.framework.DataContainer" title="cil.framework.DataContainer"><em>DataContainer</em></a>)</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>optional</em>) – Provides a placeholder for the result</p></li>
<li><p><strong>Example</strong></p></li>
<li><p><strong>--------</strong></p></li>
<li><p><strong>2</strong> (<em>&gt;&gt;&gt; a =</em>)</p></li>
<li><p><strong>3</strong> (<em>&gt;&gt;&gt; b =</em>)</p></li>
<li><p><strong>ImageGeometry</strong><strong>(</strong><strong>10</strong> (<em>&gt;&gt;&gt; ig =</em>)</p></li>
<li><p><strong>11</strong><strong>)</strong></p></li>
<li><p><strong>ig.allocate</strong><strong>(</strong><strong>1</strong><strong>)</strong> (<em>&gt;&gt;&gt; x =</em>)</p></li>
<li><p><strong>ig.allocate</strong><strong>(</strong><strong>2</strong><strong>)</strong> (<em>&gt;&gt;&gt; y =</em>)</p></li>
<li><p><strong>BlockDataContainer</strong><strong>(</strong><strong>2*x</strong> (<em>&gt;&gt;&gt; bdc1 =</em>)</p></li>
<li><p><strong>y</strong><strong>)</strong></p></li>
<li><p><strong>BlockDataContainer</strong><strong>(</strong><strong>x</strong> (<em>&gt;&gt;&gt; bdc2 =</em>)</p></li>
<li><p><strong>2*y</strong><strong>)</strong></p></li>
<li><p><strong>bdc1.sapyb</strong><strong>(</strong><strong>a</strong> (<em>&gt;&gt;&gt; out =</em>)</p></li>
<li><p><strong>bdc2</strong></p></li>
<li><p><strong>b</strong><strong>)</strong></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.axpby">
<span class="sig-name descname"><span class="pre">axpby</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_threads=2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/block/#BlockDataContainer.axpby"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.axpby" title="Link to this definition">#</a></dt>
<dd><p>Deprecated method. Alias of sapyb</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.binary_operations">
<span class="sig-name descname"><span class="pre">binary_operations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/block/#BlockDataContainer.binary_operations"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.binary_operations" title="Link to this definition">#</a></dt>
<dd><p>Algebra: generic method of algebric operation with BlockDataContainer with number/DataContainer or BlockDataContainer</p>
<p>Provides commutativity with DataContainer and subclasses, i.e. this
class’s reverse algebraic methods take precedence w.r.t. direct algebraic
methods of DataContainer and subclasses.</p>
<p>This method is not to be used directly</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.unary_operations">
<span class="sig-name descname"><span class="pre">unary_operations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operation</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/block/#BlockDataContainer.unary_operations"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.unary_operations" title="Link to this definition">#</a></dt>
<dd><p>Unary operation on BlockDataContainer:</p>
<p>generic method of unary operation with BlockDataContainer: abs, sign, sqrt and conjugate</p>
<p>This method is not to be used directly</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/block/#BlockDataContainer.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.copy" title="Link to this definition">#</a></dt>
<dd><p>alias of clone</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.__radd__">
<span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/block/#BlockDataContainer.__radd__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__radd__" title="Link to this definition">#</a></dt>
<dd><p>Reverse addition</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.__rsub__">
<span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/block/#BlockDataContainer.__rsub__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__rsub__" title="Link to this definition">#</a></dt>
<dd><p>Reverse subtraction</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/block/#BlockDataContainer.__rmul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__rmul__" title="Link to this definition">#</a></dt>
<dd><p>Reverse multiplication</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.__rdiv__">
<span class="sig-name descname"><span class="pre">__rdiv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/block/#BlockDataContainer.__rdiv__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__rdiv__" title="Link to this definition">#</a></dt>
<dd><p>Reverse division</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.__rtruediv__">
<span class="sig-name descname"><span class="pre">__rtruediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/block/#BlockDataContainer.__rtruediv__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__rtruediv__" title="Link to this definition">#</a></dt>
<dd><p>Reverse truedivision</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.__rpow__">
<span class="sig-name descname"><span class="pre">__rpow__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/block/#BlockDataContainer.__rpow__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__rpow__" title="Link to this definition">#</a></dt>
<dd><p>Reverse power</p>
<p>to make sure that this method is called rather than the __mul__ of a numpy array
the class constant __array_priority__ must be set &gt; 0
<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__">https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.classes.html#numpy.class.__array_priority__</a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.__iadd__">
<span class="sig-name descname"><span class="pre">__iadd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/block/#BlockDataContainer.__iadd__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__iadd__" title="Link to this definition">#</a></dt>
<dd><p>Inline addition</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.__isub__">
<span class="sig-name descname"><span class="pre">__isub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/block/#BlockDataContainer.__isub__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__isub__" title="Link to this definition">#</a></dt>
<dd><p>Inline subtraction</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.__imul__">
<span class="sig-name descname"><span class="pre">__imul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/block/#BlockDataContainer.__imul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__imul__" title="Link to this definition">#</a></dt>
<dd><p>Inline multiplication</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.__idiv__">
<span class="sig-name descname"><span class="pre">__idiv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/block/#BlockDataContainer.__idiv__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__idiv__" title="Link to this definition">#</a></dt>
<dd><p>Inline division</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.__itruediv__">
<span class="sig-name descname"><span class="pre">__itruediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/block/#BlockDataContainer.__itruediv__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__itruediv__" title="Link to this definition">#</a></dt>
<dd><p>Inline truedivision</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.__neg__">
<span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/framework/block/#BlockDataContainer.__neg__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.framework.BlockDataContainer.__neg__" title="Link to this definition">#</a></dt>
<dd><p>Return - self</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cil.framework.BlockDataContainer.__weakref__">
<span class="sig-name descname"><span class="pre">__weakref__</span></span><a class="headerlink" href="#cil.framework.BlockDataContainer.__weakref__" title="Link to this definition">#</a></dt>
<dd><p>list of weak references to the object</p>
</dd></dl>

</dd></dl>

</section>
<section id="block-function">
<h2>Block Function<a class="headerlink" href="#block-function" title="Link to this heading">#</a></h2>
<p><a class="reference internal" href="#block-function"><span class="std std-ref">BlockFunction</span></a> acts on <a class="reference internal" href="#blockdatacontainer"><span class="std std-ref">BlockDataContainer</span></a> as a separable sum function:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}f = [f_1,...,f_n] \newline\\f([x_1,...,x_n]) = f_1(x_1) +  .... + f_n(x_n)\end{aligned}\end{align} \]</div>
</div></blockquote>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}Y = \begin{bmatrix}
y_{1}\\
y_{2}\\
y_{3}\\
\end{bmatrix}, \quad  F  = [ f_{1}, f_{2}, f_{3} ]\end{split}\\F(Y) : = f_{1}(y_{1}) + f_{2}(y_{2}) + f_{3}(y_{3})\end{aligned}\end{align} \]</div>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.functions.BlockFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.functions.</span></span><span class="sig-name descname"><span class="pre">BlockFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">functions</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/BlockFunction/#BlockFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction" title="Link to this definition">#</a></dt>
<dd><p>BlockFunction represents a <em>separable sum</em> function <span class="math notranslate nohighlight">\(F\)</span> defined as</p>
<div class="math notranslate nohighlight">
\[F:X_{1}\times X_{2}\cdots\times X_{m} \rightarrow (-\infty, \infty]\]</div>
<p>where <span class="math notranslate nohighlight">\(F\)</span> is the separable sum of functions <span class="math notranslate nohighlight">\((f_{i})_{i=1}^{m}\)</span>,</p>
<div class="math notranslate nohighlight">
\[F(x_{1}, x_{2}, \cdots, x_{m}) = \overset{m}{\underset{i=1}{\sum}}f_{i}(x_{i}), \mbox{ with } f_{i}: X_{i} \rightarrow (-\infty, \infty].\]</div>
<p>A nice property (due to it’s separability structure) is that the proximal operator
can be decomposed along the proximal operators of each function <span class="math notranslate nohighlight">\(f_{i}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = ( \mathrm{prox}_{\tau f_{i}}(x_{i}) )_{i=1}^{m}\]</div>
<p>In addition, if <span class="math notranslate nohighlight">\(\tau := (\tau_{1},\dots,\tau_{m})\)</span>, then</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) = ( \mathrm{prox}_{\tau_{i} f_{i}}(x_{i}) )_{i=1}^{m}\]</div>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.BlockFunction.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">functions</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/BlockFunction/#BlockFunction.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.__init__" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.functions.BlockFunction.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.L" title="Link to this definition">#</a></dt>
<dd><p>Lipschitz of the gradient of function f.</p>
<p>L is positive real number, such that <span class="math notranslate nohighlight">\(\|f'(x) - f'(y)\| \leq L\|x-y\|\)</span>, assuming <span class="math notranslate nohighlight">\(f: IG \rightarrow \mathbb{R}\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.BlockFunction.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/BlockFunction/#BlockFunction.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.__call__" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the BlockFunction <span class="math notranslate nohighlight">\(F\)</span></p>
<div class="math notranslate nohighlight">
\[F(x) = \overset{m}{\underset{i=1}{\sum}}f_{i}(x_{i}), \mbox{ where } x = (x_{1}, x_{2}, \cdots, x_{m}), \quad i = 1,2,\dots,m\]</div>
<p>Parameter:</p>
<blockquote>
<div><p>x : BlockDataContainer and must have as many rows as self.length</p>
<p>returns ..math:: sum(f_i(x_i))</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.BlockFunction.convex_conjugate">
<span class="sig-name descname"><span class="pre">convex_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/BlockFunction/#BlockFunction.convex_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.convex_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the convex conjugate of the BlockFunction at <span class="math notranslate nohighlight">\(x^{*}\)</span>.</p>
<div class="math notranslate nohighlight">
\[F^{*}(x^{*}) = \overset{m}{\underset{i=1}{\sum}}f_{i}^{*}(x^{*}_{i})\]</div>
<p>Parameter:</p>
<blockquote>
<div><p>x : BlockDataContainer and must have as many rows as self.length</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.BlockFunction.proximal">
<span class="sig-name descname"><span class="pre">proximal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/BlockFunction/#BlockFunction.proximal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.proximal" title="Link to this definition">#</a></dt>
<dd><p>Proximal operator of the BlockFunction at x:</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F}(x) =  (\mathrm{prox}_{\tau f_{i}}(x_{i}))_{i=1}^{m}\]</div>
<p>Parameter:</p>
<blockquote>
<div><p>x : BlockDataContainer and must have as many rows as self.length</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.BlockFunction.gradient">
<span class="sig-name descname"><span class="pre">gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/BlockFunction/#BlockFunction.gradient"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.gradient" title="Link to this definition">#</a></dt>
<dd><p>Returns the value of the gradient of the BlockFunction function at x.</p>
<div class="math notranslate nohighlight">
\[F'(x) = [f_{1}'(x_{1}), ... , f_{m}'(x_{m})]\]</div>
<p>Parameter:</p>
<blockquote>
<div><p>x : BlockDataContainer and must have as many rows as self.length</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.BlockFunction.proximal_conjugate">
<span class="sig-name descname"><span class="pre">proximal_conjugate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/BlockFunction/#BlockFunction.proximal_conjugate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.proximal_conjugate" title="Link to this definition">#</a></dt>
<dd><p>Proximal operator of the convex conjugate of BlockFunction at x:</p>
<div class="math notranslate nohighlight">
\[\mathrm{prox}_{\tau F^{*}}(x) = (\mathrm{prox}_{\tau f^{*}_{i}}(x^{*}_{i}))_{i=1}^{m}\]</div>
<p>Parameter:</p>
<blockquote>
<div><p>x : BlockDataContainer and must have as many rows as self.length</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.functions.BlockFunction.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/functions/BlockFunction/#BlockFunction.__rmul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.functions.BlockFunction.__rmul__" title="Link to this definition">#</a></dt>
<dd><p>Define multiplication with a scalar</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – number</p>
</dd>
</dl>
<p>Returns a new <a class="reference internal" href="#block-function"><span class="std std-ref">BlockFunction</span></a> containing the product of the scalar with all the functions in the block</p>
</dd></dl>

</dd></dl>

</section>
<section id="block-operator">
<h2>Block Operator<a class="headerlink" href="#block-operator" title="Link to this heading">#</a></h2>
<p><a class="reference internal" href="#block-operator"><span class="std std-ref">BlockOperator</span></a> represent a block matrix with operators</p>
<div class="math notranslate nohighlight">
\[\begin{split}K = \begin{bmatrix}
     A_{1} &amp; A_{2} \\
     A_{3} &amp; A_{4} \\
     A_{5} &amp; A_{6}
\end{bmatrix}_{(3,2)} *  \quad \underbrace{\begin{bmatrix}
x_{1} \\
x_{2}
\end{bmatrix}_{(2,1)}}_{\textbf{x}} =  \begin{bmatrix}
A_{1}x_{1}  + A_{2}x_{2}\\
A_{3}x_{1}  + A_{4}x_{2}\\
A_{5}x_{1}  + A_{6}x_{2}\\
\end{bmatrix}_{(3,1)} =  \begin{bmatrix}
y_{1}\\
y_{2}\\
y_{3}
\end{bmatrix}_{(3,1)} = \textbf{y}\end{split}\]</div>
<p>Column: Share the same domains <span class="math notranslate nohighlight">\(X_{1}, X_{2}\)</span></p>
<p>Rows: Share the same ranges <span class="math notranslate nohighlight">\(Y_{1}, Y_{2}, Y_{3}\)</span></p>
<div class="math notranslate nohighlight">
\[K : (X_{1}\times X_{2}) \rightarrow (Y_{1}\times Y_{2} \times Y_{3})\]</div>
<p><span class="math notranslate nohighlight">\(A_{1}, A_{3}, A_{5}\)</span>: share the same domain <span class="math notranslate nohighlight">\(X_{1}\)</span> and
<span class="math notranslate nohighlight">\(A_{2}, A_{4}, A_{6}\)</span>: share the same domain <span class="math notranslate nohighlight">\(X_{2}\)</span></p>
<div class="math notranslate nohighlight">
\[\begin{split}A_{1}: X_{1} \rightarrow Y_{1} \\
A_{3}: X_{1} \rightarrow Y_{2} \\
A_{5}: X_{1} \rightarrow Y_{3} \\
A_{2}: X_{2} \rightarrow Y_{1} \\
A_{4}: X_{2} \rightarrow Y_{2} \\
A_{6}: X_{2} \rightarrow Y_{3}\end{split}\]</div>
<p>For instance with these ingredients one may write the following objective
function,</p>
<div class="math notranslate nohighlight">
\[\alpha ||\nabla u||_{2,1} + ||u - g||_2^2\]</div>
<p>where <span class="math notranslate nohighlight">\(g\)</span> represent the measured values, <span class="math notranslate nohighlight">\(u\)</span> the solution
<span class="math notranslate nohighlight">\(\nabla\)</span> is the gradient operator, <span class="math notranslate nohighlight">\(|| ~~ ||_{2,1}\)</span> is a norm for
the output of the gradient operator and <span class="math notranslate nohighlight">\(|| x-g ||^2_2\)</span> is
least squares fidelity function as</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}K = \begin{bmatrix}
          \nabla \\
          \mathbb{1}
        \end{bmatrix}\end{split}\\F(x) = \Big[ \alpha \lVert ~x~ \rVert_{2,1} ~~ , ~~ || x - g||_2^2 \Big]\\w = [ u ]\end{aligned}\end{align} \]</div>
<p>Then we have rewritten the problem as</p>
<div class="math notranslate nohighlight">
\[F(Kw) =   \alpha \left\lVert \nabla u \right\rVert_{2,1} + ||u-g||^2_2\]</div>
<p>Which in Python would be like</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">op1</span> <span class="o">=</span> <span class="n">GradientOperator</span><span class="p">(</span><span class="n">ig</span><span class="p">,</span> <span class="n">correlation</span><span class="o">=</span><span class="n">GradientOperator</span><span class="o">.</span><span class="n">CORRELATION_SPACE</span><span class="p">)</span>
<span class="n">op2</span> <span class="o">=</span> <span class="n">IdentityOperator</span><span class="p">(</span><span class="n">ig</span><span class="p">,</span> <span class="n">ag</span><span class="p">)</span>

<span class="c1"># Create BlockOperator</span>
<span class="n">K</span> <span class="o">=</span> <span class="n">BlockOperator</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>

<span class="c1"># Create functions</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">BlockFunction</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">MixedL21Norm</span><span class="p">(),</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">L2NormSquared</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="n">noisy_data</span><span class="p">))</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cil.optimisation.operators.</span></span><span class="sig-name descname"><span class="pre">BlockOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator" title="Link to this definition">#</a></dt>
<dd><p>A Block matrix containing Operators</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> (<a class="reference internal" href="#cil.optimisation.operators.Operator" title="cil.optimisation.operators.Operator"><em>Operator</em></a>) – Operators in the block.</p></li>
<li><p><strong>**kwargs</strong> (<em>dict</em>) – shape (<code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code>, optional): If shape is passed the Operators in vararg are considered input in a row-by-row fashion.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Block Framework is a generic strategy to treat variational problems in the
following form:</p>
<div class="math notranslate nohighlight">
\[\min Regulariser + Fidelity\]</div>
</div>
<p>BlockOperators have a generic shape M x N, and when applied on an
Nx1 BlockDataContainer, will yield and Mx1 BlockDataContainer.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>BlockDatacontainer are only allowed to have the shape of N x 1, with
N rows and 1 column.</p>
<p>User may specify the shape of the block, by default is a row vector</p>
<p>Operators in a Block are required to have the same domain column-wise and the
same range row-wise.</p>
</div>
<p class="rubric">Examples</p>
<p>BlockOperator(op0,op1) results in a row block</p>
<p>BlockOperator(op0,op1,shape=(1,2)) results in a column block</p>
<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.__init__" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.column_wise_compatible">
<span class="sig-name descname"><span class="pre">column_wise_compatible</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.column_wise_compatible"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.column_wise_compatible" title="Link to this definition">#</a></dt>
<dd><p>Operators in a Block should have the same domain per column</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.row_wise_compatible">
<span class="sig-name descname"><span class="pre">row_wise_compatible</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.row_wise_compatible"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.row_wise_compatible" title="Link to this definition">#</a></dt>
<dd><p>Operators in a Block should have the same range per row</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.get_item">
<span class="sig-name descname"><span class="pre">get_item</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">row</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.get_item"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.get_item" title="Link to this definition">#</a></dt>
<dd><p>Returns the Operator at specified row and col
:param row: The row index required.
:type row: <cite>int</cite>
:param col: The column index required.
:type col: <cite>int</cite></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.norm" title="Link to this definition">#</a></dt>
<dd><p>Returns the Euclidean norm of the norms of the individual operators in the BlockOperators</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.get_norms_as_list">
<span class="sig-name descname"><span class="pre">get_norms_as_list</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.get_norms_as_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.get_norms_as_list" title="Link to this definition">#</a></dt>
<dd><p>Returns a list of the individual norms of the Operators in the BlockOperator</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.set_norms">
<span class="sig-name descname"><span class="pre">set_norms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norms</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.set_norms"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.set_norms" title="Link to this definition">#</a></dt>
<dd><p>Uses the set_norm() function in Operator to set the norms of the operators in the BlockOperator from a list of custom values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>norms</strong> (<em>list</em>) – A list of positive real values the same length as the number of operators in the BlockOperator.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.direct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.direct" title="Link to this definition">#</a></dt>
<dd><p>Direct operation for the BlockOperator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>) – The input BlockDataContainer to apply the BlockOperator on. Can be a DataContainer if the domain geometry permits.</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>optional</em>) – The output BlockDataContainer to store the result of the operation. If not provided, a new BlockDataContainer is created. Can be a DataContainer if the range geometry permits.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>BlockOperators work on BlockDataContainers, but they will also work on DataContainers
and inherited classes by simple wrapping the input in a BlockDataContainer of shape (1,1)</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.adjoint">
<span class="sig-name descname"><span class="pre">adjoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.adjoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.adjoint" title="Link to this definition">#</a></dt>
<dd><p>Adjoint operation for the BlockOperator</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a>) – The input BlockDataContainer to apply the BlockOperator adjoint on. Can be a DataContainer if the range geometry permits.</p></li>
<li><p><strong>out</strong> (<a class="reference internal" href="#cil.framework.BlockDataContainer" title="cil.framework.BlockDataContainer"><em>BlockDataContainer</em></a><em>, </em><em>optional</em>) – The output BlockDataContainer to store the result of the operation. If not provided, a new BlockDataContainer is created. Can be a DataContainer if the domain geometry permits.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>BlockOperator may contain both LinearOperator and Operator
This method exists in BlockOperator as it is not known what type of
Operator it will contain.</p>
<p>BlockOperators work on BlockDataContainers, but they will also work on DataContainers
and inherited classes by simple wrapping the input in a BlockDataContainer of shape (1,1)</p>
<p>Raises: ValueError if the contained Operators are not linear</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.is_linear">
<span class="sig-name descname"><span class="pre">is_linear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.is_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.is_linear" title="Link to this definition">#</a></dt>
<dd><p>Returns whether all the elements of the BlockOperator are linear</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.get_output_shape">
<span class="sig-name descname"><span class="pre">get_output_shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xshape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adjoint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.get_output_shape"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.get_output_shape" title="Link to this definition">#</a></dt>
<dd><p>Returns the shape of the output BlockDataContainer
:param xshape:
:type xshape: BlockDataContainer
:param adjoint:
:type adjoint: <cite>bool</cite></p>
<p class="rubric">Examples</p>
<p>A(N,M) direct u(M,1) -&gt; N,1</p>
<p>A(N,M)^T adjoint u(N,1) -&gt; M,1</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.__rmul__">
<span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scalar</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.__rmul__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.__rmul__" title="Link to this definition">#</a></dt>
<dd><p>Defines the left multiplication with a scalar. Returns a block operator with Scaled Operators inside.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>scalar</strong> (<em>number</em><em> or </em><em>iterable containing numbers</em>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.T">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">T</span></span><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.T" title="Link to this definition">#</a></dt>
<dd><p>Returns the transposed of self.</p>
<p>Recall the input list is shaped in a row-by-row fashion</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.domain_geometry">
<span class="sig-name descname"><span class="pre">domain_geometry</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.domain_geometry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.domain_geometry" title="Link to this definition">#</a></dt>
<dd><p>Returns the domain of the BlockOperator</p>
<p>If the shape of the BlockOperator is (N,1) the domain is a ImageGeometry or AcquisitionGeometry.
Otherwise it is a BlockGeometry.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.range_geometry">
<span class="sig-name descname"><span class="pre">range_geometry</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.range_geometry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.range_geometry" title="Link to this definition">#</a></dt>
<dd><p>Returns the range of the BlockOperator</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.__getitem__">
<span class="sig-name descname"><span class="pre">__getitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.__getitem__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.__getitem__" title="Link to this definition">#</a></dt>
<dd><p>Returns the index-th operator in the block irrespectively of it’s shape</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cil.optimisation.operators.BlockOperator.get_as_list">
<span class="sig-name descname"><span class="pre">get_as_list</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/cil/optimisation/operators/BlockOperator/#BlockOperator.get_as_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cil.optimisation.operators.BlockOperator.get_as_list" title="Link to this definition">#</a></dt>
<dd><p>Returns the list of operators</p>
</dd></dl>

</dd></dl>

<p><a class="reference internal" href="../#mastertoc"><span class="std std-ref">Return Home</span></a></p>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Link to this heading">#</a></h3>
<div class="docutils container" id="id47">
<div role="list" class="citation-list">
<div class="citation" id="id55" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id2">1</a>,<a role="doc-backlink" href="#id5">2</a>,<a role="doc-backlink" href="#id17">3</a>)</span>
<p>Amir Beck and Marc Teboulle. A fast iterative shrinkage-thresholding algorithm for linear inverse problems. <em>SIAM Journal on Imaging Sciences</em>, 2(1):183–202, 2009. URL: <a class="reference external" href="https://doi.org/10.1137/080716542">https://doi.org/10.1137/080716542</a>, <a class="reference external" href="https://arxiv.org/abs/https://doi.org/10.1137/080716542">arXiv:https://doi.org/10.1137/080716542</a>, <a class="reference external" href="https://doi.org/10.1137/080716542">doi:10.1137/080716542</a>.</p>
</div>
<div class="citation" id="id54" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id3">1</a>,<a role="doc-backlink" href="#id6">2</a>,<a role="doc-backlink" href="#id18">3</a>)</span>
<p>Amir Beck and Marc Teboulle. Fast gradient-based algorithms for constrained total variation image denoising and deblurring problems. <em>IEEE Transactions on Image Processing</em>, 18(11):2419–2434, 2009. <a class="reference external" href="https://doi.org/10.1109/TIP.2009.2028250">doi:10.1109/TIP.2009.2028250</a>.</p>
</div>
<div class="citation" id="id50" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id9">1</a>,<a role="doc-backlink" href="#id21">2</a>)</span>
<p>Antonin Chambolle and Thomas Pock. A first-order primal-dual algorithm for convex problems with applications to imaging. <em>Journal of Mathematical Imaging and Vision</em>, 40(1):120–145, May 2011. URL: <a class="reference external" href="https://doi.org/10.1007/s10851-010-0251-1">https://doi.org/10.1007/s10851-010-0251-1</a>, <a class="reference external" href="https://doi.org/10.1007/s10851-010-0251-1">doi:10.1007/s10851-010-0251-1</a>.</p>
</div>
<div class="citation" id="id59" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">4</a><span class="fn-bracket">]</span></span>
<p>Patrick L. Combettes and Valérie R. Wajs. Signal recovery by proximal forward-backward splitting. <em>Multiscale Modeling &amp; Simulation</em>, 4(4):1168–1200, 2005. URL: <a class="reference external" href="https://doi.org/10.1137/050626090">https://doi.org/10.1137/050626090</a>, <a class="reference external" href="https://arxiv.org/abs/https://doi.org/10.1137/050626090">arXiv:https://doi.org/10.1137/050626090</a>, <a class="reference external" href="https://doi.org/10.1137/050626090">doi:10.1137/050626090</a>.</p>
</div>
<div class="citation" id="id51" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id10">5</a><span class="fn-bracket">]</span></span>
<p>Ernie Esser, Xiaoqun Zhang, and Tony F. Chan. A general framework for a class of first order primal-dual algorithms for convex optimization in imaging science. <em>SIAM Journal on Imaging Sciences</em>, 3(4):1015–1046, 2010. URL: <a class="reference external" href="https://doi.org/10.1137/09076934X">https://doi.org/10.1137/09076934X</a>, <a class="reference external" href="https://arxiv.org/abs/https://doi.org/10.1137/09076934X">arXiv:https://doi.org/10.1137/09076934X</a>, <a class="reference external" href="https://doi.org/10.1137/09076934X">doi:10.1137/09076934X</a>.</p>
</div>
<div class="citation" id="id48" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">6</a><span class="fn-bracket">]</span></span>
<p>Osman Güler. New proximal point algorithms for convex minimization. <em>SIAM Journal on Optimization</em>, 2(4):649–664, 1992.</p>
</div>
<div class="citation" id="id53" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id11">7</a><span class="fn-bracket">]</span></span>
<p>J. S. Jörgensen, E. Ametova, G. Burca, G. Fardell, E. Papoutsellis, E. Pasca, K. Thielemans, M. Turner, R. Warr, W. R. B. Lionheart, and P. J. Withers. Core imaging library - part i: a versatile python framework for tomographic imaging. <em>Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences</em>, 379(2204):20200192, 2021. URL: <a class="reference external" href="https://royalsocietypublishing.org/doi/abs/10.1098/rsta.2020.0192">https://royalsocietypublishing.org/doi/abs/10.1098/rsta.2020.0192</a>, <a class="reference external" href="https://arxiv.org/abs/https://royalsocietypublishing.org/doi/pdf/10.1098/rsta.2020.0192">arXiv:https://royalsocietypublishing.org/doi/pdf/10.1098/rsta.2020.0192</a>, <a class="reference external" href="https://doi.org/10.1098/rsta.2020.0192">doi:10.1098/rsta.2020.0192</a>.</p>
</div>
<div class="citation" id="id57" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">8</a><span class="fn-bracket">]</span></span>
<p>Avinash C. Kak and Malcolm Slaney. <em>Principles of Computerized Tomographic Imaging</em>. Society for Industrial and Applied Mathematics, January 2001. URL: <a class="reference external" href="https://doi.org/10.1137/1.9780898719277">https://doi.org/10.1137/1.9780898719277</a>, <a class="reference external" href="https://doi.org/10.1137/1.9780898719277">doi:10.1137/1.9780898719277</a>.</p>
</div>
<div class="citation" id="id49" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">9</a><span class="fn-bracket">]</span></span>
<p>Yurii Nesterov. <em>Introductory lectures on convex optimization: A basic course</em>. Volume 87. Springer Science &amp; Business Media, 2003.</p>
</div>
<div class="citation" id="id52" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id12">10</a><span class="fn-bracket">]</span></span>
<p>Evangelos Papoutsellis, Evelina Ametova, Claire Delplancke, Gemma Fardell, Jakob S. Jörgensen, Edoardo Pasca, Martin Turner, Ryan Warr, William R. B. Lionheart, and Philip J. Withers. Core imaging library - part ii: multichannel reconstruction for dynamic and spectral tomography. <em>Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences</em>, 379(2204):20200193, 2021. URL: <a class="reference external" href="https://royalsocietypublishing.org/doi/abs/10.1098/rsta.2020.0193">https://royalsocietypublishing.org/doi/abs/10.1098/rsta.2020.0193</a>, <a class="reference external" href="https://arxiv.org/abs/https://royalsocietypublishing.org/doi/pdf/10.1098/rsta.2020.0193">arXiv:https://royalsocietypublishing.org/doi/pdf/10.1098/rsta.2020.0193</a>, <a class="reference external" href="https://doi.org/10.1098/rsta.2020.0193">doi:10.1098/rsta.2020.0193</a>.</p>
</div>
<div class="citation" id="id56" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id20">11</a><span class="fn-bracket">]</span></span>
<p>Julian Rasch and Antonin Chambolle. Inexact first-order primal–dual algorithms. <em>Computational Optimization and Applications</em>, 76(2):381–430, Jun 2020. URL: <a class="reference external" href="https://doi.org/10.1007/s10589-020-00186-y">https://doi.org/10.1007/s10589-020-00186-y</a>, <a class="reference external" href="https://doi.org/10.1007/s10589-020-00186-y">doi:10.1007/s10589-020-00186-y</a>.</p>
</div>
<div class="citation" id="id58" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id19">12</a><span class="fn-bracket">]</span></span>
<p>Mingqiang Zhu, Stephen J. Wright, and Tony F. Chan. Duality-based algorithms for total-variation-regularized image restoration. <em>Computational Optimization and Applications</em>, 47(3):377–400, Nov 2010. URL: <a class="reference external" href="https://doi.org/10.1007/s10589-008-9225-2">https://doi.org/10.1007/s10589-008-9225-2</a>, <a class="reference external" href="https://doi.org/10.1007/s10589-008-9225-2">doi:10.1007/s10589-008-9225-2</a>.</p>
</div>
</div>
</div>
</section>
</section>
</section>


                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="../io/"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Read/ write AcquisitionData and ImageData</p>
      </div>
    </a>
    <a class="right-next"
       href="../processors/"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Processors</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../_static/scripts/bootstrap.js?digest=4b6f475cff7c1d6e2a7b"></script>
<script defer src="../_static/scripts/pydata-sphinx-theme.js?digest=4b6f475cff7c1d6e2a7b"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2017-2024.
      <br/>
    
  </p>
</div>
      
    </div>
  
  
  
</div>

  </footer>
  </body>
</html>